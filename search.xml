<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>9. Python-Pandas-Miscellaneous</title>
      <link href="2020/12/14/Python9-Pandas-Miscellaneous/"/>
      <url>2020/12/14/Python9-Pandas-Miscellaneous/</url>
      
        <content type="html"><![CDATA[<p>其实重要和常用的功能已经系统的介绍完了。这篇主要是查漏补缺一些function。</p><a id="more"></a><p>推荐大家熟悉这个<a href="https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf" target="_blank" rel="noopener">cheat sheet</a>，一般的学习工作需要的功能都能在里面找到类似的列子。所以我们根据这个cheat sheet查漏补缺还没有提及的功能和用法。</p><h2 id="multiindex"><a class="markdownIt-Anchor" href="#multiindex"></a> MultiIndex</h2><p>一般情况下，我们会直接读入数据，而不是生成数据，所以手动传入MultiIndex的机会不多。更常见的是当我们按照多列GroupBy之后，Index是按照GroupBy中列的顺序进行分级，最左边的列名是最高级，最右边的列名是最低级。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npcolumns = [<span class="hljs-string">'Sub'</span> + x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> np.array(np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>)).astype(str)]df = pd.DataFrame(np.random.randint(<span class="hljs-number">40</span>, <span class="hljs-number">100</span>, (<span class="hljs-number">40</span>, <span class="hljs-number">8</span>)),             columns = columns)df[<span class="hljs-string">'School'</span>] = [<span class="hljs-string">'S_1'</span>] * <span class="hljs-number">20</span> + [<span class="hljs-string">'S_2'</span>] * <span class="hljs-number">20</span>df[<span class="hljs-string">'Class'</span>] = [<span class="hljs-string">'C_1'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_2'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_3'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_4'</span>] * <span class="hljs-number">5</span> + \[<span class="hljs-string">'C_1'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_2'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_3'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_4'</span>] * <span class="hljs-number">5</span>df[<span class="hljs-string">'StudentID'</span>] = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">41</span>)df = df[[<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>, <span class="hljs-string">'StudentID'</span>] + columns[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]]df.groupby([<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>])\[columns[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]].mean()</code></pre><img src="/images/python9/p1.png" width="500"/><p>去除嵌套关系可以用<code>df.reset_index()</code>。</p><h2 id="query"><a class="markdownIt-Anchor" href="#query"></a> query</h2><p>选择符合条件的行</p><pre class="highlight"><code class="python">df.query(<span class="hljs-string">'Sub1 &gt; 90'</span>)df.query(<span class="hljs-string">'Sub1 &gt; 90 and Sub2 &gt; 90'</span>)</code></pre><h2 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h2><p>日期是数据中常见的一列，Date类型不属于数值型也不属于字符型。<br />将Integer转化为Date：</p><pre class="highlight"><code class="python">pd.to_datetime(<span class="hljs-string">'20200101'</span>)pd.to_datetime(<span class="hljs-string">'2020-01-01'</span>)pd.to_datetime(<span class="hljs-string">'2020/01/01'</span>)pd.to_datetime(<span class="hljs-string">'20200101'</span>).yearpd.to_datetime(<span class="hljs-string">'20200101'</span>).monthpd.to_datetime(<span class="hljs-string">'20200101'</span>).daypd.to_datetime(<span class="hljs-string">'202001'</span>, format = <span class="hljs-string">'%Y%m'</span>)<span class="hljs-comment"># 移动日期</span><span class="hljs-keyword">import</span> datetimepd.to_datetime(<span class="hljs-string">'202001'</span>, format = <span class="hljs-string">'%Y%m'</span>) + datetime.timedelta(days=<span class="hljs-number">5</span>)<span class="hljs-comment"># date to string</span>str(pd.to_datetime(<span class="hljs-string">'202001'</span>, format = <span class="hljs-string">'%Y%m'</span>) + datetime.timedelta(days=<span class="hljs-number">5</span>))</code></pre><h2 id="strcontains"><a class="markdownIt-Anchor" href="#strcontains"></a> str.contains</h2><p>筛选符合条件的字符串</p><pre class="highlight"><code class="python">df2 = pd.DataFrame({<span class="hljs-string">'name'</span>: [<span class="hljs-string">'Bob_James'</span>, <span class="hljs-string">'Hunter_James'</span>, <span class="hljs-string">'Alice_Peter'</span>],                   <span class="hljs-string">'score'</span>: [<span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">100</span>]})df2df2.name.str.contains(<span class="hljs-string">'James'</span>)df2[df2.name.str.contains(<span class="hljs-string">'James'</span>)]</code></pre><h2 id="qcut"><a class="markdownIt-Anchor" href="#qcut"></a> qcut</h2><p>把Series切成分量相等（几乎相等）的小段，如果unique值的个数比分数小，则报错无法切。</p><pre class="highlight"><code class="python">pd.qcut(np.arange(<span class="hljs-number">10</span>), <span class="hljs-number">3</span>)pd.qcut(np.arange(<span class="hljs-number">10</span>), <span class="hljs-number">3</span>, labels = [<span class="hljs-string">'low'</span>, <span class="hljs-string">'medium'</span>, <span class="hljs-string">'high'</span>])pd.qcut([<span class="hljs-number">1</span>] * <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, labels = [<span class="hljs-string">'low'</span>, <span class="hljs-string">'medium'</span>, <span class="hljs-string">'high'</span>]) <span class="hljs-comment"># Error</span></code></pre><h2 id="shift-rank"><a class="markdownIt-Anchor" href="#shift-rank"></a> shift &amp; rank</h2><p>纵向移动列</p><pre class="highlight"><code class="python">df[<span class="hljs-string">'Sub1_next'</span>] = df.Sub1.shift(<span class="hljs-number">-1</span>)df[<span class="hljs-string">'Sub1_pre'</span>] = df.Sub1.shift(<span class="hljs-number">1</span>)df</code></pre><p>排序（GroupBy排序）</p><pre class="highlight"><code class="python">df[<span class="hljs-string">'rank_overall'</span>] = df[<span class="hljs-string">'Sub1'</span>].rank(ascending = <span class="hljs-literal">False</span>).astype(int)df[<span class="hljs-string">'rank_school'</span>] = df.groupby(<span class="hljs-string">'School'</span>)[<span class="hljs-string">'Sub1'</span>].rank(ascending = <span class="hljs-literal">False</span>).astype(int)df[<span class="hljs-string">'rank_class'</span>] = df.groupby([<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>])[<span class="hljs-string">'Sub1'</span>]\      .rank(ascending = <span class="hljs-literal">False</span>).astype(int)df</code></pre><h2 id="isin"><a class="markdownIt-Anchor" href="#isin"></a> isin</h2><p>查看一个Series的每个值是否在另一个Series里面，返回的布尔数组可以当作index用于筛选行。</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 选出df1中符合条件的行：df1的x在df2的y中出现过</span>df1[df1.x.isin(df2.y)]</code></pre><h2 id="rolling"><a class="markdownIt-Anchor" href="#rolling"></a> rolling</h2><p>求rolling window的统计量</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 包括自己的前五个求mean</span>df.Sub1.rolling(<span class="hljs-number">5</span>).mean()</code></pre><h2 id="drop_duplicates"><a class="markdownIt-Anchor" href="#drop_duplicates"></a> drop_duplicates</h2><pre class="highlight"><code class="python">df2 = pd.DataFrame({<span class="hljs-string">'name'</span>: [<span class="hljs-string">'Bob_James'</span>, <span class="hljs-string">'Hunter_James'</span>, <span class="hljs-string">'Bob_James'</span>],                   <span class="hljs-string">'score'</span>: [<span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>]})df2df2.drop_duplicates() <span class="hljs-comment"># 默认keep第一个</span>df2.drop_duplicates(keep = <span class="hljs-string">'last'</span>) <span class="hljs-comment"># 保留最后一个</span>df2.drop_duplicates(keep = <span class="hljs-literal">False</span>) <span class="hljs-comment"># 只要重复，都去掉</span></code></pre><h2 id="plotting"><a class="markdownIt-Anchor" href="#plotting"></a> Plotting</h2><p>更多例子参考：<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html" target="_blank" rel="noopener">https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html</a></p><pre class="highlight"><code class="python">ts = pd.Series(np.random.randn(<span class="hljs-number">1000</span>),            index=pd.date_range(<span class="hljs-string">'1/1/2000'</span>, periods=<span class="hljs-number">1000</span>))ts.cumsum().plot()df = pd.DataFrame(np.random.randn(<span class="hljs-number">1000</span>, <span class="hljs-number">4</span>),                  index=ts.index,                  columns=[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>])df.cumsum().plot()df.iloc[<span class="hljs-number">5</span>].plot(kind=<span class="hljs-string">'bar'</span>)df2 = pd.DataFrame(np.random.rand(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>), columns=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])df2.plot.bar()df2.plot.bar(stacked=<span class="hljs-literal">True</span>)df2.plot.barh(stacked=<span class="hljs-literal">True</span>)<span class="hljs-comment"># save plot</span>df2.plot.barh(stacked=<span class="hljs-literal">True</span>).figure.savefig(<span class="hljs-string">'demo-file.pdf'</span>)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8. Python8-Pandas-Reshape</title>
      <link href="2020/12/11/Python8-Pandas-Pivot/"/>
      <url>2020/12/11/Python8-Pandas-Pivot/</url>
      
        <content type="html"><![CDATA[<p>像Numpy Array的reshape一样，Pandas DataFrame也是可以reshape的。但由于DataFrame的行和列分别都是有明确意义的，并且各自有自己的index，所以reshape之前，需要思考reshape之后的DataFrame应该是个什么样子。所以，在进行coding之前，在纸上画出自己想要的形式是一个很有帮助的习惯。</p><a id="more"></a><h2 id="melt"><a class="markdownIt-Anchor" href="#melt"></a> Melt</h2><!-- ![Alt text](/images/python8/p5.png){:height="50%" width="50%"} --><img src="/images/python8/p5.png" width="700"/><p>如果我们生成下一个Dataset:</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npcolumns = [<span class="hljs-string">'Sub'</span> + x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> np.array(np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>)).astype(str)]df = pd.DataFrame(np.random.randint(<span class="hljs-number">40</span>, <span class="hljs-number">100</span>, (<span class="hljs-number">40</span>, <span class="hljs-number">8</span>)),             columns = columns)df[<span class="hljs-string">'School'</span>] = [<span class="hljs-string">'S_1'</span>] * <span class="hljs-number">20</span> + [<span class="hljs-string">'S_2'</span>] * <span class="hljs-number">20</span>df[<span class="hljs-string">'Class'</span>] = [<span class="hljs-string">'C_1'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_2'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_3'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_4'</span>] * <span class="hljs-number">5</span> + \[<span class="hljs-string">'C_1'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_2'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_3'</span>] * <span class="hljs-number">5</span> + [<span class="hljs-string">'C_4'</span>] * <span class="hljs-number">5</span>df[<span class="hljs-string">'StudentID'</span>] = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">41</span>)df = df[[<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>, <span class="hljs-string">'StudentID'</span>] + columns]</code></pre><img src="/images/python8/p1.png" width="500"/><p>如果我们想看每个学校的每个班级的各项平均成绩可以直接用：</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 在Jupyter中，如果换行之后，前一句可以被当作一句完整的语句，</span><span class="hljs-comment"># 系统会分开处理两句，所以这时需要在第一句后面加一个斜杠\来表示“这句没有结束”</span>df.groupby([<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>])\[[<span class="hljs-string">'Sub1'</span>, <span class="hljs-string">'Sub2'</span>, <span class="hljs-string">'Sub3'</span>, <span class="hljs-string">'Sub4'</span>, <span class="hljs-string">'Sub5'</span>, <span class="hljs-string">'Sub6'</span>, <span class="hljs-string">'Sub7'</span>, <span class="hljs-string">'Sub8'</span>]].mean()</code></pre><img src="/images/python8/p2.png" width="500"/><p>如果我想看相对于每个Subject，不同的学校的平均成绩如何，应该要怎么办呢，这时，我们就需要将整个DataFrame换一种形式，将Sub变成一列，才能用GroupBy：</p><pre class="highlight"><code class="python">df2 = df.melt(id_vars = [<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>, <span class="hljs-string">'StudentID'</span>],        value_vars = [<span class="hljs-string">'Sub1'</span>, <span class="hljs-string">'Sub2'</span>, <span class="hljs-string">'Sub3'</span>, <span class="hljs-string">'Sub4'</span>, <span class="hljs-string">'Sub5'</span>, <span class="hljs-string">'Sub6'</span>, <span class="hljs-string">'Sub7'</span>, <span class="hljs-string">'Sub8'</span>],        var_name=<span class="hljs-string">'Subject'</span>, value_name=<span class="hljs-string">'Score'</span>)df2</code></pre><img src="/images/python8/p3.png" width="300"/><p>然后我们就能查看不同的学校在每个学科中的比较了。</p><pre class="highlight"><code class="python">df3 = df2.groupby([<span class="hljs-string">'Subject'</span>, <span class="hljs-string">'School'</span>])[<span class="hljs-string">'Score'</span>].agg([np.mean, np.min, np.max])df3</code></pre><img src="/images/python8/p4.png" width="300"/><p>行index出现了层次嵌套关系，如果想变成简单的index，可以用<code>df3.reset_index()</code>来去掉嵌套关系。如果想去掉列的嵌套关系，用<code>df3.columns = df3.columns.droplevel()</code>。</p><h2 id="pivot"><a class="markdownIt-Anchor" href="#pivot"></a> Pivot</h2><p>Melt是将不同的列整合成两列（variable，value），一列是表示原来的列名，一列是原来列对应的值。由宽矩阵转化为长矩阵。<br />Pivot就是将长矩阵转化为宽矩阵。<br /><img src="/images/python8/p6.png" width="700"/></p><p>继续用df3来做例子，先用<code>df3 = df3.reset_index()</code>去掉行index的嵌套关系，得到：<br /><img src="/images/python8/p7.png" width="300"/></p><p>然后用pivot将长型转化为宽型：</p><pre class="highlight"><code class="python">df3_mean = df3.pivot(index=<span class="hljs-string">'School'</span>, columns=<span class="hljs-string">'Subject'</span>, values=<span class="hljs-string">'mean'</span>)df3_mean</code></pre><img src="/images/python8/p8.png" width="500"/>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7. Python-Pandas分组和聚合</title>
      <link href="2020/12/09/Python7-Pandas-Grouping/"/>
      <url>2020/12/09/Python7-Pandas-Grouping/</url>
      
        <content type="html"><![CDATA[<p>GroupBy是数据处理最常用的形式之一。整个GroupBy的过程可以分为&quot;Split-Apply-Combine&quot;（拆分-应用-合并）三个阶段。</p><a id="more"></a><h2 id="groupby"><a class="markdownIt-Anchor" href="#groupby"></a> GroupBy</h2><p>过程：</p><ul><li><strong>Splitting</strong> the data into groups based on some criteria</li><li><strong>Applying</strong> a function to each group independently</li><li><strong>Combining</strong> the results into a data structure<br /><img src="/images/python7/SAC.jpg" alt="Alt text" /></li></ul><p>作用：<br />In the <strong>apply</strong> step, we might wish to do one of the following:</p><ul><li><strong>Aggregation</strong>: 为每个group计算统计量，例如，group sums/group means/group sizes/group counts</li><li><strong>Transformation</strong>: 每个group中的每一行都会有个计算值，例如，standardize data within a group</li><li><strong>Filtration</strong>: 用于去掉一些group，例如，只想留下平均分大于60的班级</li></ul><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pddf = pd.read_csv(<span class="hljs-string">'https://raw.githubusercontent.com/yeayee/joyful-pandas/master/data/table.csv'</span>)df.head() <span class="hljs-comment"># 查看前5行</span>df.shape <span class="hljs-comment"># 查看shape</span>df.dtypes <span class="hljs-comment"># 查看数据类型</span><span class="hljs-comment"># 按照School分组</span>df.School.value_counts() <span class="hljs-comment"># 统计School列不同值的count</span>df_single_group = df.groupby(<span class="hljs-string">'School'</span>) <span class="hljs-comment"># 按照School分组</span>df_single_group.size() <span class="hljs-comment"># 查看分组情况</span>df_single_group.get_group(<span class="hljs-string">'S_2'</span>) <span class="hljs-comment"># 分别查看group的DataFrame</span><span class="hljs-comment"># 查看每个组</span><span class="hljs-keyword">for</span> name, group <span class="hljs-keyword">in</span> df.groupby(<span class="hljs-string">'School'</span>):    print(name)    print(group)<span class="hljs-comment"># 按照School和Class分组</span>df_multi_group = df.groupby([<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>], dropna = <span class="hljs-literal">True</span>) <span class="hljs-comment"># School为第一level，Class为第二level</span>df_multi_group.size() <span class="hljs-comment"># 查看分组情况</span>df_multi_group.get_group((<span class="hljs-string">'S_2'</span>, <span class="hljs-string">'C_1'</span>)) <span class="hljs-comment"># 查看具体的一个分组，注意是圆括号</span></code></pre><h2 id="aggregation"><a class="markdownIt-Anchor" href="#aggregation"></a> Aggregation</h2><p>生成的结果会比原DataFrame的行数少。与R里面的dplyr的summarize类似。</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 用Series自带的function，单个function</span>df.groupby(<span class="hljs-string">'School'</span>)[<span class="hljs-string">'Math'</span>].mean() <span class="hljs-comment"># 选择感兴趣的列，进行计算，得到结果</span>df.groupby(<span class="hljs-string">'School'</span>)[<span class="hljs-string">'Math'</span>].std() <span class="hljs-comment"># mean函数可以替换成任何统计描述: nth()/min()/max()</span>df.groupby(<span class="hljs-string">'School'</span>)[<span class="hljs-string">'Math'</span>].nlargest(<span class="hljs-number">3</span>) <span class="hljs-comment"># 每个学校的数学前三名，可替换nsmallest</span>df.groupby([<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>])[<span class="hljs-string">'Height'</span>].mean() <span class="hljs-comment"># 选择感兴趣的列，进行计算，得到结果</span>df.groupby([<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>])[<span class="hljs-string">'Height'</span>].std() <span class="hljs-comment"># mean函数可以替换成任何统计描述</span>df.groupby([<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>])[<span class="hljs-string">'Height'</span>].mean().reset_index() <span class="hljs-comment"># 规范成DataFrame</span><span class="hljs-comment"># 同时计算多个Numpy function</span>df.groupby(<span class="hljs-string">'School'</span>)[<span class="hljs-string">'Math'</span>].agg([np.sum, np.mean, np.std])df.groupby(<span class="hljs-string">'School'</span>)[<span class="hljs-string">'Math'</span>, <span class="hljs-string">'Height'</span>].agg([np.sum, np.mean, np.std])<span class="hljs-comment"># 同时计算多个自定义的function</span>df.groupby(<span class="hljs-string">'School'</span>)[<span class="hljs-string">'Math'</span>].agg(max_min = (<span class="hljs-keyword">lambda</span> y : y.max() - y.min()),                                 median_mean = (<span class="hljs-keyword">lambda</span> y : y.median() - y.mean())) <span class="hljs-comment"># 同一列使用不同的function</span></code></pre><h2 id="transformation"><a class="markdownIt-Anchor" href="#transformation"></a> Transformation</h2><p>生成的结果和原DataFrame的行数一样。与R里面的dplyr的mutate类似。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npindex = pd.date_range(<span class="hljs-string">'10/1/1999'</span>, periods=<span class="hljs-number">1100</span>)df = pd.DataFrame({<span class="hljs-string">'data'</span>: np.random.normal(<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1100</span>)}, index = index)<span class="hljs-comment"># 用存在的function</span>ts.groupby(ts.index.year).transform(<span class="hljs-string">'mean'</span>)ts.groupby(ts.index.year).transform(<span class="hljs-string">'std'</span>)<span class="hljs-comment"># 自己定义function</span>ts.groupby(ts.index.year)[<span class="hljs-string">'data'</span>].transform(<span class="hljs-keyword">lambda</span> x : (x - x.mean()) / x.std()) <span class="hljs-comment"># 按年来standardize</span></code></pre><h2 id="filtration"><a class="markdownIt-Anchor" href="#filtration"></a> Filtration</h2><p>选择符合条件的group</p><pre class="highlight"><code class="python">df = pd.read_csv(<span class="hljs-string">'https://raw.githubusercontent.com/yeayee/joyful-pandas/master/data/table.csv'</span>)df.groupby([<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>])[<span class="hljs-string">'Math'</span>].mean()df.groupby([<span class="hljs-string">'School'</span>, <span class="hljs-string">'Class'</span>]).filter(<span class="hljs-keyword">lambda</span> x : x[<span class="hljs-string">'Math'</span>].mean() &gt;= <span class="hljs-number">60</span>)  <span class="hljs-comment"># 只留下班级平均分大于等于60的record</span>df = pd.DataFrame({<span class="hljs-string">'A'</span>: np.arange(<span class="hljs-number">8</span>),                   <span class="hljs-string">'B'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'c'</span>]})dff.groupby(<span class="hljs-string">'B'</span>).filter(<span class="hljs-keyword">lambda</span> x: len(x) &gt; <span class="hljs-number">2</span>)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6. Python-Pandas数据前期处理</title>
      <link href="2020/12/07/Python6-Pandas-DataPreprocessing/"/>
      <url>2020/12/07/Python6-Pandas-DataPreprocessing/</url>
      
        <content type="html"><![CDATA[<p>在进入分析之前，我们通常要对获取的数据进行清理和处理，也就是大家常说的Data Cleaning。也是数据的前期处理，处理成我们所需要的数据，这个处理步骤需要非常细心，因为处理得当与否直接决定后续的分析是否准确，所以要多加检查，尽量没做完一步都检查一下自己的目的是否正确达到。</p><a id="more"></a><h2 id="数据选取"><a class="markdownIt-Anchor" href="#数据选取"></a> 数据选取</h2><table><thead><tr><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>用列名选取一些列</td><td><code>df[['col1', 'col2']]</code></td></tr><tr><td>用列的位置选取一些列</td><td><code>df.iloc[:, 0:2]</code></td></tr><tr><td>用index名选取一些行</td><td><code>df.loc[['row1', 'row2']]</code></td></tr><tr><td>用index的位置选取一些行</td><td><code>df.iloc[0:2, :]</code>或者<code>df[0:2]</code></td></tr><tr><td>选择符合条件的行</td><td><code>df[df.col1 != 0]</code></td></tr><tr><td>将DataFrame按照某一列或多列排序</td><td><code>df.sort_values(by = 'col1')</code></td></tr><tr><td>按列名去掉一些列</td><td><code>df.drop(['col1', 'col2'], axis = 1)</code></td></tr><tr><td>按列位置去掉一些列</td><td><code>df.drop(df.columns[0:2], axis = 1)</code></td></tr><tr><td>按index名去掉一些行</td><td><code>df.drop(['row1', 'row2'], axis = 0)</code></td></tr><tr><td>按index位置去掉一些列</td><td><code>df.drop(df.index[0:5], axis = 0)</code></td></tr><tr><td>重新自动生成index</td><td><code>df.reset_index(drop = true)</code></td></tr></tbody></table><h2 id="转换类型"><a class="markdownIt-Anchor" href="#转换类型"></a> 转换类型</h2><table><thead><tr><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>string to int</td><td><code>df.col.astype(int)</code></td></tr><tr><td>int to string</td><td><code>df.col.astype(str)</code></td></tr><tr><td>string to float</td><td><code>df.col.astype(float)</code></td></tr><tr><td>float to string</td><td><code>df.col.astype(str)</code></td></tr><tr><td>string to date</td><td><code>pd.to_datetime(df.col, ...) #参数参考官方文档</code></td></tr><tr><td>int to date</td><td><code>pd.to_datetime(df.col, ...) #参数参考官方文档</code></td></tr></tbody></table><h2 id="数据合并"><a class="markdownIt-Anchor" href="#数据合并"></a> 数据合并</h2><h3 id="merge"><a class="markdownIt-Anchor" href="#merge"></a> Merge</h3><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pddf1 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>],                    <span class="hljs-string">'data1'</span>: range(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>)})df2 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>],                   <span class="hljs-string">'data2'</span>: range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)})pd.merge(df1, df2, on = <span class="hljs-string">'key'</span>) <span class="hljs-comment"># 默认是inner join，取键的交集，默认把重叠的列名当作键</span>pd.merge(df1, df2, on = <span class="hljs-string">'key'</span>, how = <span class="hljs-string">'outer'</span>) <span class="hljs-comment"># outer join，取键的并集</span>pd.merge(df1, df2, on = <span class="hljs-string">'key'</span>, how = <span class="hljs-string">'left'</span>) <span class="hljs-comment"># left join，保留左边DataFrame的全部键</span>pd.merge(df1, df2, on = <span class="hljs-string">'key'</span>, how = <span class="hljs-string">'right'</span>) <span class="hljs-comment"># right join，保留右边DataFrame的全部键</span><span class="hljs-comment"># 如果两个DataFrame没有相同的列名当作键，可分别指定</span>df3 = pd.DataFrame({<span class="hljs-string">'key1'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>],                    <span class="hljs-string">'data1'</span>: range(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>)})df4 = pd.DataFrame({<span class="hljs-string">'key2'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>],                   <span class="hljs-string">'data2'</span>: range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)})pd.merge(df3, df4, left_on = <span class="hljs-string">'key1'</span>, right_on = <span class="hljs-string">'key2'</span>, how = <span class="hljs-string">'outer'</span>)<span class="hljs-comment"># 如果两个DataFrame有重叠的列名，但不是当作键使用，需要分别保留下来，可添加后缀</span>df5 = pd.DataFrame({<span class="hljs-string">'key1'</span>: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>],                    <span class="hljs-string">'key2'</span>: [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'one'</span>],                    <span class="hljs-string">'data1'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]})df6 = pd.DataFrame({<span class="hljs-string">'key1'</span>: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'bar'</span>],                    <span class="hljs-string">'key2'</span>: [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'one'</span>],                    <span class="hljs-string">'data2'</span>: [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]})pd.merge(df5, df6, on = <span class="hljs-string">'key1'</span>, suffixes = [<span class="hljs-string">'_left'</span>, <span class="hljs-string">'_right'</span>])<span class="hljs-comment"># 按照index进行merge</span>pd.merge(df5, df6, left_index = <span class="hljs-literal">True</span>, right_index = <span class="hljs-literal">True</span>, how = <span class="hljs-string">'outer'</span>)</code></pre><h3 id="concat"><a class="markdownIt-Anchor" href="#concat"></a> Concat</h3><p>行堆积</p><pre class="highlight"><code class="python">df1 = pd.DataFrame({<span class="hljs-string">'A'</span>: [<span class="hljs-string">'A0'</span>, <span class="hljs-string">'A1'</span>, <span class="hljs-string">'A2'</span>, <span class="hljs-string">'A3'</span>],                    <span class="hljs-string">'B'</span>: [<span class="hljs-string">'B0'</span>, <span class="hljs-string">'B1'</span>, <span class="hljs-string">'B2'</span>, <span class="hljs-string">'B3'</span>],                    <span class="hljs-string">'C'</span>: [<span class="hljs-string">'C0'</span>, <span class="hljs-string">'C1'</span>, <span class="hljs-string">'C2'</span>, <span class="hljs-string">'C3'</span>],                    <span class="hljs-string">'D'</span>: [<span class="hljs-string">'D0'</span>, <span class="hljs-string">'D1'</span>, <span class="hljs-string">'D2'</span>, <span class="hljs-string">'D3'</span>]},                    index=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])df2 = pd.DataFrame({<span class="hljs-string">'A'</span>: [<span class="hljs-string">'A4'</span>, <span class="hljs-string">'A5'</span>, <span class="hljs-string">'A6'</span>, <span class="hljs-string">'A7'</span>],                    <span class="hljs-string">'B'</span>: [<span class="hljs-string">'B4'</span>, <span class="hljs-string">'B5'</span>, <span class="hljs-string">'B6'</span>, <span class="hljs-string">'B7'</span>],                    <span class="hljs-string">'C'</span>: [<span class="hljs-string">'C4'</span>, <span class="hljs-string">'C5'</span>, <span class="hljs-string">'C6'</span>, <span class="hljs-string">'C7'</span>],                    <span class="hljs-string">'D'</span>: [<span class="hljs-string">'D4'</span>, <span class="hljs-string">'D5'</span>, <span class="hljs-string">'D6'</span>, <span class="hljs-string">'D7'</span>]},                    index=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])df3 = pd.DataFrame({<span class="hljs-string">'A'</span>: [<span class="hljs-string">'A8'</span>, <span class="hljs-string">'A9'</span>, <span class="hljs-string">'A10'</span>, <span class="hljs-string">'A11'</span>],                    <span class="hljs-string">'B'</span>: [<span class="hljs-string">'B8'</span>, <span class="hljs-string">'B9'</span>, <span class="hljs-string">'B10'</span>, <span class="hljs-string">'B11'</span>],                    <span class="hljs-string">'C'</span>: [<span class="hljs-string">'C8'</span>, <span class="hljs-string">'C9'</span>, <span class="hljs-string">'C10'</span>, <span class="hljs-string">'C11'</span>],                    <span class="hljs-string">'D'</span>: [<span class="hljs-string">'D8'</span>, <span class="hljs-string">'D9'</span>, <span class="hljs-string">'D10'</span>, <span class="hljs-string">'D11'</span>]},                    index=[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])pd.concat([df1, df2, df3]) <span class="hljs-comment"># 方式一，添加参数 ignore_index=True 使index重新生成</span>df1.append(df2).append(df3) <span class="hljs-comment"># 方式二</span></code></pre><p><img src="/images/python6/merge_concat.png" alt="Alt text" /></p><hr /><p>列堆积</p><pre class="highlight"><code class="python">df4 = pd.DataFrame({<span class="hljs-string">'B'</span>: [<span class="hljs-string">'B2'</span>, <span class="hljs-string">'B3'</span>, <span class="hljs-string">'B6'</span>, <span class="hljs-string">'B7'</span>],                    <span class="hljs-string">'D'</span>: [<span class="hljs-string">'D2'</span>, <span class="hljs-string">'D3'</span>, <span class="hljs-string">'D6'</span>, <span class="hljs-string">'D7'</span>],                    <span class="hljs-string">'F'</span>: [<span class="hljs-string">'F2'</span>, <span class="hljs-string">'F3'</span>, <span class="hljs-string">'F6'</span>, <span class="hljs-string">'F7'</span>]},                    index=[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])pd.concat([df1, df4], axis = <span class="hljs-number">1</span>)</code></pre><p><img src="/images/python6/merge_concat_col.png" alt="Alt text" /></p><h2 id="填充缺失"><a class="markdownIt-Anchor" href="#填充缺失"></a> 填充缺失</h2><pre class="highlight"><code class="python">df = pd.DataFrame([[np.nan, <span class="hljs-number">2</span>, np.nan, <span class="hljs-number">0</span>],                   [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, np.nan, <span class="hljs-number">1</span>],                   [np.nan, np.nan, np.nan, <span class="hljs-number">5</span>],                   [np.nan, <span class="hljs-number">3</span>, np.nan, <span class="hljs-number">4</span>]],                  columns = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>])<span class="hljs-comment"># 寻找缺失的行和列</span>df.isnull() <span class="hljs-comment"># 查看每个值</span>df.isnull().sum() <span class="hljs-comment"># 统计空值</span>df.isnull().any(axis = <span class="hljs-number">0</span>) <span class="hljs-comment"># 哪些列含有至少一个空值，可作为筛选的条件</span>df.isnull().any(axis = <span class="hljs-number">1</span>) <span class="hljs-comment"># 哪些行含有至少一个空值，可作为筛选的条件</span>df.isnull().all(axis = <span class="hljs-number">0</span>) <span class="hljs-comment"># 哪些列全部都是空值，可作为筛选的条件</span>df.isnull().all(axis = <span class="hljs-number">1</span>) <span class="hljs-comment"># 哪些行全部都是空值，可作为筛选的条件</span>df.loc[:, df.isnull().all(axis = <span class="hljs-number">0</span>)]<span class="hljs-comment"># 填充</span>df.fillna(<span class="hljs-number">0</span>) <span class="hljs-comment"># 用0填充</span>df.fillna(method = <span class="hljs-string">'ffill'</span>) <span class="hljs-comment"># 用前一个值填充</span>df.fillna(value = {<span class="hljs-string">'A'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'B'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'C'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'D'</span>: <span class="hljs-number">3</span>}) <span class="hljs-comment"># 不同列的NaN值用不同的值填充</span>df.fillna(value = {<span class="hljs-string">'A'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'B'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'C'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'D'</span>: <span class="hljs-number">3</span>}, limit = <span class="hljs-number">1</span>) <span class="hljs-comment"># 每列只填充第一个NaN值</span><span class="hljs-comment"># 丢掉含有缺失的行，不声明axis就是默认对行进行操作</span>df.dropna(how = <span class="hljs-string">'any'</span>) <span class="hljs-comment"># 只要含有NaN的行就去掉</span>df.dropna(how = <span class="hljs-string">'all'</span>) <span class="hljs-comment"># 要全是NaN的行才去掉</span>df.dropna(thresh = <span class="hljs-number">2</span>)  <span class="hljs-comment"># 留下至少2个非空的的行</span>df.dropna(how = <span class="hljs-string">'any'</span>, subset = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>]) <span class="hljs-comment"># 只在乎其中几列的空缺情况</span></code></pre><h2 id="描述统计"><a class="markdownIt-Anchor" href="#描述统计"></a> 描述统计</h2><pre class="highlight"><code class="python">df = pd.read_csv(<span class="hljs-string">'https://raw.githubusercontent.com/justmarkham/DAT8/master/data/u.user'</span>,                  sep = <span class="hljs-string">'|'</span>,                  index_col = <span class="hljs-string">'user_id'</span>)df.sort_values(by = <span class="hljs-string">'zip_code'</span>) <span class="hljs-comment"># 将整个DataFrame按照某一列排序，查看tail，找到分界点</span>new_df = df.loc[df.zip_code &lt;= <span class="hljs-string">'99835'</span>].copy() <span class="hljs-comment"># 将正常的部分截取</span>new_df.zip_code = new_df.zip_code.astype(int) <span class="hljs-comment"># 将zip_code转化为integer</span>new_df.describe() <span class="hljs-comment"># 整个DataFrame的数值型列的统计</span>new_df.gender.describe() <span class="hljs-comment"># 单列的统计</span>new_df.gender.nunique() <span class="hljs-comment"># 这一列就多少个unique的值，一般用于类型为字符串的列</span>new_df.gender.value_counts() <span class="hljs-comment"># 每个unique值的出现频率，一般用于类型为字符串的列</span></code></pre><table><thead><tr><th>方法</th><th>说明 （基本都是对列进行操作）</th></tr></thead><tbody><tr><td>count</td><td>非空值的数量</td></tr><tr><td>min, max</td><td>计算最小值和最大值</td></tr><tr><td>argmin, argmax</td><td>最小值和最大值的索引位置</td></tr><tr><td>idxmin, idxmax</td><td>最小值和最大值的索引值</td></tr><tr><td>quantile</td><td>分位数</td></tr><tr><td>sum</td><td>求和</td></tr><tr><td>mean</td><td>求mean</td></tr><tr><td>median</td><td>求median</td></tr><tr><td>var</td><td>求方差</td></tr><tr><td>std</td><td>求标准差</td></tr><tr><td>skew</td><td>求偏度</td></tr><tr><td>kurt</td><td>求峰度</td></tr><tr><td>cumsum</td><td>求累计和</td></tr><tr><td>cummin，cummax</td><td>累计最小值和累计最大值</td></tr><tr><td>cumprod</td><td>累计积</td></tr><tr><td>diff</td><td>一阶差分（对时间序列很有用）</td></tr><tr><td>pct_change</td><td>百分数变化（自动用前一个数填充空值）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5. Python-Pandas读写文件</title>
      <link href="2020/12/07/Python5-Pandas-ReadWriteFile/"/>
      <url>2020/12/07/Python5-Pandas-ReadWriteFile/</url>
      
        <content type="html"><![CDATA[<p>如果不能将数据导入导出Python，那学习Numpy和Pandas也就没什么意义了。所以本教程将着重介绍Pandas的输入输出函数，这些函数将表格型数据直接读取为DataFrame。</p><a id="more"></a><p>本文主要介绍两组函数，<code>pd.read_csv()</code>和<code>pd.to_csv()</code>，用来导入和导出csv文件；<code>pd.read_excel()</code>和<code>pd.to_excel()</code>，用来导入和导出excel文件。但是Pandas还有其他的文件读写函数，如果这两组不能解决问题，大家可以再去学习其他的。一般只会用到这两组。</p><h2 id="读写csv"><a class="markdownIt-Anchor" href="#读写csv"></a> 读写csv</h2><p>csv（<strong>C</strong>omma-<strong>S</strong>eparated <strong>V</strong>alues）文件是一个由逗号隔开数值的文本文件。每一行是一个observation，由多个feature值组成，用逗号隔开。</p><h3 id="read_csv"><a class="markdownIt-Anchor" href="#read_csv"></a> read_csv</h3><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" target="_blank" rel="noopener">官方文档</a></p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pdpd.read_csv(filepath_or_buffer, <span class="hljs-comment"># 文件的路径或者url</span>            sep = <span class="hljs-string">','</span>, <span class="hljs-comment"># 隔开符默认是逗号，可以读取非逗号隔开的文件，如果是tab隔开的，替换为'\t'</span>            header = <span class="hljs-number">0</span>, <span class="hljs-comment"># 列名默认为第一行</span>            names = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 如果需要传入指定的列名，header = None, names = ['col1', 'col2',...]</span>            index_col = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 指定行的index，默认是系统生成0到N-1</span>            usecols = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 读取指定列，默认是读取全部列</span>            nrows = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 读取前几行，默认是读取全部行</span>            )</code></pre><h3 id="to_csv"><a class="markdownIt-Anchor" href="#to_csv"></a> to_csv</h3><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html#pandas.DataFrame.to_csv" target="_blank" rel="noopener">官方文档</a></p><pre class="highlight"><code class="python">DataFrame.to_csv(path_or_buf, <span class="hljs-comment"># 输出文件的路径</span>                 sep = <span class="hljs-string">','</span>, <span class="hljs-comment"># 指定输出的分隔符，默认是逗号</span>                 columns = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 指定输出的列，默认是全部列</span>                 header = <span class="hljs-literal">True</span>, <span class="hljs-comment"># 是否输出列名，默认是输出</span>                 index = <span class="hljs-literal">True</span> <span class="hljs-comment"># 是否输出行index，默认是输出</span>                 )</code></pre><h2 id="读写excel"><a class="markdownIt-Anchor" href="#读写excel"></a> 读写excel</h2><h3 id="read_excel"><a class="markdownIt-Anchor" href="#read_excel"></a> read_excel</h3><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html" target="_blank" rel="noopener">官方文档</a></p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pdpd.read_excel(io, <span class="hljs-comment"># excel文件的路径</span>              sheet_name = <span class="hljs-number">0</span>, <span class="hljs-comment"># 默认是读取第一个sheet，可以按位置指定，也可以按sheet名指定</span>              header = <span class="hljs-number">0</span>, <span class="hljs-comment"># 列名默认为第一行</span>              names = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 如果需要传入指定的列名，header = None, names = ['col1', 'col2',...]</span>              index_col = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 指定行的index，默认是系统生成0到N-1</span>              usecols = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 读取指定列，默认是读取全部列</span>              nrows = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 读取前几行，默认是读取全部行</span>              )</code></pre><h3 id="to_excel"><a class="markdownIt-Anchor" href="#to_excel"></a> to_excel</h3><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_excel.html#pandas.DataFrame.to_excel" target="_blank" rel="noopener">官方文档</a></p><pre class="highlight"><code class="python">DataFrame.to_excel(excel_writer, <span class="hljs-comment"># 输出文件的路径</span>                   sheet_name = <span class="hljs-string">'Sheet1'</span>, <span class="hljs-comment"># 输出的sheet名，默认是"Sheet1"</span>                   columns = <span class="hljs-literal">None</span>, <span class="hljs-comment"># 指定输出的列，默认是全部列</span>                   header = <span class="hljs-literal">True</span>, <span class="hljs-comment"># 是否输出列名，默认是输出</span>                   index = <span class="hljs-literal">True</span> <span class="hljs-comment"># 是否输出行index，默认是输出</span>                   )</code></pre><h2 id="演练"><a class="markdownIt-Anchor" href="#演练"></a> 演练</h2><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-comment"># 按照默认的逗号隔开导入</span>df = pd.read_csv(<span class="hljs-string">'https://raw.githubusercontent.com/justmarkham/DAT8/master/data/u.user'</span>)<span class="hljs-comment"># 指定分隔符</span>df = pd.read_csv(<span class="hljs-string">'https://raw.githubusercontent.com/justmarkham/DAT8/master/data/u.user'</span>,                  sep = <span class="hljs-string">'|'</span>)<span class="hljs-comment"># 指定index列</span>df = pd.read_csv(<span class="hljs-string">'https://raw.githubusercontent.com/justmarkham/DAT8/master/data/u.user'</span>,                  sep = <span class="hljs-string">'|'</span>,                  index_col = <span class="hljs-string">'user_id'</span>)<span class="hljs-comment"># 查看前15行</span>df.head(<span class="hljs-number">15</span>) <span class="hljs-comment"># 可查看任意数量的行数，替换15，不写的话默认是前5行</span><span class="hljs-comment"># 查看最后10行</span>df.tail(<span class="hljs-number">10</span>) <span class="hljs-comment"># 可查看任意数量的行数，替换10，不写的话默认是尾5行</span><span class="hljs-comment"># 没有print语句的打印行要运行在一个Jupyter的单独cell</span>df.shapedf.columnsdf.indexdf.dtypes <span class="hljs-comment"># zip_code应该是int，但是是object，说明不是所有的值都是数字，需要查看不正常值</span>df.sort_values(by = <span class="hljs-string">'zip_code'</span>) <span class="hljs-comment"># 将整个DataFrame按照某一列排序，查看tail，找到分界点</span>new_df = df.loc[df.zip_code &lt;= <span class="hljs-string">'99835'</span>].copy() <span class="hljs-comment"># 将正常的部分截取</span>new_df.zip_code = new_df.zip_code.astype(int) <span class="hljs-comment"># 将zip_code转化为integer</span>new_df.dtypes <span class="hljs-comment"># 再次查看类型</span><span class="hljs-comment"># 有多少unique的occupation</span>new_df.occupation.value_counts() <span class="hljs-comment"># 返回一个Series，统计每一个unique的值有多少个重复</span>len(new_df.occupation.value_counts()) <span class="hljs-comment"># 这个Series的长度就是unique值的个数</span><span class="hljs-comment"># summarize DataFrame</span>new_df.describe() <span class="hljs-comment"># generate numerical descriptive statistics</span><span class="hljs-comment"># summarize Series</span>new_df.occupation.describe()<span class="hljs-comment"># 求平均年龄</span>new_df.age.mean()<span class="hljs-comment"># 每个年龄出现的次数</span>new_df.age.value_counts()<span class="hljs-comment"># 输出csv文件</span>new_df.to_csv(<span class="hljs-string">'new_file.csv'</span>) <span class="hljs-comment"># 如果没有指定路径，输出的文件会和Jupyter Notebook在一个文件夹下</span>new_df.to_csv(<span class="hljs-string">'new_file.csv'</span>, index = <span class="hljs-literal">False</span>) <span class="hljs-comment"># 去掉index</span></code></pre><!-- 本教程练习所用数据从[这里](https://github.com/guipsamora/pandas_exercises)下载。 -->]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4. Python-Pandas介绍</title>
      <link href="2020/12/06/Python4-Pandas-Introduction/"/>
      <url>2020/12/06/Python4-Pandas-Introduction/</url>
      
        <content type="html"><![CDATA[<p>终于来到了这次学习的重点——Pandas，之前的教程都是为使用Pandas而打下的基础。Pandas是基于Numpy构建的，让以Numpy为中心的应用变得更简单。</p><a id="more"></a><p><strong>安装</strong>：使用Pandas之前需要安装，如果在Jupyter中执行<code>import pandas as pd</code>报错，说明还没有安装，请参考<a href="https://pearmonkey.com/2020/12/01/Python0-install-Jupyter_Notebook/">这篇</a>进行安装Pandas。</p><p><strong>使用</strong>：由于Pandas是基于Numpy构建的，所以Numpy里的所有计算函数都可以给Pandas应用，一般情况下，将两个包都导入:</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 以后在其他code里，看到pd就是pandas，np就是numpy</span><span class="hljs-comment"># 其实也可以把package里所有的function都import，from pandas import *，但是这不是一个好习惯</span><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</code></pre><h2 id="pandas数据结构"><a class="markdownIt-Anchor" href="#pandas数据结构"></a> Pandas数据结构</h2><h3 id="series"><a class="markdownIt-Anchor" href="#series"></a> Series</h3><p>Series是一种类似于一维数组的对象，由一组数据（Numpy数组或者Python数组）和一组与之相关的数据标签（即索引）组成。</p><pre class="highlight"><code class="python">a = pd.Series([<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">3</span>])a</code></pre><p>左边是索引，右边是值。默认索引是一个0到N-1（N为数据的长度）的整数型索引。Series有values和index两个属性。</p><pre class="highlight"><code class="python">print(a.values)print(a.index)</code></pre><p>可以传递定义好的索引，长度应和数组长度一致：</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 给现有的Series定义index</span>a.index = [<span class="hljs-string">'d'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>]print(a)a.index = [<span class="hljs-string">'d'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]print(a[<span class="hljs-string">'b'</span>])<span class="hljs-comment"># 生成Series时定义index</span>b = pd.Series([<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">3</span>], index = [<span class="hljs-string">'d'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>])print(b)print(b.index)print(b[<span class="hljs-string">'a'</span>]) <span class="hljs-comment"># 通过索引获取值</span>b[<span class="hljs-string">'a'</span>] = <span class="hljs-number">6</span> <span class="hljs-comment"># 通过索引修改值</span>print(b[[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]])</code></pre><p>Numpy数组的运算（根据条件语句筛选、矢量计算）都会保留索引和值之间的连接：</p><pre class="highlight"><code class="python">print(b)print(b[b &gt; <span class="hljs-number">5</span>])print(b * <span class="hljs-number">2</span>)print(np.exp(b))</code></pre><p>还可以通过字典Dict来创建Series，字典的key就是索引，value就是值：</p><pre class="highlight"><code class="python">x = {<span class="hljs-string">'Jeo'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'Tom'</span>: <span class="hljs-number">85</span>, <span class="hljs-string">'Alice'</span>: <span class="hljs-number">100</span>}y = pd.Series(x)print(y)</code></pre><p>在Pandas里，用<code>NaN</code>（<code>np.nan</code>）表示缺失值，可以用Pandas的isnull和notnull来检测缺失数据：</p><pre class="highlight"><code class="python">y[<span class="hljs-string">'Bob'</span>] = np.nanprint(y)print(pd.isnull(y))print(y.isnull()) <span class="hljs-comment"># Series也有同样的function</span>print(pd.notnull(y))</code></pre><p>Series的索引最重要的作用是，在算术运算中会按照索引自动对齐，没有对齐到的索引处用<code>NaN</code>填充：</p><pre class="highlight"><code class="python">x = pd.Series({<span class="hljs-string">'Jeo'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'Tom'</span>: <span class="hljs-number">85</span>, <span class="hljs-string">'Alice'</span>: <span class="hljs-number">100</span>})y = pd.Series({<span class="hljs-string">'Jeo'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'Tom'</span>: <span class="hljs-number">85</span>, <span class="hljs-string">'Bob'</span>: <span class="hljs-number">100</span>})print(x + y)</code></pre><h3 id="dataframe"><a class="markdownIt-Anchor" href="#dataframe"></a> DataFrame</h3><p>DataFrame是一个表格型的数据结构，含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。DataFrame既有列索引也有行索引，可以被看由Series组成的字典（共用同一个索引）。可以把DataFrame看作是一个二维结构来保存数据的容器。<br />构建DataFrame的方法：<br />传入由几个等长的Python数组或者Numpy数组组成的数组：</p><pre class="highlight"><code class="python">data = {<span class="hljs-string">'state'</span>: [<span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Ohio'</span>, <span class="hljs-string">'Nevada'</span>, <span class="hljs-string">'Nevada'</span>],        <span class="hljs-string">'year'</span>: [<span class="hljs-number">2000</span>, <span class="hljs-number">2001</span>, <span class="hljs-number">2002</span>, <span class="hljs-number">2001</span>, <span class="hljs-number">2002</span>],        <span class="hljs-string">'pop'</span>: [<span class="hljs-number">1.5</span>, <span class="hljs-number">1.7</span>, <span class="hljs-number">3.6</span>, <span class="hljs-number">2.4</span>, <span class="hljs-number">2.9</span>]}df = pd.DataFrame(data)print(df)print(df.columns) <span class="hljs-comment"># 列名是字典的key</span>print(df.index) <span class="hljs-comment"># 被自动添加的索引</span>print(df.dtypes) <span class="hljs-comment"># object = str or mixed</span>print(df.shape)</code></pre><p>可以指定列的顺序:</p><pre class="highlight"><code class="python">df = pd.DataFrame(data, columns = [<span class="hljs-string">'year'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'pop'</span>])print(df)print(df.columns) <span class="hljs-comment"># 按给定的顺序</span><span class="hljs-comment"># 可以指定行索引</span>df = pd.DataFrame(data, columns = [<span class="hljs-string">'year'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'pop'</span>],                        index = [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>, <span class="hljs-string">'four'</span>, <span class="hljs-string">'five'</span>])print(df)print(df.index)</code></pre><p>通过列索引和行索引获取数据（.loc()）：</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 获取一列 (类型为Series)</span>print(df[<span class="hljs-string">'state'</span>])print(df[[<span class="hljs-string">'state'</span>, <span class="hljs-string">'year'</span>]]) <span class="hljs-comment"># 获取多列</span><span class="hljs-comment"># 获取一行 (类型为Series)</span>print(df.loc[<span class="hljs-string">'three'</span>])print(type(df.loc[<span class="hljs-string">'three'</span>]))</code></pre><p>通过行列的的位置获取数据（.iloc()）：</p><pre class="highlight"><code class="python">df.iloc[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, <span class="hljs-number">0</span>:<span class="hljs-number">2</span>] <span class="hljs-comment"># 取第一第二行，第一第二列</span></code></pre><h2 id="添加和删除列"><a class="markdownIt-Anchor" href="#添加和删除列"></a> 添加和删除列</h2><p>可以给DataFrame添加列，长度要和原DataFrame的行数一样，如果添加的是一个Series，会精确对齐DataFrame的行索引（因为双方都有行索引），没有匹配上的被填上空缺值：</p><pre class="highlight"><code class="python">df = pd.DataFrame(data, columns = [<span class="hljs-string">'year'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'pop'</span>],                        index = [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>, <span class="hljs-string">'four'</span>, <span class="hljs-string">'five'</span>])print(df)<span class="hljs-comment"># 添加列</span>new_col = pd.Series([<span class="hljs-number">-1.2</span>, <span class="hljs-number">-1.5</span>, <span class="hljs-number">-1.7</span>], index = [<span class="hljs-string">'two'</span>, <span class="hljs-string">'five'</span>, <span class="hljs-string">'four'</span>])df[<span class="hljs-string">'new_col'</span>] = new_colprint(df)df[<span class="hljs-string">'eastern'</span>] = (df.state == <span class="hljs-string">'Ohio'</span>)print(df)<span class="hljs-comment"># 删除列</span>print(df.columns)df = df.drop([<span class="hljs-string">'new_col'</span>, <span class="hljs-string">'year'</span>], axis = <span class="hljs-number">1</span>) <span class="hljs-comment"># axis = 1 表示按列操作</span>print(df)<span class="hljs-comment"># 删除行</span>print(df.drop([<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>], axis = <span class="hljs-number">0</span>)) <span class="hljs-comment"># axis = 0 表示按行操作</span>print(df.drop(df.index[df.eastern], axis = <span class="hljs-number">0</span>)) <span class="hljs-comment"># drop eastern为True的行</span>print(df.drop(df.index[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>], axis = <span class="hljs-number">0</span>)) <span class="hljs-comment"># drop前两行</span></code></pre><h2 id="修改索引"><a class="markdownIt-Anchor" href="#修改索引"></a> 修改索引</h2><p>行索引和列索引不能原地修改，可以用.rename()修改</p><pre class="highlight"><code class="">print(df)print(df.rename(index = {'five': 'aaa'}))print(df.rename(columns = {'pop': 'population'}))</code></pre><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>至此，一共学习三种数组：</p><ul><li><strong>Python数组（list）</strong>：e.g., <code>[1, 2, 2, 5]</code>. 需要用for loop去接触每一个元素，可以嵌套形成多维数组；</li><li><strong>Numpy数组（ndarray）</strong>：e.g., <code>np.array([1, 2, 2, 5])</code>. 可以做快速的矢量化计算，是Python进行数据分析的基础，也可以嵌套形成多维数组；</li><li><strong>Pandas Series</strong>：e.g., <code>pd.Series([1, 2, 2], index = [...])</code>. 可以由python数组或者Numpy数组作为内容生成，可以给每个值设置一个索引。可以是Pandas DataFrame的一行或者一列，矢量计算与Numpy数组一样。两个Series进行计算时，会自动先按照index对齐，再计算，没有对齐到的结果为<code>NaN</code>。</li></ul><p><strong>Pandas DataFrame</strong>: e.g., <code>pd.DataFrame({...}, columns = [], index = [])</code></p><ul><li>与R的dataframe类似，是一个二维的数据结构（底层是一个二维Numpy数组），列表示feature，行表示observation；</li><li>每一列取出来都是Series，index为原DataFrame的行索引；</li><li>每一行取出来都是Series，index为原DataFrame的列索引；</li><li>按条件筛选的方式与Numpy数组一样。</li></ul><p><strong>Pandas筛选数据的三种方式</strong></p><ol><li>用位置选取：选行<code>df.iloc[0:2]</code>，选列<code>df.iloc[:, 0:2]</code>；</li><li>用索引值选取：选行<code>df.loc[['row1', 'row3']]</code>，选列<code>df[['col1', 'col2']]</code>；</li><li>用布尔条件选取：满足条件的所有的行<code>df.loc[df.col1 &gt; 0]</code>。</li></ol><h1 id="小测验"><a class="markdownIt-Anchor" href="#小测验"></a> 小测验</h1><ol><li>创建内容如下的DataFrame命名为profile：<br /><img src="/images/python4/Q1.png" alt="Alt text" /></li></ol><!-- data = {'Age': [12, 16, 13, 13, 14],  --><!-- 'Score': [82, 85, 90, 85, 78], --><!-- 'Gender': ['M', 'M', 'M', 'F', 'F'], --><!-- 'On_Campus': [True, False, True, True, False]} --><!-- profile = pd.DataFrame(data, index = ['Michael', 'Joe', 'Bob', 'Alice', 'Tiffany']) --><!-- profile --><ol start="2"><li>打印出Alice和Bob的信息：<br /><img src="/images/python4/Q2.png" alt="Alt text" /></li></ol><!-- profile.loc[['Alice', 'Bob']] --><ol start="3"><li>打印出On_Campus为True的行：<br /><img src="/images/python4/Q3.png" alt="Alt text" /></li></ol><!-- profile.loc[profile.On_Campus] --><ol start="4"><li>打印列[‘Gender’, ‘Age’]:<br /><img src="/images/python4/Q4.png" alt="Alt text" /></li></ol><!-- profile[['Gender', 'Age']] --><ol start="5"><li>创建一个新列名为&quot;Score_Plus&quot;，值为每个人的Score都加5：<br /><img src="/images/python4/Q5.png" alt="Alt text" /></li></ol><!-- profile['Score_Plus'] = profile.Score + 5 --><!-- profile -->]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. Python-Numpy介绍</title>
      <link href="2020/12/03/Python3-Numpy/"/>
      <url>2020/12/03/Python3-Numpy/</url>
      
        <content type="html"><![CDATA[<p>Numpy（Numerical Python的简称）是高性能科学计算和数据分析的基础包。Numpy本身没有提供多么高级的数据分析功能，但是理解Numpy数组和面向数组的计算将有助于高效的使用Pandas Dataframe。我们主要学习数据整理、子集构造和过滤、转换等矢量化数组运算。</p><a id="more"></a><p><strong>矢量化计算</strong>：指使用高效、提前编译的低级语言代码对数据序列进行数学操作，去代替显性迭代代码，如Python中的for循环。这样做的前提是要保证数组的元素是<strong>同质</strong>的。用矢量化计算会比python for loop快超过50倍，因为for loop在迭代每个元素时需要一个个检查元素的数据类型（list是允许不同类型的数据在同一个list里面的）。</p><p><strong>安装</strong>：使用Numpy之前需要安装，如果在Jupyter中执行<code>import numpy</code>报错，说明还没有安装，请参考<a href="https://pearmonkey.com/2020/12/01/Python0-install-Jupyter_Notebook/">这篇</a>进行安装Numpy。</p><p><strong>ndarray</strong>：Numpy包应用的对象。一个通用的同构数据的多维容器，所有元素必须是相同类型的。每个数组都有两个属性，<code>shape</code>（各维度的大小）和<code>dtype</code>（数组数据的类型）。</p><h2 id="生成数组"><a class="markdownIt-Anchor" href="#生成数组"></a> 生成数组</h2><pre class="highlight"><code class="python"><span class="hljs-comment"># 所有的function的调用都是  package.func()，所以将numpy缩写成np</span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npx = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]) <span class="hljs-comment"># 二维numpy数组</span>print(x)print(x.shape) <span class="hljs-comment"># 数组的dimension</span>print(x.dtype)x = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]], dtype = np.float32) <span class="hljs-comment"># 生成二维numpy数组，声明dtype</span>print(x.dtype)x = x.astype(np.int32) <span class="hljs-comment"># 类型转换</span>print(x.dtype)print(np.zeros(<span class="hljs-number">10</span>)) <span class="hljs-comment"># zeros生成全零数组，换成ones可以生成全1数组</span>print(np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>))) <span class="hljs-comment"># 生成二维的全零数组</span>print(np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>)) <span class="hljs-comment"># 生成序列，如果是从0开始的，可以只写end：np.arange(15)</span>print(np.identity(<span class="hljs-number">5</span>)) <span class="hljs-comment"># 生成5 * 5的identity矩阵</span>print(np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment"># 生成3 * 3的正态分布随机小数数组</span>print(np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, size = [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>])) <span class="hljs-comment">#生成3 * 3的随机整数数组，整数的范围是[0, 10)</span></code></pre><h2 id="基础运算"><a class="markdownIt-Anchor" href="#基础运算"></a> 基础运算</h2><pre class="highlight"><code class="python">x = np.array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>],              [ <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>],              [ <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">8.</span>]])print(x * <span class="hljs-number">2</span>) <span class="hljs-comment"># 每个数都乘以2</span>print(x ** <span class="hljs-number">2</span>) <span class="hljs-comment"># 每个数都平方</span>print(np.sqrt(x)) <span class="hljs-comment"># 每个数的平方根</span>print(<span class="hljs-number">0.5</span> + x[<span class="hljs-number">0</span>, :])y = np.array([[<span class="hljs-number">-4.</span> , <span class="hljs-number">-3.5</span>, <span class="hljs-number">-3.</span> ],              [<span class="hljs-number">-2.5</span>, <span class="hljs-number">-2.</span> , <span class="hljs-number">-1.5</span>],              [<span class="hljs-number">-1.</span> , <span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.</span> ]])print(x + y)</code></pre><h2 id="按轴进行运算"><a class="markdownIt-Anchor" href="#按轴进行运算"></a> 按轴进行运算</h2><pre class="highlight"><code class="python">x = np.array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>],              [ <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>],              [ <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">8.</span>]])print(np.sum(x))print(np.sum(x, axis = <span class="hljs-number">0</span>)) <span class="hljs-comment"># axis = 0 对每一列操作</span>print(np.sum(x, axis = <span class="hljs-number">1</span>)) <span class="hljs-comment"># axis = 1 对每一行操作</span>print(np.mean(x, axis = <span class="hljs-number">1</span>))print(np.max(x, axis = <span class="hljs-number">1</span>))print(np.std(x, axis = <span class="hljs-number">1</span>))print(np.argmax(x, axis = <span class="hljs-number">0</span>))y = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, size = [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>])print(<span class="hljs-string">"原来的y："</span>)print(y)print(<span class="hljs-string">"按行sort后："</span>)print(np.sort(y))print(<span class="hljs-string">"按列sort后："</span>)print(np.sort(y, axis = <span class="hljs-number">0</span>))</code></pre><h2 id="数组切片"><a class="markdownIt-Anchor" href="#数组切片"></a> 数组切片</h2><p>对于连续的行或列切片，可以用Python的范围表示方法（冒号表示法）<br /><img src="/images/python3_slicing.jpg" alt="Alt text" /><br />对于非连续的行或列，可以用index list来挑取</p><pre class="highlight"><code class="python">x = np.array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>],              [ <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>],              [ <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">8.</span>]])print(x[:, [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]])</code></pre><p><strong>重要笔记</strong><br /><span style="color:red">对Numpy数组的切片，不是对原始数组的复制，而是引用原数组，所以对切片里的元素进行修改，等于修改原数组！！</span>这样设计的原因是，由于Numpy的设计目的是处理大数据，假如默认是将数据复制，会大幅度消耗内存而降低性能。如果想要得到一份副本，需要显式地进行复制 <code>y = x[5:8].copy()</code>。</p><pre class="highlight"><code class="python">x = np.arange(<span class="hljs-number">10</span>)print(<span class="hljs-string">'x: '</span>, x)y = x[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>]print(<span class="hljs-string">'y: '</span>, y)y[<span class="hljs-number">1</span>] = <span class="hljs-number">1000</span>print(<span class="hljs-string">'new x: '</span>, x)</code></pre><h2 id="数组布尔索引"><a class="markdownIt-Anchor" href="#数组布尔索引"></a> 数组布尔索引</h2><p>布尔值就是<code>True</code>和<code>False</code>，布尔值可以控制所在位置的元素是否被挑选，所以这个布尔值数组的长度必须要和原数组的长度一样</p><pre class="highlight"><code class="python">names = np.array([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Will'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Will'</span>, <span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Joe'</span>])print(names == <span class="hljs-string">'Bob'</span>)print(names[names == <span class="hljs-string">'Bob'</span>])print(names[names != <span class="hljs-string">'Bob'</span>])<span class="hljs-comment"># 多个条件</span>mask = (names == <span class="hljs-string">'Bob'</span>) | (names == <span class="hljs-string">'Will'</span>)print(mask)print(names[mask])data = np.random.randn(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>)print(data)data[data &lt; <span class="hljs-number">0</span>] = <span class="hljs-number">0</span>print(data)</code></pre><h2 id="数组塑型"><a class="markdownIt-Anchor" href="#数组塑型"></a> 数组塑型</h2><pre class="highlight"><code class="python">x = np.arange(<span class="hljs-number">32</span>)print(x)print(x.reshape((<span class="hljs-number">8</span>, <span class="hljs-number">4</span>)))</code></pre><h2 id="常用计算函数"><a class="markdownIt-Anchor" href="#常用计算函数"></a> 常用计算函数</h2><pre class="highlight"><code class="python">x = <span class="hljs-number">10</span> <span class="hljs-comment"># x可以是任意维的numpy数组</span>print(<span class="hljs-string">"绝对值："</span>, np.absolute(x))print(<span class="hljs-string">"平方根"</span>, np.sqrt(x))print(<span class="hljs-string">"sin："</span>, np.sin(x))print(<span class="hljs-string">"cos："</span>, np.cos(x))print(<span class="hljs-string">"tan："</span>, np.tan(x))print(<span class="hljs-string">"自然对数："</span>, np.log(x))print(<span class="hljs-string">"10为底的对数："</span>, np.log10(x))print(<span class="hljs-string">"2为底的对数："</span>, np.log2(x))print(<span class="hljs-string">"指数："</span>, np.exp(x))print(<span class="hljs-string">"次幂："</span>, x ** <span class="hljs-number">4</span>)</code></pre><p>小测验1：将x的四个象限（比如说<code>[[0, 1], [4, 5]]</code>）相加，返回形状为(2, 2)的结果）<br />小测验2：求x的第三行的第一和第三个元素的自然对数以得到形状为(2,)的结果</p><pre class="highlight"><code class="python">x = np.array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],              [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],              [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],              [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]])<span class="hljs-comment"># 答案1</span>b = x[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, <span class="hljs-number">0</span>:<span class="hljs-number">2</span>] + x[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, <span class="hljs-number">2</span>:<span class="hljs-number">4</span>] + x[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>, <span class="hljs-number">0</span>:<span class="hljs-number">2</span>] + x[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>, <span class="hljs-number">2</span>:<span class="hljs-number">4</span>]<span class="hljs-comment"># 答案2</span>b = np.log(x[<span class="hljs-number">2</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]])</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2. Python-基础知识进阶</title>
      <link href="2020/12/02/Python2-List-Loop/"/>
      <url>2020/12/02/Python2-List-Loop/</url>
      
        <content type="html"><![CDATA[<p>如果用Python作为数据处理和分析的工具，很多功能就不用立马掌握了，例如：面向对象编程，进程和线程。这些功能对于一个Data Scientist可以说是几乎用不到（虽然很多网上的教程都会讲这些，但是就个人经验而言，这些知识并不是必须的，如果遇到可以再学）。</p><a id="more"></a><p>做数据处理与分析，其实就是对Python变量进行操作，所以，我们要进一步掌握基础变量，以及变量之间的转化。这里，我们继续学习上一篇中提到的各种概念，并加以运用。</p><h2 id="变量赋值"><a class="markdownIt-Anchor" href="#变量赋值"></a> 变量赋值</h2><p>Python是可以同时给多个变量赋值的。<br />给不同变量赋同一个值：</p><pre class="highlight"><code class="python">a = b = c = <span class="hljs-number">1</span>a = b = c = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</code></pre><p>或者给不同变量不同的值：</p><pre class="highlight"><code class="python">name, score, age = <span class="hljs-string">"Tom"</span>, <span class="hljs-number">95</span>, <span class="hljs-number">21</span></code></pre><h2 id="字符串string"><a class="markdownIt-Anchor" href="#字符串string"></a> 字符串String</h2><p><strong>插入一个知识点，python表示范围的形式是<code>[start, end, step]</code>，从<code>start</code>取到<code>end-1</code>，步长为<code>step</code>，default <code>step</code>为1</strong></p><pre class="highlight"><code class="python">s = <span class="hljs-string">'abcdef'</span><span class="hljs-comment"># 截取string：</span>print(s[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])print(s[<span class="hljs-number">1</span>:]) <span class="hljs-comment"># 冒号后面不写表示直到结束</span>print(s[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]) <span class="hljs-comment"># [start : end : step]，先截取string，再按步长取字符</span><span class="hljs-comment"># 重复string</span>print(s * <span class="hljs-number">2</span>)<span class="hljs-comment"># 粘贴string</span>print(s + <span class="hljs-string">' yeah!'</span>)</code></pre><h2 id="数组list"><a class="markdownIt-Anchor" href="#数组list"></a> 数组List</h2><pre class="highlight"><code class="python"><span class="hljs-comment"># 截取子数组</span>a = [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]print(a[::<span class="hljs-number">3</span>]) <span class="hljs-comment"># [start : end : step]，先或者子数组，再按步长取元素</span><span class="hljs-comment"># 重复数组</span>print(a * <span class="hljs-number">2</span>)<span class="hljs-comment"># 粘贴数组</span>b = [<span class="hljs-string">'aaa'</span>, <span class="hljs-string">'bbb'</span>, <span class="hljs-string">'ccc'</span>]print(a + b)<span class="hljs-comment"># 检查元素是否在list里</span>print(<span class="hljs-number">4</span> <span class="hljs-keyword">in</span> a)</code></pre><h2 id="字典dict"><a class="markdownIt-Anchor" href="#字典dict"></a> 字典Dict</h2><pre class="highlight"><code class="python">d = {<span class="hljs-string">'Michael'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'Bob'</span>: <span class="hljs-number">75</span>, <span class="hljs-string">'Tracy'</span>: <span class="hljs-number">85</span>}<span class="hljs-comment"># 获得所有key</span>print(d.keys())<span class="hljs-comment"># 获得所有value</span>print(d.values())<span class="hljs-comment"># nested dict</span>d = {<span class="hljs-string">'Michael'</span>: {<span class="hljs-string">'score'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">27</span>}, <span class="hljs-string">'Bob'</span>: {<span class="hljs-string">'score'</span>: <span class="hljs-number">85</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">25</span>}}print(d.keys())print(d.values())print(d[<span class="hljs-string">'Michael'</span>].keys())print(d[<span class="hljs-string">'Michael'</span>].values())</code></pre><h2 id="数据转换"><a class="markdownIt-Anchor" href="#数据转换"></a> 数据转换</h2><pre class="highlight"><code class="python"><span class="hljs-comment"># Integer to String</span>print(str(<span class="hljs-number">1000</span>))<span class="hljs-comment"># String to Integer</span>print(int(<span class="hljs-string">"-100"</span>))<span class="hljs-comment"># float number to Integer</span><span class="hljs-comment"># 向下取整</span>print(int(<span class="hljs-number">8.88</span>))</code></pre><h2 id="一行for-loop"><a class="markdownIt-Anchor" href="#一行for-loop"></a> 一行for loop</h2><p>如何对list中每一个元素进行相同的操作。</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 把每一个数字都除以2</span>a = [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]b = [x / <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a]print(b)<span class="hljs-comment"># 把"new_"添加到每个元素的前面</span>a = [<span class="hljs-string">"york"</span>, <span class="hljs-string">"mexico"</span>, <span class="hljs-string">"city"</span>]b = [<span class="hljs-string">"new_"</span> + x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a]print(b)<span class="hljs-comment"># 对每个元素进行奇偶判断</span>a = [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]b = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]print(b)<span class="hljs-comment"># 如果有else，if else需要在for前面，如果没有，if需要在for的后面</span>a = [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]b = [<span class="hljs-string">"even"</span> <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"odd"</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a]print(a, b)</code></pre><p><em>小测验：用一行for loop语句输出a和b的交集</em></p><pre class="highlight"><code class="python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]b = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<span class="hljs-comment"># 答案</span>print([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> b])</code></pre><h2 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h2><p>break和continue的使用</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 用break提前终止</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):  <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">10</span>:    <span class="hljs-keyword">break</span> <span class="hljs-comment"># 程序在此终止</span>  print(i)<span class="hljs-comment"># 用continue跳过不需要的</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>):  <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:    <span class="hljs-keyword">continue</span> <span class="hljs-comment"># 直接跳到下个循环，下面的代码不执行了</span>  print(i)</code></pre><h2 id="print函数"><a class="markdownIt-Anchor" href="#print函数"></a> print函数</h2><p>print多个变量，用逗号隔开，有两个可调参数，<code>sep</code>和<code>end</code>。<code>seq</code>是说明多个变量用什么隔开，default是一个空格，<code>end</code>是说明最后以什么结尾，default是换行(\n)</p><pre class="highlight"><code class="python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]b = <span class="hljs-string">"hahaha"</span>print(a, b)print(<span class="hljs-string">"first print"</span>, end = <span class="hljs-string">'++++++++'</span>)print(a, b, <span class="hljs-string">"hello world!"</span>, sep = <span class="hljs-string">'\t'</span>)</code></pre><p><em>小测验1: 用for loop和print打印出</em></p><pre class="highlight"><code class="python"><span class="hljs-number">1</span>*<span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-number">2</span>*<span class="hljs-number">2</span>=<span class="hljs-number">4</span><span class="hljs-number">3</span>*<span class="hljs-number">3</span>=<span class="hljs-number">9</span><span class="hljs-number">4</span>*<span class="hljs-number">4</span>=<span class="hljs-number">16</span><span class="hljs-number">5</span>*<span class="hljs-number">5</span>=<span class="hljs-number">25</span><span class="hljs-number">6</span>*<span class="hljs-number">6</span>=<span class="hljs-number">36</span><span class="hljs-number">7</span>*<span class="hljs-number">7</span>=<span class="hljs-number">49</span><span class="hljs-number">8</span>*<span class="hljs-number">8</span>=<span class="hljs-number">64</span><span class="hljs-number">9</span>*<span class="hljs-number">9</span>=<span class="hljs-number">81</span><span class="hljs-comment"># 答案</span><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):    print(a, <span class="hljs-string">'*'</span>, a, <span class="hljs-string">'='</span>, a * a, sep = <span class="hljs-string">''</span>)</code></pre><p><em>小测验2：用for loop和print打印出</em></p><pre class="highlight"><code class="python"><span class="hljs-number">1</span>*<span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-number">1</span>*<span class="hljs-number">2</span>=<span class="hljs-number">2</span><span class="hljs-number">1</span>*<span class="hljs-number">3</span>=<span class="hljs-number">3</span><span class="hljs-number">1</span>*<span class="hljs-number">4</span>=<span class="hljs-number">4</span><span class="hljs-number">1</span>*<span class="hljs-number">5</span>=<span class="hljs-number">5</span><span class="hljs-number">1</span>*<span class="hljs-number">6</span>=<span class="hljs-number">6</span><span class="hljs-number">1</span>*<span class="hljs-number">7</span>=<span class="hljs-number">7</span><span class="hljs-number">1</span>*<span class="hljs-number">8</span>=<span class="hljs-number">8</span><span class="hljs-number">1</span>*<span class="hljs-number">9</span>=<span class="hljs-number">9</span><span class="hljs-comment"># 答案</span>a = <span class="hljs-number">1</span><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):    print(a, <span class="hljs-string">'*'</span>, b, <span class="hljs-string">'='</span>, a * b, sep = <span class="hljs-string">''</span>, end = <span class="hljs-string">'\t'</span>)</code></pre><p><em>小测验3：用for loop和print打印出</em></p><pre class="highlight"><code class="python"><span class="hljs-number">1</span>*<span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-number">1</span>*<span class="hljs-number">2</span>=<span class="hljs-number">2</span><span class="hljs-number">1</span>*<span class="hljs-number">3</span>=<span class="hljs-number">3</span><span class="hljs-number">1</span>*<span class="hljs-number">4</span>=<span class="hljs-number">4</span><span class="hljs-number">1</span>*<span class="hljs-number">5</span>=<span class="hljs-number">5</span><span class="hljs-number">1</span>*<span class="hljs-number">6</span>=<span class="hljs-number">6</span><span class="hljs-number">1</span>*<span class="hljs-number">7</span>=<span class="hljs-number">7</span><span class="hljs-number">1</span>*<span class="hljs-number">8</span>=<span class="hljs-number">8</span><span class="hljs-number">1</span>*<span class="hljs-number">9</span>=<span class="hljs-number">9</span><span class="hljs-number">2</span>*<span class="hljs-number">2</span>=<span class="hljs-number">4</span><span class="hljs-number">2</span>*<span class="hljs-number">3</span>=<span class="hljs-number">6</span><span class="hljs-number">2</span>*<span class="hljs-number">4</span>=<span class="hljs-number">8</span><span class="hljs-number">2</span>*<span class="hljs-number">5</span>=<span class="hljs-number">10</span><span class="hljs-number">2</span>*<span class="hljs-number">6</span>=<span class="hljs-number">12</span><span class="hljs-number">2</span>*<span class="hljs-number">7</span>=<span class="hljs-number">14</span><span class="hljs-number">2</span>*<span class="hljs-number">8</span>=<span class="hljs-number">16</span><span class="hljs-number">2</span>*<span class="hljs-number">9</span>=<span class="hljs-number">18</span><span class="hljs-number">3</span>*<span class="hljs-number">3</span>=<span class="hljs-number">9</span><span class="hljs-number">3</span>*<span class="hljs-number">4</span>=<span class="hljs-number">12</span><span class="hljs-number">3</span>*<span class="hljs-number">5</span>=<span class="hljs-number">15</span><span class="hljs-number">3</span>*<span class="hljs-number">6</span>=<span class="hljs-number">18</span><span class="hljs-number">3</span>*<span class="hljs-number">7</span>=<span class="hljs-number">21</span><span class="hljs-number">3</span>*<span class="hljs-number">8</span>=<span class="hljs-number">24</span><span class="hljs-number">3</span>*<span class="hljs-number">9</span>=<span class="hljs-number">27</span><span class="hljs-number">4</span>*<span class="hljs-number">4</span>=<span class="hljs-number">16</span><span class="hljs-number">4</span>*<span class="hljs-number">5</span>=<span class="hljs-number">20</span><span class="hljs-number">4</span>*<span class="hljs-number">6</span>=<span class="hljs-number">24</span><span class="hljs-number">4</span>*<span class="hljs-number">7</span>=<span class="hljs-number">28</span><span class="hljs-number">4</span>*<span class="hljs-number">8</span>=<span class="hljs-number">32</span><span class="hljs-number">4</span>*<span class="hljs-number">9</span>=<span class="hljs-number">36</span><span class="hljs-number">5</span>*<span class="hljs-number">5</span>=<span class="hljs-number">25</span><span class="hljs-number">5</span>*<span class="hljs-number">6</span>=<span class="hljs-number">30</span><span class="hljs-number">5</span>*<span class="hljs-number">7</span>=<span class="hljs-number">35</span><span class="hljs-number">5</span>*<span class="hljs-number">8</span>=<span class="hljs-number">40</span><span class="hljs-number">5</span>*<span class="hljs-number">9</span>=<span class="hljs-number">45</span><span class="hljs-number">6</span>*<span class="hljs-number">6</span>=<span class="hljs-number">36</span><span class="hljs-number">6</span>*<span class="hljs-number">7</span>=<span class="hljs-number">42</span><span class="hljs-number">6</span>*<span class="hljs-number">8</span>=<span class="hljs-number">48</span><span class="hljs-number">6</span>*<span class="hljs-number">9</span>=<span class="hljs-number">54</span><span class="hljs-number">7</span>*<span class="hljs-number">7</span>=<span class="hljs-number">49</span><span class="hljs-number">7</span>*<span class="hljs-number">8</span>=<span class="hljs-number">56</span><span class="hljs-number">7</span>*<span class="hljs-number">9</span>=<span class="hljs-number">63</span><span class="hljs-number">8</span>*<span class="hljs-number">8</span>=<span class="hljs-number">64</span><span class="hljs-number">8</span>*<span class="hljs-number">9</span>=<span class="hljs-number">72</span><span class="hljs-number">9</span>*<span class="hljs-number">9</span>=<span class="hljs-number">81</span><span class="hljs-comment"># 答案</span><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> range(a, <span class="hljs-number">10</span>):        print(a, <span class="hljs-string">'*'</span>, b, <span class="hljs-string">'='</span>, a * b, sep = <span class="hljs-string">''</span>, end = <span class="hljs-string">'\t'</span>)    print()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1. Python-变量与函数</title>
      <link href="2020/12/01/Python1-variables-function/"/>
      <url>2020/12/01/Python1-variables-function/</url>
      
        <content type="html"><![CDATA[<p>如果把计算机想成一个可以进行计算的机器人，那么编程语言就是给这个机器人下达命令的规则。生活和工作中也会经常遇到不同类型的数据，理解Python的变量类型是做数据处理和分析的前提。</p><a id="more"></a><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><p>变量是一个接收数值的容器，我们想要这么一个容器，就需要给它命个名，命名规则是：<strong>必须是大小写英文、数字和_的组合，且不能用数字开头</strong>。比如：<code>a, b, c, a1, a2, new_a, new_b</code>。</p><p>有了容器之后，我们就可以往里面放数据了，Python中常见的数据类型有以下几种：</p><ul><li>整数（integer）:</li></ul><pre class="highlight"><code class="python">a = <span class="hljs-number">10</span>b = <span class="hljs-number">-1</span>print(type(a))print(a + b)</code></pre><ul><li>浮点数（float number）:</li></ul><pre class="highlight"><code class="python">a = <span class="hljs-number">0.1</span>b = <span class="hljs-number">-0.001</span>print(type(a))print(a + b)</code></pre><ul><li>字符串（string）:</li></ul><pre class="highlight"><code class="python">a = <span class="hljs-string">"hello "</span>b = <span class="hljs-string">"world!"</span>print(a + b)</code></pre><ul><li>布尔值（boolean）:</li></ul><pre class="highlight"><code class="python">a = (<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)b = (<span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>)print(a)print(b)print(a &amp; b)</code></pre><ul><li>空值（None）: 有时我们会遇到一些缺失的值，用0填充是不合适的，因为0是有含义的</li></ul><pre class="highlight"><code class="python">a = <span class="hljs-literal">None</span></code></pre><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><p>知道了python里面有哪些数据类型后，接下来了解一下这些数据可以存放的方式。</p><h3 id="list数组"><a class="markdownIt-Anchor" href="#list数组"></a> List数组</h3><p>这个容器不仅可以装一个数据，还可以装多个，在python叫list，index（坐标）从0开始。list可以装不同类型的数据，但是一般用法都是装类型一样的数据，因为便于后续的处理。</p><pre class="highlight"><code class="python">a = [<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Tom"</span>]print(type(a))print(a[<span class="hljs-number">0</span>])print(a[<span class="hljs-number">2</span>])print(a[<span class="hljs-number">-1</span>])</code></pre><p>在已有的list后面添加新的元素：</p><pre class="highlight"><code class="python">a = [<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Tom"</span>]a.append(<span class="hljs-string">"Joe"</span>)print(a)print(len(a)) <span class="hljs-comment"># 查看list的长度</span>a.insert(<span class="hljs-number">1</span>, <span class="hljs-string">"Zoe"</span>)print(a)</code></pre><p>上面是一维list，取值需要一个坐标，我们还可以定义多维list，比如：</p><pre class="highlight"><code class="python">a = [[<span class="hljs-string">"a1"</span>, <span class="hljs-string">"a2"</span>, <span class="hljs-string">"a3"</span>], [<span class="hljs-string">"b1"</span>, <span class="hljs-string">"b2"</span>, <span class="hljs-string">"b3"</span>]]print(a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])</code></pre><h3 id="set集合"><a class="markdownIt-Anchor" href="#set集合"></a> Set集合</h3><p>list是允许放重复的元素的，并且这些元素的顺序是保证的，可以被操作的。但是set集合里面的元素是没有重复的，存放的顺序也是不能规定的，用法可以以后碰到了在了解。基本操作：</p><pre class="highlight"><code class="python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]b = set(a)print(len(a))print(len(b))b.add(<span class="hljs-number">5</span>)print(len(b))b.remove(<span class="hljs-number">1</span>)print(len(b))</code></pre><h3 id="dict字典"><a class="markdownIt-Anchor" href="#dict字典"></a> Dict字典</h3><p>dict全称是dictionary，顾名思义，就是具有高效率的查找速度，其他语言中叫做map。是用键-值（key-value）储存。比如，如果要根据学生的姓名查找对应的成绩，如果用list实现，则需要两个list：</p><pre class="highlight"><code class="python">names = [<span class="hljs-string">'Michael'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Tracy'</span>]scores = [<span class="hljs-number">95</span>, <span class="hljs-number">75</span>, <span class="hljs-number">85</span>]</code></pre><p>给定一个名字，想要知道他的成绩，就先要在names中找到对应的位置，再从scores里面取出对应的成绩，list越长，找的时间就越长。<br />如果能够把成绩和名字绑定起来，找到名字就找到成绩了，速度会快很多很多。</p><pre class="highlight"><code class="python">d = {<span class="hljs-string">'Michael'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'Bob'</span>: <span class="hljs-number">75</span>, <span class="hljs-string">'Tracy'</span>: <span class="hljs-number">85</span>}print(d[<span class="hljs-string">'Michael'</span>])</code></pre><p>如果想要有更多的属性，可以继续嵌套：</p><pre class="highlight"><code class="python">d = {<span class="hljs-string">'Michael'</span>: {<span class="hljs-string">'score'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">27</span>}, <span class="hljs-string">'Bob'</span>: {<span class="hljs-string">'score'</span>: <span class="hljs-number">85</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">25</span>}}print(d[<span class="hljs-string">'Michael'</span>][<span class="hljs-string">'score'</span>])</code></pre><p>所以啊，dict里面的key是不能重复的，如果添加的重复的，就会自动覆盖之前的value。如果key不存在，程序就会报错，所以在查找之前可以先检查一下key是否在dict里面：</p><pre class="highlight"><code class="python">print(<span class="hljs-string">'Alice'</span> <span class="hljs-keyword">in</span> d)</code></pre><h2 id="循环和条件判断"><a class="markdownIt-Anchor" href="#循环和条件判断"></a> 循环和条件判断</h2><p>如果我们需要计算1+2+3+…+10，我们可以用code直接把所有数字写出来。但如果要算1+2+…+10000呢？写完全部的数字就不太愿意了。这时候我们就可以用循环来完成。首先需要生成循环所需的范围，也就是在什么范围里面循环。<code>range(start, end + 1)</code>函数可以生成从start到end的一组连续的数字，所以我们的代码可以这样写：</p><pre class="highlight"><code class="python">sum = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10001</span>):  sum = sum + iprint(sum)</code></pre><p>条件判断就是用if else语句完成，如果不是二分的条件，可以用elif来分出另外的条件，例如：</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 这段code不能执行，只是阐述结构</span><span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> blue:  ...<span class="hljs-keyword">elif</span> a <span class="hljs-keyword">is</span> red:  ...<span class="hljs-keyword">elif</span> a <span class="hljs-keyword">is</span> green:  ...<span class="hljs-keyword">else</span>:  ...</code></pre><h2 id="函数定义与调用"><a class="markdownIt-Anchor" href="#函数定义与调用"></a> 函数定义与调用</h2><p>我们在什么情况下需要用函数呢？<br />答：当某一段代码我们需要重复使用的时候。例如，当一个公司有少于1000个员工时，我们成它为小型公司（S）；如果超过1000不到5000，是中型公司（M）；如果超过5000人，是大型公司（L）。<br />也就是说，每次的input都是一个整数，表示着这个公司的员工数量，我们需要写一个程序来返回一个结果，S表示小公司，M表示中公司，L表示大公司。这时我们就需要定义一个函数来完成这些重复的工作。<br />函数定义的模板：</p><pre class="highlight"><code class="python"><span class="hljs-comment"># func是函数的名字，尽量写得有含义一些，命名规则和变量命名规则一样，x和y是输入，数量不限</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(x, y)</span>:</span>  ...  <span class="hljs-keyword">return</span> ...</code></pre><p>针对举的例子，我们的函数可以这样写：</p><pre class="highlight"><code class="python"><span class="hljs-comment"># 定义函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size_of_firm</span><span class="hljs-params">(num_employee)</span>:</span>  <span class="hljs-keyword">if</span> num_employee &lt;= <span class="hljs-number">1000</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">"S"</span>  <span class="hljs-keyword">elif</span> num_employee &lt;= <span class="hljs-number">5000</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">"M"</span>  <span class="hljs-keyword">else</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">"L"</span><span class="hljs-comment"># 调用函数</span>print(size_of_firm(<span class="hljs-number">1500</span>))</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0. 安装Python和Jupyter Notebook</title>
      <link href="2020/12/01/Python0-install-Jupyter_Notebook/"/>
      <url>2020/12/01/Python0-install-Jupyter_Notebook/</url>
      
        <content type="html"><![CDATA[<p>使用Python有两种方法，一种是把所有的code都写在一个后缀名为.py文件里面，然后统一运行，这种方式适用于提交已经debug好的code到远程服务器运行；另一种是用Jupyter Notebook写一行code运行一行，方便随时查看中间结果，有问题即使解决。所以在开始学习Python的时候，强烈推荐用第二种写一行运行一行的模式。在这里介绍一下如何安装Jupyter Notebook。</p><a id="more"></a><p>（不需要提前给电脑安装Python）</p><h2 id="下载miniconda"><a class="markdownIt-Anchor" href="#下载miniconda"></a> 下载Miniconda</h2><p>无论是Windows还是MaxOS，都推荐用Conda来安装Jupyter，所以先下载一个<a href="https://docs.conda.io/en/latest/miniconda.html" target="_blank" rel="noopener">Miniconda</a>。Python2已经停止Maintain了，所以我们统一用Python3.8吧。我选择下载的是<strong>Miniconda3 Windows 64-bit</strong>，下载到桌面就行，因为安装后可以删掉。安装Miniconda时就一直点continue就行，不用修改任何地方。安装大概需要一分钟。</p><h2 id="安装jupyter"><a class="markdownIt-Anchor" href="#安装jupyter"></a> 安装Jupyter</h2><p>如果你时Win10的系统，在左下角的搜索框里输入anaconda，点击<strong>Anaconda Prompt (miniconda3)</strong>，会弹出黑色的命令行框，输入<code>conda install -c conda-forge notebook</code>，按回车，等待安装，出现需要输入Y/N，输入Y再回车。安装完后，输入<code>jupyter notebook</code>再回车，这时候你会发现浏览器打开了一个网页，这就是安装成功啦~~~</p><h2 id="运行python"><a class="markdownIt-Anchor" href="#运行python"></a> 运行Python</h2><p>黑色的命令行框，也叫cmd（全称时command），就是一个<strong>服务器</strong>；Jupyter自动打开的网页，相当于一个<strong>客户端</strong>，我们是通过这个网页来让服务器运行我们的代码。所以，在网页运行程序的时候，我们要保持服务器（cmd）开着，可以最小化。当我们结束了之后，就可以关闭cmd了。</p><p>在Jupyter打开的网页中，能看到电脑的各个文件夹，我们可以先新建一个folder用于储存代码（在桌面或者文件夹里完成），再从网页中进入这个folder，然后点击右上角的new button，选择Python3，这样就建好了一个notebook，就可以开始写代码了。</p><h2 id="安装package"><a class="markdownIt-Anchor" href="#安装package"></a> 安装package</h2><p>如果需要安装package（我们会需要安装pandas和numpy），在左下角的搜索框里输入anaconda，点击<strong>Anaconda Prompt (miniconda3)</strong>，会弹出cmd，输入<code>conda install pandas</code>或者<code>conda install numpy</code>，按回车后等待安装。安装完后，在jupyter点击restart，就可以写<code>import pandas</code>导入刚刚安装的package啦~</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R Code | Find Drawdowns</title>
      <link href="2020/11/15/Find-Drawdowns/"/>
      <url>2020/11/15/Find-Drawdowns/</url>
      
        <content type="html"><![CDATA[<p>I improve the algorithm of functions table.Drawdowns() and findDrawdowns() from package (PerformanceAnalytics).</p><a id="more"></a><h2 id="description-of-the-algorithm"><a class="markdownIt-Anchor" href="#description-of-the-algorithm"></a> Description of the algorithm</h2><ol><li>Use Fama-French market factor to calculate the cumulative return (as variable <strong>CumRET</strong>) assuming an investor put $1 in the market portfolio in 1926-07-01.</li><li>Calculate the cumulative maximum of <strong>CumRET</strong> (call it <strong>CumMax.CumRET</strong>).</li><li>Identify the dates where its <strong>CumRET</strong> is less than its <strong>CumMax.CumRET</strong>.</li><li>Put the different identified dates into a same group if they are consecutive and give each group a unique ID. Each group represents a drawdown period.</li><li>For each drawdown period, find the following items:<br />a. Lowest <strong>CumRET</strong>,<br />b. The date with the lowest <strong>CumRET</strong>,<br />c. Starting date,<br />d. End date.<br />Then the depth of a drawdown is given by<br />(Lowest <strong>CumRET</strong> - <strong>CumMax.CumRET</strong>)/ <strong>CumMax.CumRET</strong></li></ol><h2 id="r-code"><a class="markdownIt-Anchor" href="#r-code"></a> R Code</h2><pre class="highlight"><code class="">######################################## I improve the algorithm of functions table.Drawdowns()# and findDrawdowns() from package (PerformanceAnalytics).# Example: market portfolio returns from Kenneth French's library# Import the datasetFF &lt;- read.csv(&quot;C:/Users/kerwi/Dropbox/Empirics/Data/FF_Others/FF_3_Factors_Daily.CSV&quot;)# Market return = market excess return + risk-free returnFF$Mkt &lt;- FF$Mkt.RF+FF$RF# Only need two columns: &quot;Date&quot; &quot;Mkt&quot;FF &lt;- FF[,c(1,ncol(FF))]# FF use percentageFF$Mkt &lt;- FF$Mkt/100# Transform FF-Date into R-Date formatFF$Date &lt;- as.Date(as.character(FF$Date), &quot;%Y%m%d&quot;)# Calculate the cumulative returnFF$CumRET &lt;- cumprod(FF$Mkt+1)# Calculate the cumulative maximum cumulative returnFF$CumMax.CumRET &lt;- cummax(FF$CumRET)# Find the drawdowns -- the places where black line is under red line# These are the platforms of the red line# Varibale 'Up':#             it is 1 if CumRET is equal to CumMax.CumRET#             it is 0 if CumRET is less than CumMax.CumRETFF$Up &lt;- ifelse(FF$CumRET==FF$CumMax.CumRET, 1, 0)# The following two commands give each platform a unique indexFF$index &lt;- cumsum(FF$Up)FF$index[FF$Up==1] &lt;- NA# For each platform, find (1) the start and end dates,#                         (2) the bottom return and date,#                         (3) length between the dates.library(dplyr)res &lt;- FF %&gt;%  arrange(Date) %&gt;%  group_by(index) %&gt;%  summarise(Peak=CumMax.CumRET[1],            Bottom=min(CumRET),            Depth=(Bottom-Peak)/Peak,            From=Date[1],            To=Date[n()],            Trough=Date[CumRET==Bottom],            Length=n()+1,            To.Trough=sum(Date&lt;=Trough),            Recovery=sum(Date&gt;Trough)+1,            .groups='drop')# Re-order the result based on the depths of the drawdownsDrawdowns &lt;- res[order(res$Depth),                 c(&quot;From&quot;,&quot;To&quot;,&quot;Trough&quot;,&quot;Depth&quot;,&quot;Length&quot;,                   &quot;To.Trough&quot;,&quot;Recovery&quot;)]</code></pre><pre class="highlight"><code class="">################################## Use some figures to illustrate the algorithm# Take a sample after 2018tmp &lt;- FF[FF$Date&gt;='2019-06-01',]library(ggplot2)# Plot 1: the black line is the cumulative returnggplot(tmp, aes(Date)) +  geom_line(aes(y=CumRET), colour=&quot;black&quot;) +  scale_x_date(date_breaks = &quot;6 month&quot;, date_labels = &quot;%m-%Y&quot;)</code></pre><p><img src="/images/find_drawdowns/find_drawdowns_plot1.png" alt="Alt text" /></p><pre class="highlight"><code class="">################################## Plot 2: the added red line is the cumulative maximum cumulative returnggplot(tmp, aes(Date)) +  geom_line(aes(y=CumRET), colour=&quot;black&quot;) +  geom_line(aes(y=CumMax.CumRET), colour=&quot;red&quot;) +  scale_x_date(date_breaks = &quot;6 month&quot;, date_labels = &quot;%m-%Y&quot;)</code></pre><p><img src="/images/find_drawdowns/find_drawdowns_plot2.png" alt="Alt text" /></p><pre class="highlight"><code class="">################################## Plot 3: we identify each drawdown period with an unique indextmp$index[is.na(tmp$index)] &lt;- 0ggplot() +  geom_line(data=tmp, aes(x=Date, y=CumRET, color=as.factor(index))) +  scale_x_date(date_breaks = &quot;3 month&quot;, date_labels = &quot;%m-%Y&quot;)</code></pre><p><img src="/images/find_drawdowns/find_drawdowns_plot3.png" alt="Alt text" /></p><pre class="highlight"><code class="">################################## Plot 4:colnames(res)tmp.res &lt;- res[res$From&gt;='2019-06-01',]ggplot() +  geom_point(data=tmp.res, aes(x=From, y=Peak), size=2, alpha=0.5, shape='triangle') +  geom_point(data=tmp.res, aes(x=Trough, y=Bottom), size=2, alpha=0.5, color='blue') +  scale_x_date(date_breaks = &quot;3 month&quot;, date_labels = &quot;%m-%Y&quot;) +  geom_line(data=tmp, aes(x=Date, y=CumRET)) +  geom_line(data=tmp, aes(x=Date, y=CumMax.CumRET), color='red')</code></pre><p><img src="/images/find_drawdowns/find_drawdowns_plot4.png" alt="Alt text" /></p>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stock Market </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode | DFS 总结</title>
      <link href="2020/11/13/Leetcode-DFS-%E6%80%BB%E7%BB%93/"/>
      <url>2020/11/13/Leetcode-DFS-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>DFS（深度优先搜索），是算法题中比掌握的一门武艺。我在一开始刷题时，总是不确定dfs的input该写什么，里面for loop又该写什么，但是看别人答案又看得懂，觉得很简单，自己写就不行了。尝试着总结了很多遍，每一遍都有新的体会，现在觉得有点开窍，所以想把整个思路整理记录下来。</p><a id="more"></a><p>其实掌握dfs的写法，还是要追溯到最开始的步骤，先抛开编程语言的写法，用大白话叙述出来。如果能用大白话叙述出来了，再尝试着写成伪代码，最后再对应题目用编程语言实现。<br />深度优先搜索是用在图中的一种搜索算法，搜索的对象是满足条件的路径，要么是个数，要么是记录全部路径。<br />其实只需要理清三个概念：<strong>状态</strong>、<strong>路径</strong>、<strong>选择</strong>，就能讲好这个故事。</p><h2 id="一-大白话描述"><a class="markdownIt-Anchor" href="#一-大白话描述"></a> 一、大白话描述</h2><p>【状态】站在图的一个节点上，【选择】在所有没有访问过的邻居节点中选择一个节点，【路径】更新状态并加入路径，以这个节点重新开始一轮dfs，直到没有可往下走的邻居节点，就判断是否满足条件，如果满足，将路径记录下来，然后返回。如果在想解决方案的时候，能想到可以先一条路走到底，再往回走一步换个方向再走到底，就是要用dfs了。</p><h2 id="二-伪代码"><a class="markdownIt-Anchor" href="#二-伪代码"></a> 二、伪代码</h2><pre class="highlight"><code class="">//调用dfs(【起始状态】，【空路径】);//定义dfs(【状态】，【路径】){  if(没有进一步的【选择】){    if(满足条件){      记录【路径】;    }    return;  }  for(所有可选的【选择】){    标记【选择】，更新【状态】，更新【路径】; //凡是不需要恢复标记的题，标记选择都是在for loop之上    dfs(【新状态】，【新路径】);    去除标记，恢复状态，恢复路径;  }}</code></pre><h2 id="三-干题"><a class="markdownIt-Anchor" href="#三-干题"></a> 三、干题</h2><h3 id="46-permutations"><a class="markdownIt-Anchor" href="#46-permutations"></a> 46. Permutations</h3><p>Medium: <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a><br />要记录所有的排列，那么先搞清楚三个概念分别对应什么。<br /><strong>状态</strong>：哪些数字已经被访问了 （boolean[] visited）以及现在填到第几个空格了；<br /><strong>路径</strong>：已经排好的数字（List&lt;Integer&gt;out）；<br /><strong>选择</strong>：没有被访问的数字；</p><pre class="highlight"><code class="">List&lt;List&lt;Integer&gt;&gt; res;boolean[] visited;public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums){  res = new ArrayList();  visited = new boolean[nums.length];  dfs(nums, 0, new ArrayList()); //初始状态 + 空路径  return res;}public void dfs(int[] nums, int index, List&lt;Integer&gt; out){  if(index == nums.length){ //往下填不了了    res.add(new ArrayList(out)); //记录路径    return;  }  for(int i = 0; i &lt; nums.length; i++){    if(!visited[i]){ //选择没有访问过的数字      visited[i] = true; //标记状态      out.add(nums[i]); //更新路径      dfs(nums, index + 1, out);      out.remove(out.size() - 1); //恢复路径      visited[i] = false; //恢复状态    }  }}</code></pre><h3 id="679-24-game"><a class="markdownIt-Anchor" href="#679-24-game"></a> 679. 24 Game</h3><p>Hard: <a href="https://leetcode.com/problems/24-game/" target="_blank" rel="noopener">https://leetcode.com/problems/24-game/</a><br />再来一道Hard题体会体会。<br />给四张牌，每张牌的数字可能是1到9的其中一个，判断这四个数能否通过 <strong>*</strong>, <strong>/</strong>, <strong>+</strong>, <strong>-</strong>, <strong>(</strong>, <strong>)</strong> 这些符号去得到24.<br /><strong>状态</strong>：现在的结果是多少，哪些数字已经用过了；但是现在的结果也会作为一个数字参与计算，所以不能用普通的记录方法。用List把数字记录，把中间的结果也放进去；<br /><strong>路径</strong>：因为是判断是否存在，所以不需要记录过程，需要dfs返回true or false；<br /><strong>选择</strong>：剩下的没用过的数字；</p><pre class="highlight"><code class="">class Solution {    public boolean judgePoint24(int[] nums) {        List&lt;Double&gt; list = new ArrayList();        for(int n : nums)            list.add(1.0 * n);        return dfs(list);    }    public boolean dfs(List&lt;Double&gt; list){        if(list.size() == 1){ //如果list只有一个数字了，就直接判断            //这里之所以不是直接相等，因为过程中除法可能会除不尽            if(Math.abs(list.get(0) - 24) &lt; 0.001)                return true;            return false;        }        //选两个list中的数（当前状态），遍历所有可能性（所有选择），        //再组成新的list（新的状态），进行新的dfs        for(int i = 0; i &lt; list.size(); i++){            for(int j = i + 1; j &lt; list.size(); j++){                for(double ans : get_possible(list.get(i), list.get(j))){                    List&lt;Double&gt; tmp = new ArrayList();                    tmp.add(ans);                    for(int k = 0; k &lt; list.size(); k++){                        if(k == i || k == j) continue;                        tmp.add(list.get(k));                    }                    if(dfs(tmp)) return true;                }            }        }        return false;    }    public double[] get_possible(double n1, double n2){        return new double[]{n1 + n2, n1 - n2, n2 - n1, n1 * n2, n1 / n2, n2 / n1};    }}</code></pre><h3 id="489-robot-room-cleaner"><a class="markdownIt-Anchor" href="#489-robot-room-cleaner"></a> 489. Robot Room Cleaner</h3><p>Hard: [<a href="https://leetcode.com/problems/robot-room-cleaner/" target="_blank" rel="noopener">https://leetcode.com/problems/robot-room-cleaner/</a>]<br />题目不给绝对坐标，那么就用相对坐标，因为目的是把所有地方都打扫到，那么任意一个地方相对起始位置都是唯一且固定的。打扫的思路就是，顺着当前方向打扫下去，如果走不通了或者前方已经打扫过了，就转个方向继续前进，这里转方向可以规定为一直向右转或者向左转，如果是向右转，那么int[][] dirs这个数组就要是上、右、下、左的顺序。<br /><strong>状态</strong>：当前的位置（相对于起始位置）和方向（相对于起始方向），哪些地方已经打扫过了；<br /><strong>路径</strong>：不需要返回路径；<br /><strong>选择</strong>：能走得通并且没有打扫过的相邻格子；</p><pre class="highlight"><code class="java">    <span class="hljs-keyword">int</span>[][] dirs = &lt;!--￼<span class="hljs-number">0</span>--&gt;; <span class="hljs-comment">// 上，右，下，左</span>    Robot robot;    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanRoom</span><span class="hljs-params">(Robot robot)</span> </span>{        <span class="hljs-keyword">this</span>.robot = robot;        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 起始位置和方向</span>    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> d)</span></span>{        robot.clean();        set.add(i + <span class="hljs-string">","</span> + j); <span class="hljs-comment">// 记录（凡是不需要恢复标记的题，标记选择都是在for loop之上）</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++){ <span class="hljs-comment">// 四种可能的选择</span>            <span class="hljs-keyword">int</span> new_d = (d + k) % <span class="hljs-number">4</span>;            <span class="hljs-keyword">int</span> x = i + dirs[new_d][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> y = j + dirs[new_d][<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(!set.contains(x + <span class="hljs-string">","</span> + y) &amp;&amp; robot.move()){ <span class="hljs-comment">// 没有打扫过且可以走得通</span>                dfs(x, y, new_d);                robot.turnRight(); <span class="hljs-comment">// 恢复状态</span>                robot.turnRight();                robot.move();                robot.turnRight();                robot.turnRight();            }            robot.turnRight(); <span class="hljs-comment">// 下一个方向是上一个方向向右转</span>        }    }</code></pre><h3 id="797-all-paths-from-source-to-target"><a class="markdownIt-Anchor" href="#797-all-paths-from-source-to-target"></a> 797. All Paths From Source to Target</h3><p>Medium: <a href="https://leetcode.com/problems/all-paths-from-source-to-target/" target="_blank" rel="noopener">https://leetcode.com/problems/all-paths-from-source-to-target/</a><br />找出从0到n-1的所有路径。这就是一道几乎最典型的dfs的题了，一条道走到黑，再返回换个方向再走到黑。。。<br /><strong>状态</strong>：当前位置和已经走过的点；<br /><strong>路径</strong>：一路走来的路径；<br /><strong>选择</strong>：邻居中还没有走过的点；</p><pre class="highlight"><code class="">    List&lt;List&lt;Integer&gt;&gt; res;    boolean[] visited;    int n;    int[][] graph;    public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) {        res = new ArrayList();        this.graph = graph;        n = graph.length;        visited = new boolean[n];        List&lt;Integer&gt; out = new ArrayList();        //因为起点固定了，不是可以选择的，所以不用进dfs        out.add(0);        visited[0] = true;        dfs(0, out);        return res;    }    public void dfs(int cur, List&lt;Integer&gt; out){ // 状态，路径        if(cur == n - 1){ // 到达终点            res.add(new ArrayList(out));            return;        }        for(int nb : graph[cur]){ // 所有可能的选择            if(!visited[nb]){ // 邻居中还没有走过的点                visited[nb] = true; // 标记                out.add(nb); // 更新路径                dfs(nb, out);                out.remove(out.size() - 1); // 恢复路径                visited[nb] = false; // 恢复标记            }        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Scientist 常见面试题</title>
      <link href="2020/11/10/%E6%97%A5%E5%BF%97-Data-Scientist-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/11/10/%E6%97%A5%E5%BF%97-Data-Scientist-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Data Scientist（DS）面试内容和Software Engineer（SE）的面试内容大不相同。SE主要是刷算法题，而DS主要是复习统计的基础知识并应用到实际场景之中。（如果公式没有渲染成功，那就刷新一下吧~）</p><a id="more"></a><h2 id="1-linear-regression"><a class="markdownIt-Anchor" href="#1-linear-regression"></a> 1. Linear Regression</h2><p><strong>What are the assumptions of Linear Regression?</strong></p><ol><li>Linear Relationship (mean of the response variable is a linear combination of \(\beta\) and \(X\));</li><li>Independence (observations are independent of each other);</li><li>Multivariable Normality (residuals are normally distributed).</li></ol><p><strong>How to estimate coefficients \(\beta\), correlation \(r\), and R square \(R^2\)?</strong><br />If assume \(Y = \beta ^T X + \epsilon\) and \(\epsilon \sim N(0, 1)\), then<br />\[\hat{\beta}_{OLS} = (X ^T X)X ^T Y = \frac{cov(X, Y)}{Var(X)}\]<br />\[r = correlation(X, Y) = \frac{cov(X, Y)}{\sigma_X \sigma_Y}\]<br />\[R^2 = r^2 = \frac{cov(X, Y)^2}{Var(X) Var(Y)}\]</p><h2 id="2-logistic-regression"><a class="markdownIt-Anchor" href="#2-logistic-regression"></a> 2. Logistic Regression</h2><p><strong>What is Logistic Regression?</strong><br />It is a statistical model that uses a logistic function to model a binary dependent variable.<br />\[p_\theta (x) = \frac{1}{1 + e^{-\theta ^ T x}} \]<br />Likelihood function:</p><p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align* at position 7: \begin{̲a̲l̲i̲g̲n̲*̲}̲L(\theta | y; …'>\begin{align*}L(\theta | y; x) &amp;= Pr(Y|X;\theta) \\ &amp;= \prod_i Pr(y_i|x_i;\theta)\\ &amp;= \prod_i p_\theta (x_i)^{y_i} (1 - p_\theta (x_i))^{1 - y_i}\end{align*}</p><p>Objective function:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munder><mo>∑</mo><mi>i</mi></munder><mo stretchy="false">[</mo><msub><mi>y</mi><mi>i</mi></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">J(\theta) = -\frac{1}{m} \sum_i [y_i \log p_{\theta} (x_i) + (1 - y_i) \log (1 - p_{\theta} (x_i))]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.599109em;vertical-align:-1.277669em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p><h2 id="3-support-vector-machine"><a class="markdownIt-Anchor" href="#3-support-vector-machine"></a> 3. Support Vector Machine</h2><p><strong>What is Support Vector Machine (SVM)?</strong><br />A SVM constructs a hyperplane or set of hyperplanes in a high- or infinite-dimensional space, which can be used for classification, regression, or ther tasks like outliers detection.<br />SVM是一种二类分类模型。它的基本模型是在特征空间中寻找间隔最大化的分离超平面的线性分类器。</p><ul><li>当训练样本线性可分时，通过硬间隔最大化，学习一个线性分类器，即线性可分支持向量机；</li><li>当训练样本近似线性可分时，引入松弛变量，通过软间隔最大化，学习一个线性分类器，即线性支持向量机；</li><li>当训练样本线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。</li></ul><h2 id="4-decision-tree"><a class="markdownIt-Anchor" href="#4-decision-tree"></a> 4. Decision Tree</h2><p><strong>What is Decision Tree?</strong><br />A flowchart-like tree structure, where each internal node (non-leaf node) denotes a test on an attribute, each branch represents an outcome of the test, and each leaf node holds a value for the target variable.</p><p><strong>决策树的优缺点</strong></p><ul><li>优点<ul><li>计算简单，速度快；</li><li>可解释性强；</li><li>比较适合处理由缺失属性的样本。</li></ul></li><li>缺点<ul><li>容易发生过拟合（随机森林可以解决）；</li><li>忽略了特征之间的相关性。</li></ul></li></ul><p><strong>决策树的种类以及各类的特点</strong><br />决策树算法，无论哪种，目的都是为了让模型的不确定性（熵）降低的越快越好，不同的算法基于的指标不同。<br />熵 (Entropy \(H(S)\) is a measure of the amount of uncertainty in the data \(S\)):<br />\[H(S) = \sum_{x \in X} -p(x) \log_2 p(x)\]</p><ul><li>\(S\): the current dataset</li><li>\(X\): the set of classes in \(S\)</li><li>\(p(x)\): the proportion of the number of elements in class \(x\) to the number of elements in set \(S\)</li></ul><p>为了让熵尽快降低，尽量选择区分度更大的特征进行分裂：</p><ul><li><p>ID3算法：基于信息增益 (Information Gain)</p><ul><li>\(IG(S, A) = H(S) - H(S|A)\)。</li><li>\(IG\) can be calculated for each remaining attrubute.</li><li>The attribute with the largest \(IG\) is used to split \(S\).</li><li>缺点：信息增益准则对那些取值比较多的特征有所偏好，因为取值越多，分的越开，熵就越小。但是这样就会产生一些没有意义的分类，比如每个人都有身份证号码，如果单单看信息增益，那么就会按照每个身份证为一类，一类也只有一个人，这样每个子集的熵是0，但是没有任何意义。</li></ul></li><li><p>C4.5算法：信息增益率 (Information Gain Ratio)</p><ul><li>\(IGR(S, A) = \frac{IG(S, A)}{IV(A)}\), \(IV(A) = -\sum^n_{i=1} \frac{|S_i|}{|S|} \log_2 \frac{|S_i|}{|S|}\), n是特征A的取值个数，A的取值少的话，那么A的纯度比较高，\(IV(A)\)就比较小；相反，如果A的取值比较多，A的纯度就低，\(IV(A)\)就比较大。这样就中和了ID3算法的问题了。</li></ul></li><li><p>CART(classification and regression tree)算法：基尼系数 (Gini)</p><ul><li>\(Gini(A) = 1 - \sum_i^C p_i^2\), 其中\(p_i\)表示属于\(i\)类的概率，当\(Gini(A)=0\)时，所有样本属于同类，所有类在节点中以等概率出现时，最大化\(Gini(A) = C(C - 1) / 2\).</li></ul></li></ul><p><strong>决策树出现过拟合的原因和解决方法</strong></p><ul><li>原因：<ul><li>在决策树的构建过程中，对决策树的生长没有进行合理的剪枝；</li><li>构建过程中使用了取值较多的特征。</li></ul></li><li>解决办法：<ul><li>选择合理的参数进行剪枝，可以分为预剪枝和后剪枝，一般采用后剪枝的方法；</li><li>用K-folds交叉验证；</li><li>降维或者加正则化。</li></ul></li></ul><h2 id="5-bagging-vs-boosting"><a class="markdownIt-Anchor" href="#5-bagging-vs-boosting"></a> 5. Bagging v.s. Boosting</h2><p><strong>Bagging</strong><br />Bagging means <strong>B</strong>ootstrap <strong>agg</strong>regat<strong>ing</strong>. It is a machine learning ensemble meta-algorithm designed to improve the stability and accuracy in classification and regression. It also reduces variance and helps to avoid overfitting. Although it is usually applied to decision tree methods, it can be used with any type of method.</p><p><strong>Boosting</strong><br />Boosting is an ensemble meta-algorithm for reducing bias, and also variance in supervised learning.</p><p><strong>比较</strong></p><table><thead><tr><th>Bagging</th><th>Boosting</th></tr></thead><tbody><tr><td>reduce variance</td><td>reduce both variance and bias</td></tr><tr><td>majority vote for output</td><td>weighted sum of weak learners for output</td></tr><tr><td>resampling subset for training</td><td>whole dataset but different weight for samples</td></tr><tr><td>equal-weight weak learners</td><td>weighted by accuracy</td></tr><tr><td>easy parallelization</td><td>hard parallelization</td></tr><tr><td>Random Forest</td><td>Adaboosting, Gradient Boosting</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quant有趣面试题</title>
      <link href="2020/11/07/%E6%97%A5%E5%BF%97-Quant%E6%9C%89%E8%B6%A3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/11/07/%E6%97%A5%E5%BF%97-Quant%E6%9C%89%E8%B6%A3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>找工作的时候顺便也投了Quantitative Research这个职位，准备过程中学习到了很多有趣的题目。涉及的知识点也很广，主要集中在Probability, Linear Regression, Calculus, Quantative Finance。（如果公式没有渲染成功，那就刷新一下吧~）</p><a id="more"></a><h2 id="赛道加油问题"><a class="markdownIt-Anchor" href="#赛道加油问题"></a> 赛道加油问题</h2><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>假设你在一个单向环形的赛道上。有N个加油站随机分布在赛道的不同位置，所有加油站的油加起来刚好能跑完一圈。假设你的车最开始是没有油的，但是你能选择任意一个位置作为开始位置，并且在前进过程中每遇到一个加油站你能加里面的油。请问，你是否总能选择一个合适的开始位置去跑完一圈？</p><h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3><p>从最简单的情况开始想，假如\(N=1\)，答案是肯定能跑完；假如\(N=2\)，用\(x_1\)和\(x_2\)表示站1和站2的油分别能跑的距离，用\(y_1\)和\(y_2\)表示站1-&gt;站2的距离和站2-&gt;站1的距离（赛道是单向环形），由于\(x_1+x_2=1\)并且\(y_1+y_2=1\)，那么\(x_1 \geq y_1\)或者\(x_2 \geq y_2\) (因为\(x_1 &lt; y_1\)和\(x_2 &lt; y_2\)不可能同时成立)。如果\(x_1 \geq y_1\)，我们就能从站1出发，有足够的油来到站2，并加完站2的油，去跑完剩下的。反之亦然。</p><p>接下来可以用Induction来证明，假设\(N=n\)成立，那么\(N=n+1\)也成立。</p><p>对于\(N=n+1\)，我们有\(x_1+x_2+…+x_{n+1}=1\)并且\(y_1+y_2+…+y_{n+1}=1\)。所以肯定存在一个\(i\)，\(1 \leq i \leq n+1\)，使得\(x_i \geq y_i\)，这就意味着一旦车到达了站\(i\)，就能到达站\(i+1\)。用另外的话说，我们可以将站\(i\)和站\(i+1\)合并起来，合并站将拥有油能跑\(x_i + x_{i+1}\)距离。这样就将问题转化为了\(N=n\)问题，所以\(N=n+1\)也就同样成立了。</p><h2 id="生日问题"><a class="markdownIt-Anchor" href="#生日问题"></a> 生日问题</h2><h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3><p>需要至少多少人在同一个房间里，能使得有两个人是同一天生日的概率大于\(1/2\)？</p><h3 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h3><p>答案是至少需要23人。</p><p>假设有\(n\)个人，那么可能有\(365^n\)种组合。这里计算没有重复的生日会比较容易，一共有\(365 \times 364 \times … \times (365 - n + 1)\)种组合。那么我们需要找到最小的\(n\)使得<br />\[\frac{365 \times 364 \times … \times (365 - n + 1)}{365^n} \leq 1/2\]</p><h2 id="扔硬币游戏"><a class="markdownIt-Anchor" href="#扔硬币游戏"></a> 扔硬币游戏</h2><p>扔硬币的题目可能是考概率最常见的场景了。</p><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3><p>A和B在玩掷硬币的游戏，A有\(n+1\)个正常的硬币，B有\(n\)个正常的硬币。如果他们都一次性掷完所有硬币，问A有更多的head的概率。</p><p>我们将三种情况标记如下：</p><ul><li>\(E_1\): A的n个硬币中的head &gt; B的n个硬币中的head；</li><li>\(E_2\): A的n个硬币中的head = B的n个硬币中的head；</li><li>\(E_3\): A的n个硬币中的head &lt; B的n个硬币中的head；</li></ul><p>如果我们从A拿走一枚硬币，那么A和B的所有情况就都是一样了，那么\(E_1\)和\(E_3\)是对称的，所以\(P(E_1) = P(E_3)\)。让我们标记\(P(E_1) = P(E_3) = x, P(E_2) = y\)，那么\(2x + y = 1\)。</p><p>如果A多一枚硬币，对于\(E_1\)，A本来就比B多，所以A增加一枚硬币不影响结果；对于\(E_2\)，如果多的那枚硬币是head，\(E_2\)就变成\(E_1\)了，概率为\(1/2\)；对于\(E_3\)，A增加一枚硬币不会改变\(E_1\)。所以最终结果就是，当A有\(n+1\)个硬币时，head比B多的概率是\(x + 0.5y = x + 0.5(1 - 2x) = 0.5\)。</p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3><p>A和B还是玩掷硬币的游戏，他们轮流掷一枚正常的硬币，A先掷。记录硬币的结果顺序，如果出现head–&gt;tail (HT)，那掷出这个tail的人赢。问A获胜的概率是多少。</p><p>首先要把这个问题转换为先手和后手谁会赢的问题，因为在掷的过程中，A可能会成为新游戏的后手。<br />用\(P(A)\)和\(P(B)\)分别代表先手和后手获胜的概率，那么\(P(B) = 1 - P(A)\)。先手分别有\(1/2\)的概率掷\(H\)和\(T\)，那么先手获胜的条件概率为<br />\[P(A) = 1/2P(A|H) + 1/2P(A|T)\]<br />如果先手的第一次是\(T\)，那么先手将成为新游戏的后手，所以<br />\[P(A|T)=P(B)=1-P(A)\]<br />如果先手的第一次是\(H\)，那么就要讨论后手的情况。后手有\(1/2\)的概率掷得\(T\)，也就是后手赢先手输。如果后手以\(1/2\)概率掷得\(H\)，那么后手将变成新游戏中掷得一个\(H\)的先手，这种情况下，当前游戏的先手获胜的概率为\(1 - P(A|H)\)，所以<br />\[P(A|H) = 1/2 \times 0 + 1/2 \times (1 - P(A|H)) =&gt; P(A|H) = 1/3\]<br />结合以上所有信息，我们就能算出先手获胜的概率为<br />\[P(A) = 1/2 \times 1/3 + 1/2 \times (1 - P(A)) =&gt; P(A) = 4/9\]<br />直觉上想，也很容易猜到\(P(A) &lt; 1/2\)，因为先手不可能掷一次就赢，但后手有\(1/4\)的概率掷一次就赢。</p><h2 id="扔色子游戏"><a class="markdownIt-Anchor" href="#扔色子游戏"></a> 扔色子游戏</h2><h3 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h3><p>有一个正常的六面色子，可以最多扔3次。扔到几就得几块钱，之后可以选择重新扔或者停止并获得当前的钱。你愿意花多少钱来玩这个游戏？</p><h3 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h3><p>问愿意花多少钱来玩这个游戏其实就是问玩这个游戏获得钱数的期望是多少。这是一个动态规划的问题，需要从最后的一轮往回推，因为最后一轮的期望值是可以直接算出来的。第三轮的期望值是\(1/6 \times (1 + 2 + 3 + 4 + 5 + 6) = $3.5\)。那么在第二轮的时候，如果扔出了4、5、6，就不会继续扔了，如果是1、2、3就会继续扔，那么第二轮的期望值是\(3/6 \times 3.5 + 1/6 \times (4 + 5 + 6) = $4.25\)。所以，在第一轮的时候，如果我花的钱比$4.25少，我是愿意扔的，也就是愿意玩这个游戏的。因此，我最多会花$4.25来玩这个游戏。</p><h2 id="随机变量之和"><a class="markdownIt-Anchor" href="#随机变量之和"></a> 随机变量之和</h2><h3 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h3><p>假设\(X_1, X_2, …, X_n\)是IID (independent and identically-distributed) 地服从0到1 uniform distribution。问\(S_n = X_1 + X_2 + … + X_n \leq 1\)的概率。</p><h3 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h3><p>从\(n=1\)开始，\(P(S_1 = X_1 \leq 1) = 1\)。如果\(n=2\)，那么\(P(S_2 = X_1 + X_2 \leq 1) = 1/2\)，因为\(X_1\)和\(X_2\)画出来就是一个正方形，\(X_1 + X_2 \leq 1\)就是左下角的三角形的面积。如果\(n=3\)，那就是正方体左下角的三角锥的体积：\(1/3 \times 1/2 = 1/6\)。那么我们可以猜测\(P(S_n \leq 1) = 1 / n!\)。接下来用Induction来证明，先假设\(P(S_n \leq 1) = 1/n!\)成立，需要证明\(P(S_{n+1} \leq 1) = 1 / (n+1)!\)也成立。（证明过程有点复杂，请上网查询 😅）</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Quantative Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1008. Construct Binary Search Tree from Preorder Traversal</title>
      <link href="2020/02/18/Leetcode-1008-Construct-Binary-Search-Tree-from-Preorder-Traversal/"/>
      <url>2020/02/18/Leetcode-1008-Construct-Binary-Search-Tree-from-Preorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Medium 75.1%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Return the root node of a binary search tree that matches the given preorder traversal.</p><p>(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)</p><p>Example 1:</p><pre class="highlight"><code class="">Input: [8,5,1,7,10,12]Output: [8,5,10,1,7,null,12]</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>还是要习惯把右边当作不可到达的长度值。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">bstFromPreorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder)</span> </span>{        <span class="hljs-keyword">return</span> helper(preorder, <span class="hljs-number">0</span>, preorder.length);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] p, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>{        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> max_ind = right;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = left; i &lt; right; i++){            <span class="hljs-keyword">if</span>(p[i] &gt; p[left]){                max_ind = i;                <span class="hljs-keyword">break</span>;            }        }        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(p[left]);        root.left = helper(p, left+<span class="hljs-number">1</span>, max_ind);        root.right = helper(p, max_ind, right);        <span class="hljs-keyword">return</span> root;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 6.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14. Longest Common Prefix</title>
      <link href="2020/02/18/Leetcode-14-Longest-Common-Prefix/"/>
      <url>2020/02/18/Leetcode-14-Longest-Common-Prefix/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-prefix/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Easy 34.7%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>{        <span class="hljs-keyword">int</span> N = strs.length;        <span class="hljs-keyword">if</span>(N == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;        <span class="hljs-keyword">int</span> min_len = strs[<span class="hljs-number">0</span>].length();        <span class="hljs-keyword">for</span>(String s : strs)            min_len = Math.min(min_len, s.length());        String res = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; min_len; i++){            <span class="hljs-keyword">char</span> cur = strs[<span class="hljs-number">0</span>].charAt(i);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.length; j++)                <span class="hljs-keyword">if</span>(strs[j].charAt(i) != cur)                    <span class="hljs-keyword">return</span> res;            res += cur;        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 11.78%<br />Memory: 76.02%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>648. Replace Words</title>
      <link href="2020/02/16/Leetcode-648-Replace-Words/"/>
      <url>2020/02/16/Leetcode-648-Replace-Words/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/replace-words/" target="_blank" rel="noopener">https://leetcode.com/problems/replace-words/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Medium 54.7%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another.</p><p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.</p><p>You need to output the sentence after the replacement.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]sentence = &quot;the cattle was rattled by the battery&quot;Output: &quot;the cat was rat by the bat&quot;</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题目给了一些词根，和一句话。要求用词根替换句子里面的词。所以是一道很明显用trie的题。<br />首先是把词根放入trie，因为是要做替换，所以在构建trienode的时候要记录string。然后trienode的function比较多，CPGSSI (containsChild, put, get, setString, setEnd, isEnd)。因为是trie作为prefix，所以在searchprefix的时候就要判断是否是end，否则就不属于这个prefix。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span></span>{        TrieNode[] children;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">26</span>;        <span class="hljs-keyword">boolean</span> isEnd;        String string;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span></span>{            children = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsChild</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>{            <span class="hljs-keyword">return</span> children[c - <span class="hljs-string">'a'</span>] != <span class="hljs-keyword">null</span>;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, TrieNode node)</span></span>{            children[c - <span class="hljs-string">'a'</span>] = node;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>{            <span class="hljs-keyword">return</span> children[c - <span class="hljs-string">'a'</span>];        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setString</span><span class="hljs-params">(String a)</span></span>{            string = a;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">()</span></span>{            isEnd = <span class="hljs-keyword">true</span>;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span></span>{            <span class="hljs-keyword">return</span> isEnd;        }    }    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span></span>{        TrieNode root;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>{            root = <span class="hljs-keyword">new</span> TrieNode();        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String s)</span></span>{            TrieNode node = root;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++){                <span class="hljs-keyword">char</span> cur = s.charAt(i);                <span class="hljs-keyword">if</span>(!node.containsChild(cur))                    node.put(cur, <span class="hljs-keyword">new</span> TrieNode());                node = node.get(cur);            }            node.setEnd();            node.setString(s);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">searchPrefix</span><span class="hljs-params">(String s)</span></span>{            TrieNode node = root;            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(!node.isEnd &amp;&amp; i &lt; s.length()){                <span class="hljs-keyword">char</span> cur = s.charAt(i++);                <span class="hljs-keyword">if</span>(!node.containsChild(cur)) <span class="hljs-keyword">break</span>;                node = node.get(cur);            }            <span class="hljs-keyword">return</span> node.isEnd ? node.string : <span class="hljs-string">""</span>;        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dict, String sentence)</span> </span>{        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        Trie trie = <span class="hljs-keyword">new</span> Trie();        <span class="hljs-keyword">for</span>(String s : dict)            trie.insert(s);        <span class="hljs-keyword">for</span>(String s : sentence.split(<span class="hljs-string">" "</span>)){            String r = trie.searchPrefix(s);            <span class="hljs-keyword">if</span>(r.equals(<span class="hljs-string">""</span>))                sb.append(s);            <span class="hljs-keyword">else</span>                sb.append(r);            sb.append(<span class="hljs-string">" "</span>);        }        <span class="hljs-keyword">return</span> sb.substring(<span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>).toString();    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 99.14%<br />Memory: 75.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208. Implement Trie (Prefix Tree)</title>
      <link href="2020/02/16/Leetcode-208-Implement-Trie-Prefix-Tree/"/>
      <url>2020/02/16/Leetcode-208-Implement-Trie-Prefix-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsimplement-trie-prefix-tree"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsimplement-trie-prefix-tree"></a> 题目链接https://leetcode.com/problems/implement-trie-prefix-tree/</h2><h2 id="题目难度medium-436"><a class="markdownIt-Anchor" href="#题目难度medium-436"></a> 题目难度Medium 43.6%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Implement a trie with insert, search, and startsWith methods.</p><p>Example 1:</p><pre class="highlight"><code class="">Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;);   // returns truetrie.search(&quot;app&quot;);     // returns falsetrie.startsWith(&quot;app&quot;); // returns truetrie.insert(&quot;app&quot;);trie.search(&quot;app&quot;);     // returns true</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>看讲解[<a href="https://leetcode.com/problems/implement-trie-prefix-tree/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-trie-prefix-tree/solution/</a>]</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span></span>{    TrieNode[] children;    <span class="hljs-keyword">int</span> l = <span class="hljs-number">26</span>;    <span class="hljs-keyword">boolean</span> isEnd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span></span>{        children = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsChild</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>{        <span class="hljs-keyword">return</span> children[c - <span class="hljs-string">'a'</span>] != <span class="hljs-keyword">null</span>;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>{        <span class="hljs-keyword">return</span> children[c - <span class="hljs-string">'a'</span>];    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, TrieNode node)</span></span>{        children[c - <span class="hljs-string">'a'</span>] = node;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">()</span></span>{        isEnd = <span class="hljs-keyword">true</span>;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">return</span> isEnd;    }}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>{    TrieNode root;    <span class="hljs-comment">/** Initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>{        root = <span class="hljs-keyword">new</span> TrieNode();    }    <span class="hljs-comment">/** Inserts a word into the trie. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>{        TrieNode node = root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++){            <span class="hljs-keyword">char</span> cur = word.charAt(i);            <span class="hljs-keyword">if</span>(!node.containsChild(cur)){                node.put(cur, <span class="hljs-keyword">new</span> TrieNode());            }            node = node.get(cur);        }        node.setEnd();    }    <span class="hljs-function"><span class="hljs-keyword">private</span> TrieNode <span class="hljs-title">searchPrefix</span><span class="hljs-params">(String word)</span></span>{        TrieNode node = root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++){            <span class="hljs-keyword">char</span> cur = word.charAt(i);            <span class="hljs-keyword">if</span>(!node.containsChild(cur)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            node = node.get(cur);        }        <span class="hljs-keyword">return</span> node;    }    <span class="hljs-comment">/** Returns if the word is in the trie. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>{        TrieNode node = searchPrefix(word);        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.isEnd();    }    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>{        TrieNode node = searchPrefix(prefix);        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span>;    }}<span class="hljs-comment">/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */</span></code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>422. Valid Word Square</title>
      <link href="2020/02/16/Leetcode-422-Valid-Word-Square/"/>
      <url>2020/02/16/Leetcode-422-Valid-Word-Square/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsvalid-word-square"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsvalid-word-square"></a> 题目链接https://leetcode.com/problems/valid-word-square/</h2><h2 id="题目难度easy-371"><a class="markdownIt-Anchor" href="#题目难度easy-371"></a> 题目难度Easy 37.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a sequence of words, check whether it forms a valid word square.</p><p>A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns).</p><p>Note:</p><ol><li>The number of words given is at least 1 and does not exceed 500.</li><li>Word length will be at least 1 and does not exceed 500.</li><li>Each word contains only lowercase English alphabet a-z.</li></ol><p>Example 1:</p><pre class="highlight"><code class="">Input:[  &quot;abcd&quot;,  &quot;bnrt&quot;,  &quot;crmy&quot;,  &quot;dtye&quot;]Output:trueExplanation:The first row and first column both read &quot;abcd&quot;.The second row and second column both read &quot;bnrt&quot;.The third row and third column both read &quot;crmy&quot;.The fourth row and fourth column both read &quot;dtye&quot;.Therefore, it is a valid word square.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>细节挺多的。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validWordSquare</span><span class="hljs-params">(List&lt;String&gt; words)</span> </span>{        <span class="hljs-keyword">int</span> N = words.size();        <span class="hljs-keyword">if</span>(N != words.get(<span class="hljs-number">0</span>).length()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">char</span>[][] ca = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[N][N];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++){            String s = words.get(i);            <span class="hljs-keyword">if</span>(s.length() &gt; N) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++)                ca[i][j] = s.charAt(j);        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; N; j++)                <span class="hljs-keyword">if</span>(ca[i][j] != ca[j][i]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 98.18%<br />Memory: 16.67%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1037. Valid Boomerang</title>
      <link href="2020/02/16/Leetcode-1037-Valid-Boomerang/"/>
      <url>2020/02/16/Leetcode-1037-Valid-Boomerang/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsvalid-boomerang"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsvalid-boomerang"></a> 题目链接https://leetcode.com/problems/valid-boomerang/</h2><h2 id="题目难度easy-376"><a class="markdownIt-Anchor" href="#题目难度easy-376"></a> 题目难度Easy 37.6%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>A boomerang is a set of 3 points that are all distinct and not in a straight line.</p><p>Given a list of three points in the plane, return whether these points are a boomerang.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: [[1,1],[2,3],[3,2]]Output: true</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>比较垃圾的题。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBoomerang</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points)</span> </span>{        <span class="hljs-keyword">int</span>[] p1 = points[<span class="hljs-number">0</span>], p2 = points[<span class="hljs-number">1</span>], p3 = points[<span class="hljs-number">2</span>];        <span class="hljs-keyword">if</span>(p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>] &amp;&amp; p1[<span class="hljs-number">1</span>] == p2[<span class="hljs-number">1</span>] || p1[<span class="hljs-number">0</span>] == p3[<span class="hljs-number">0</span>] &amp;&amp; p1[<span class="hljs-number">1</span>] == p3[<span class="hljs-number">1</span>] || p2[<span class="hljs-number">0</span>] == p3[<span class="hljs-number">0</span>] &amp;&amp; p2[<span class="hljs-number">1</span>] == p3[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>] &amp;&amp; p1[<span class="hljs-number">0</span>] == p3[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(p1[<span class="hljs-number">1</span>] == p2[<span class="hljs-number">1</span>] &amp;&amp; p1[<span class="hljs-number">1</span>] == p3[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>] || p1[<span class="hljs-number">0</span>] == p3[<span class="hljs-number">0</span>] || p2[<span class="hljs-number">0</span>] == p3[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(p1[<span class="hljs-number">1</span>] == p2[<span class="hljs-number">1</span>] || p1[<span class="hljs-number">1</span>] == p3[<span class="hljs-number">1</span>] || p2[<span class="hljs-number">1</span>] == p3[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)(p1[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>]) / (p1[<span class="hljs-number">0</span>] - p2[<span class="hljs-number">0</span>]) != (<span class="hljs-keyword">double</span>)(p1[<span class="hljs-number">1</span>] - p3[<span class="hljs-number">1</span>]) / (p1[<span class="hljs-number">0</span>] - p3[<span class="hljs-number">0</span>]);    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>240. Search a 2D Matrix II</title>
      <link href="2020/02/15/Leetcode-240-Search-a-2D-Matrix-II/"/>
      <url>2020/02/15/Leetcode-240-Search-a-2D-Matrix-II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemssearch-a-2d-matrix-ii"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemssearch-a-2d-matrix-ii"></a> 题目链接https://leetcode.com/problems/search-a-2d-matrix-ii/</h2><h2 id="题目难度medium-423"><a class="markdownIt-Anchor" href="#题目难度medium-423"></a> 题目难度Medium 42.3%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p>Example 1:</p><pre class="highlight"><code class="">Consider the following matrix:[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>逆向思维啊</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>{        <span class="hljs-keyword">int</span> row = matrix.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; matrix[<span class="hljs-number">0</span>].length){            <span class="hljs-keyword">if</span>(matrix[row][col] &gt; target)                row--;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][col] &lt; target)                col++;            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>720. Longest Word in Dictionary</title>
      <link href="2020/02/15/Leetcode-720-Longest-Word-in-Dictionary/"/>
      <url>2020/02/15/Leetcode-720-Longest-Word-in-Dictionary/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemslongest-word-in-dictionary"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemslongest-word-in-dictionary"></a> 题目链接https://leetcode.com/problems/longest-word-in-dictionary/</h2><h2 id="题目难度easy-470"><a class="markdownIt-Anchor" href="#题目难度easy-470"></a> 题目难度Easy 47.0%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order.</p><p>If there is no answer, return the empty string.</p><p>Example 1:</p><pre class="highlight"><code class="language-markup">Input:words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]Output: &quot;world&quot;Explanation:The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="language-java">class Solution {    public String longestWord(String[] words) {        Set&lt;String&gt; set = new HashSet();        String res = &quot;&quot;;        for(String s : words)            set.add(s);        for(String s : words){            int i = 1;            for(; i &lt; s.length(); i++){                if(!set.contains(s.substring(0, i))) break;            }            if(i == s.length()){                if(res.length() &lt; s.length())                    res = s;                else if(res.length() == s.length())                    res = helper(s, res);            }        }        return res;    }    public String helper(String s, String t){        boolean flag = true;        for(int i = 0; i &lt; s.length(); i++){            if(s.charAt(i) == t.charAt(i)) continue;            if(s.charAt(i) &gt; t.charAt(i)){                flag = false;                break;            } else break;        }        return flag ? s : t;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 16.75%<br />Memory: 6.25%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>399. Evaluate Division</title>
      <link href="2020/02/14/Leetcode-399-Evaluate-Division/"/>
      <url>2020/02/14/Leetcode-399-Evaluate-Division/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsevaluate-division"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsevaluate-division"></a> 题目链接https://leetcode.com/problems/evaluate-division/</h2><h2 id="题目难度medium-499"><a class="markdownIt-Anchor" href="#题目难度medium-499"></a> 题目难度Medium 49.9%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.</p><p>Example 1:</p><pre class="highlight"><code class="">Given a / b = 2.0, b / c = 3.0.queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .return [6.0, 0.5, -1.0, 1.0, -1.0 ].The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector&lt;double&gt;.According to the example above:equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],values = [2.0, 3.0],queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>{        Map&lt;String, String&gt; parent; <span class="hljs-comment">// &lt;node, parent of node&gt;</span>        Map&lt;String, Double&gt; ratio; <span class="hljs-comment">// &lt;node, parent / node&gt;</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">()</span></span>{            parent = <span class="hljs-keyword">new</span> HashMap();            ratio = <span class="hljs-keyword">new</span> HashMap();        }        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">find</span><span class="hljs-params">(String p)</span></span>{            <span class="hljs-keyword">if</span>(p.equals(parent.get(p)))                <span class="hljs-keyword">return</span> p;            String father = parent.get(p);            String grandfather = parent.get(father);            parent.put(p, grandfather);            ratio.put(p, ratio.get(p) * ratio.get(father));            <span class="hljs-keyword">return</span> parent.get(p);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(String p, String q, <span class="hljs-keyword">double</span> val)</span></span>{            <span class="hljs-keyword">if</span>(!parent.containsKey(p)){                parent.put(p, p);                ratio.put(p, <span class="hljs-number">1.0</span>);            }            <span class="hljs-keyword">if</span>(!parent.containsKey(q)){                parent.put(q, q);                ratio.put(q, <span class="hljs-number">1.0</span>);            }            String rootp = find(p);            String rootq = find(q);            parent.put(rootq, rootp);            ratio.put(rootq, ratio.get(p) * val / ratio.get(q));        }    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) {        <span class="hljs-keyword">int</span> n = queries.size();        <span class="hljs-keyword">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n];        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; equations.size(); i++){            List&lt;String&gt; list = equations.get(i);            String p = list.get(<span class="hljs-number">0</span>);            String q = list.get(<span class="hljs-number">1</span>);            uf.union(p, q, values[i]);        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){            List&lt;String&gt; query = queries.get(i);            String p = query.get(<span class="hljs-number">0</span>);            String q = query.get(<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(!uf.parent.containsKey(p) || !uf.parent.containsKey(q) || !uf.find(p).equals(uf.find(q)))                res[i] = -<span class="hljs-number">1.0</span>;            <span class="hljs-keyword">else</span>{                res[i] = uf.ratio.get(q) / uf.ratio.get(p);            }        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 7.84%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1319. Number of Operations to Make Network Connected</title>
      <link href="2020/02/14/Leetcode-1319-Number-of-Operations-to-Make-Network-Connected/"/>
      <url>2020/02/14/Leetcode-1319-Number-of-Operations-to-Make-Network-Connected/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsnumber-of-operations-to-make-network-connected"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsnumber-of-operations-to-make-network-connected"></a> 题目链接https://leetcode.com/problems/number-of-operations-to-make-network-connected/</h2><h2 id="题目难度medium-505"><a class="markdownIt-Anchor" href="#题目难度medium-505"></a> 题目难度Medium 50.5%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>There are n computers numbered from 0 to n-1 connected by ethernet cables connections forming a network where connections[i] = [a, b] represents a connection between computers a and b. Any computer can reach any other computer directly or indirectly through the network.</p><p>Given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the minimum number of times you need to do this in order to make all the computers connected. If it’s not possible, return -1.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: n = 4, connections = [[0,1],[0,2],[1,2]]Output: 1Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>{        <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-keyword">int</span> count;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];            count = n;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)                parent[i] = i;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>{            <span class="hljs-keyword">if</span>(p == parent[p])                <span class="hljs-keyword">return</span> p;            <span class="hljs-keyword">return</span> parent[p] = find(parent[p]);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>{            <span class="hljs-keyword">int</span> rootp = find(p);            <span class="hljs-keyword">int</span> rootq = find(q);            <span class="hljs-keyword">if</span>(rootp == rootq)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            parent[rootq] = rootp;            count--;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">makeConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] connections)</span> </span>{        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);        <span class="hljs-keyword">int</span> unused = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] c : connections){            <span class="hljs-keyword">boolean</span> flag = uf.union(c[<span class="hljs-number">0</span>], c[<span class="hljs-number">1</span>]);            <span class="hljs-keyword">if</span>(!flag)                unused++;        }        <span class="hljs-keyword">return</span> unused &gt;= (uf.count-<span class="hljs-number">1</span>) ? (uf.count-<span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 92.13%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>323. Number of Connected Components in an Undirected Graph</title>
      <link href="2020/02/14/Leetcode-323-Number-of-Connected-Components-in-an-Undirected-Graph/"/>
      <url>2020/02/14/Leetcode-323-Number-of-Connected-Components-in-an-Undirected-Graph/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsnumber-of-connected-components-in-an-undirected-graph"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsnumber-of-connected-components-in-an-undirected-graph"></a> 题目链接https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/</h2><h2 id="题目难度542"><a class="markdownIt-Anchor" href="#题目难度542"></a> 题目难度54.2%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]]     0          3     |          |     1 --- 2    4Output: 2</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>典型的找连同分量的个数，没有任何trick。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>{        <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-keyword">int</span> count;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];            count = n;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)                parent[i] = i;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>{            <span class="hljs-keyword">if</span>(p == parent[p])                <span class="hljs-keyword">return</span> p;            <span class="hljs-keyword">return</span> parent[p] = find(parent[p]);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>{            <span class="hljs-keyword">int</span> rootp = find(p);            <span class="hljs-keyword">int</span> rootq = find(q);            <span class="hljs-keyword">if</span>(rootp != rootq){                parent[rootq] = rootp;                count--;            }        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countComponents</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges)</span> </span>{        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] e : edges){            uf.union(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]);        }        <span class="hljs-keyword">return</span> uf.count;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>947. Most Stones Removed with Same Row or Column</title>
      <link href="2020/02/14/Leetcode-947-Most-Stones-Removed-with-Same-Row-or-Column/"/>
      <url>2020/02/14/Leetcode-947-Most-Stones-Removed-with-Same-Row-or-Column/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsmost-stones-removed-with-same-row-or-column"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsmost-stones-removed-with-same-row-or-column"></a> 题目链接https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/</h2><h2 id="题目难度medium-548"><a class="markdownIt-Anchor" href="#题目难度medium-548"></a> 题目难度Medium 54.8%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point may have at most one stone.</p><p>Now, a move consists of removing a stone that shares a column or row with another stone on the grid.</p><p>What is the largest possible number of moves we can make?</p><p>Example 1:</p><pre class="highlight"><code class="">Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]Output: 5</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>{        <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-keyword">int</span> count;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];            count = n;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)                parent[i] = i;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>{            <span class="hljs-keyword">if</span>(p == parent[p])                <span class="hljs-keyword">return</span> p;            <span class="hljs-keyword">return</span> parent[p] = find(parent[p]);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>{            <span class="hljs-keyword">int</span> rootp = find(p);            <span class="hljs-keyword">int</span> rootq = find(q);            <span class="hljs-keyword">if</span>(rootp != rootq){                parent[rootq] = rootp;                count--;            }        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeStones</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] stones)</span> </span>{        <span class="hljs-keyword">int</span> N = stones.length;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(N);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++){                <span class="hljs-keyword">if</span>(i != j &amp;&amp; (stones[i][<span class="hljs-number">0</span>] == stones[j][<span class="hljs-number">0</span>] || stones[i][<span class="hljs-number">1</span>] == stones[j][<span class="hljs-number">1</span>]))                    uf.union(i, j);            }        }        <span class="hljs-keyword">return</span> N - uf.count;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 25.74%<br />Memory: 78.54%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DFS </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>684. Redundant Connection</title>
      <link href="2020/02/13/Leetcode-684-Redundant-Connection/"/>
      <url>2020/02/13/Leetcode-684-Redundant-Connection/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsredundant-connection"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsredundant-connection"></a> 题目链接https://leetcode.com/problems/redundant-connection/</h2><h2 id="题目难度medium-552"><a class="markdownIt-Anchor" href="#题目难度medium-552"></a> 题目难度Medium 55.2%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>In this problem, a tree is an undirected graph that is connected and has no cycles.</p><p>The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p><p>The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v.</p><p>Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]Output: [1,4]Explanation: The given undirected graph will be like this:5 - 1 - 2    |   |    4 - 3</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>等做完union find了再来写。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>{        <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)                parent[i] = i;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>{            <span class="hljs-keyword">if</span>(p == parent[p])                <span class="hljs-keyword">return</span> p;            <span class="hljs-keyword">return</span> parent[p] = find(parent[p]);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>{            <span class="hljs-keyword">int</span> rootp = find(p);            <span class="hljs-keyword">int</span> rootq = find(q);            <span class="hljs-keyword">if</span>(rootp == rootq)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            parent[rootp] = rootq;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        }    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findRedundantConnection(<span class="hljs-keyword">int</span>[][] edges) {        <span class="hljs-keyword">int</span> N = edges.length;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(N + <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] e : edges){            <span class="hljs-keyword">if</span>(!uf.union(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]};        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>};    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 63.64%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1135. Connecting Cities With Minimum Cost</title>
      <link href="2020/02/13/Leetcode-1135-Connecting-Cities-With-Minimum-Cost/"/>
      <url>2020/02/13/Leetcode-1135-Connecting-Cities-With-Minimum-Cost/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsconnecting-cities-with-minimum-cost"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsconnecting-cities-with-minimum-cost"></a> 题目链接https://leetcode.com/problems/connecting-cities-with-minimum-cost/</h2><h2 id="题目难度medium-562"><a class="markdownIt-Anchor" href="#题目难度medium-562"></a> 题目难度Medium 56.2%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>There are N cities numbered from 1 to N.</p><p>You are given connections, where each connections[i] = [city1, city2, cost] represents the cost to connect city1 and city2 together.  (A connection is bidirectional: connecting city1 and city2 is the same as connecting city2 and city1.)</p><p>Return the minimum cost so that for every pair of cities, there exists a path of connections (possibly of length 1) that connects those two cities together.  The cost is the sum of the connection costs used. If the task is impossible, return -1.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: N = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]Output: 6Explanation:Choosing any 2 edges will connect all cities so we choose the minimum 2.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>等做完union find了再来写。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>{        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> count, total_cost;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{            count = n - <span class="hljs-number">1</span>;            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];            total_cost = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++){                parent[i] = i;            }        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>{            <span class="hljs-keyword">if</span>(p == parent[p])                <span class="hljs-keyword">return</span> p;            <span class="hljs-keyword">return</span> parent[p] = find(parent[p]);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> cost)</span></span>{            <span class="hljs-keyword">int</span> rootp = find(p);            <span class="hljs-keyword">int</span> rootq = find(q);            <span class="hljs-keyword">if</span>(rootp != rootq){                parent[rootq] = rootp;                count--;                total_cost += cost;            }        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumCost</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[][] connections)</span> </span>{        Arrays.sort(connections, (n1, n2)-&gt;n1[<span class="hljs-number">2</span>] - n2[<span class="hljs-number">2</span>]); <span class="hljs-comment">//先sort，然后往里加就应该是最小的cost</span>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(N + <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] n : connections){            uf.union(n[<span class="hljs-number">0</span>], n[<span class="hljs-number">1</span>], n[<span class="hljs-number">2</span>]);        }        <span class="hljs-keyword">if</span>(uf.count &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> uf.total_cost;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 91.31%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1061. Lexicographically Smallest Equivalent String</title>
      <link href="2020/02/13/Leetcode-1061-Lexicographically-Smallest-Equivalent-String/"/>
      <url>2020/02/13/Leetcode-1061-Lexicographically-Smallest-Equivalent-String/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemslexicographically-smallest-equivalent-string"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemslexicographically-smallest-equivalent-string"></a> 题目链接https://leetcode.com/problems/lexicographically-smallest-equivalent-string/</h2><h2 id="题目难度medium-641"><a class="markdownIt-Anchor" href="#题目难度medium-641"></a> 题目难度Medium 64.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given strings A and B of the same length, we say A[i] and B[i] are equivalent characters. For example, if A = “abc” and B = “cde”, then we have ‘a’ == ‘c’, ‘b’ == ‘d’, ‘c’ == ‘e’.</p><p>Equivalent characters follow the usual rules of any equivalence relation:</p><p>Reflexivity: ‘a’ == ‘a’<br />Symmetry: ‘a’ == ‘b’ implies ‘b’ == ‘a’<br />Transitivity: ‘a’ == ‘b’ and ‘b’ == ‘c’ implies ‘a’ == ‘c’<br />For example, given the equivalency information from A and B above, S = “eed”, “acd”, and “aab” are equivalent strings, and “aab” is the lexicographically smallest equivalent string of S.</p><p>Return the lexicographically smallest equivalent string of S by using the equivalency information from A and B.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: A = &quot;parker&quot;, B = &quot;morris&quot;, S = &quot;parser&quot;Output: &quot;makkek&quot;Explanation: Based on the equivalency information in A and B, we can group their characters as [m,p], [a,o], [k,r,s], [e,i]. The characters in each group are equivalent and sorted in lexicographical order. So the answer is &quot;makkek&quot;.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>等做完union find了再来写。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>{        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)                parent[i] = i;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>{            <span class="hljs-keyword">if</span>(p == parent[p])                <span class="hljs-keyword">return</span> p;            <span class="hljs-keyword">return</span> parent[p] = find(parent[p]);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>{            <span class="hljs-keyword">int</span> rootp = find(p);            <span class="hljs-keyword">int</span> rootq = find(q);            <span class="hljs-keyword">int</span> min = Math.min(rootp, rootq); <span class="hljs-comment">// 一直选择最小的当root</span>            parent[rootp] = min;            parent[rootq] = min;        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">smallestEquivalentString</span><span class="hljs-params">(String A, String B, String S)</span> </span>{        <span class="hljs-keyword">int</span> n = A.length();        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(<span class="hljs-number">26</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){            uf.union(A.charAt(i) - <span class="hljs-string">'a'</span>, B.charAt(i) - <span class="hljs-string">'a'</span>);        }        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : S.toCharArray())            res.append((<span class="hljs-keyword">char</span>)(<span class="hljs-string">'a'</span> + uf.find(c - <span class="hljs-string">'a'</span>)));        <span class="hljs-keyword">return</span> res.toString();    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>959. Regions Cut By Slashes</title>
      <link href="2020/02/13/Leetcode-959-Regions-Cut-By-Slashes/"/>
      <url>2020/02/13/Leetcode-959-Regions-Cut-By-Slashes/</url>
      
        <content type="html"><![CDATA[<h4 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h4><p><a href="https://leetcode.com/problems/regions-cut-by-slashes/" target="_blank" rel="noopener">https://leetcode.com/problems/regions-cut-by-slashes/</a></p><h4 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h4><p>Medium 64.8%</p><a id="more"></a><h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4><p>In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, , or blank space.  These characters divide the square into contiguous regions.</p><p>(Note that backslash characters are escaped, so a \ is represented as “\”.)</p><p>Return the number of regions.</p><p>Example 1:</p><pre class="highlight"><code class="">Input:[  &quot; /&quot;,  &quot;/ &quot;]Output: 2</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>等做完union find了再来写。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>{        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> count;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{            count = n;            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i++)                parent[i] = i;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>{            <span class="hljs-keyword">if</span>(p == parent[p])                <span class="hljs-keyword">return</span> p;            <span class="hljs-keyword">return</span> parent[p] = find(parent[p]);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>{            <span class="hljs-keyword">int</span> rootp = find(p);            <span class="hljs-keyword">int</span> rootq = find(q);            <span class="hljs-keyword">if</span>(rootp != rootq){                parent[rootp] = rootq;                count--;            }        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">regionsBySlashes</span><span class="hljs-params">(String[] grid)</span> </span>{        <span class="hljs-keyword">int</span> N = grid.length;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(N * N * <span class="hljs-number">4</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++){                <span class="hljs-keyword">char</span> cur = grid[i].charAt(j);                <span class="hljs-keyword">int</span> root = (i * N + j) * <span class="hljs-number">4</span>;                <span class="hljs-keyword">if</span>(cur != <span class="hljs-string">'\\'</span>){                    uf.union(root + <span class="hljs-number">0</span>, root + <span class="hljs-number">1</span>);                    uf.union(root + <span class="hljs-number">2</span>, root + <span class="hljs-number">3</span>);                }                <span class="hljs-keyword">if</span>(cur != <span class="hljs-string">'/'</span>){                    uf.union(root + <span class="hljs-number">0</span>, root + <span class="hljs-number">3</span>);                    uf.union(root + <span class="hljs-number">1</span>, root + <span class="hljs-number">2</span>);                }                <span class="hljs-comment">//Union down</span>                <span class="hljs-keyword">if</span>(i &lt; N - <span class="hljs-number">1</span>)                    uf.union(root + <span class="hljs-number">2</span>, ((i + <span class="hljs-number">1</span>) * N + j) * <span class="hljs-number">4</span>);                <span class="hljs-comment">//Union right</span>                <span class="hljs-keyword">if</span>(j &lt; N - <span class="hljs-number">1</span>)                    uf.union(root + <span class="hljs-number">3</span>, (i * N + j + <span class="hljs-number">1</span>) * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>);            }        }        <span class="hljs-keyword">return</span> uf.count;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 95.88%<br />Memory: 25.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1101. The Earliest Moment When Everyone Become Friends</title>
      <link href="2020/02/13/Leetcode-1101-The-Earliest-Moment-When-Everyone-Become-Friends/"/>
      <url>2020/02/13/Leetcode-1101-The-Earliest-Moment-When-Everyone-Become-Friends/</url>
      
        <content type="html"><![CDATA[<h4 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h4><p><a href="https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/" target="_blank" rel="noopener">https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/</a></p><a id="more"></a><h4 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h4><p>Medium 64.9%</p><h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4><p>In a social group, there are N people, with unique integer ids from 0 to N-1.</p><p>We have a list of logs, where each logs[i] = [timestamp, id_A, id_B] contains a non-negative integer timestamp, and the ids of two different people.</p><p>Each log represents the time in which two different people became friends.  Friendship is symmetric: if A is friends with B, then B is friends with A.</p><p>Let’s say that person A is acquainted with person B if A is friends with B, or A is a friend of someone acquainted with B.</p><p>Return the earliest time for which every person became acquainted with every other person. Return -1 if there is no such earliest time.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], N = 6Output: 20190301Explanation:The first event occurs at timestamp = 20190101 and after 0 and 1 become friends we have the following friendship groups [0,1], [2], [3], [4], [5].The second event occurs at timestamp = 20190104 and after 3 and 4 become friends we have the following friendship groups [0,1], [2], [3,4], [5].The third event occurs at timestamp = 20190107 and after 2 and 3 become friends we have the following friendship groups [0,1], [2,3,4], [5].The fourth event occurs at timestamp = 20190211 and after 1 and 5 become friends we have the following friendship groups [0,1,5], [2,3,4].The fifth event occurs at timestamp = 20190224 and as 2 and 4 are already friend anything happens.The sixth event occurs at timestamp = 20190301 and after 0 and 3 become friends we have that all become friends.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>等做完union find了再来写。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span>{        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> count;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{            count = n;            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)                parent[i] = i;        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>{            <span class="hljs-keyword">if</span>(p == parent[p])                <span class="hljs-keyword">return</span> p;            <span class="hljs-keyword">return</span> parent[p] = find(parent[p]);        }        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>{            <span class="hljs-keyword">int</span> rootp = find(p);            <span class="hljs-keyword">int</span> rootq = find(q);            <span class="hljs-keyword">if</span>(rootp != rootq){                parent[rootp] = rootq;                count--;            }        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">earliestAcq</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] logs, <span class="hljs-keyword">int</span> N)</span> </span>{        Arrays.sort(logs, (l1, l2) -&gt; l1[<span class="hljs-number">0</span>] - l2[<span class="hljs-number">0</span>]);        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(N);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; logs.length; i++){            <span class="hljs-keyword">int</span> time = logs[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span>(uf.find(logs[i][<span class="hljs-number">1</span>]) != uf.find(logs[i][<span class="hljs-number">2</span>]))                uf.union(logs[i][<span class="hljs-number">1</span>], logs[i][<span class="hljs-number">2</span>]);            <span class="hljs-keyword">if</span>(uf.count == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> time;        }        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 98.01%<br />Memory: 50.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>109. Convert Sorted List to Binary Search Tree</title>
      <link href="2020/02/12/Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree/"/>
      <url>2020/02/12/Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Medium 44.7%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example 1:</p><pre class="highlight"><code class="">Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:      0     / \   -3   9   /   / -10  5</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>快慢指针找中点，再递归生成左右子树，这里要注意的是判断list是否只有一个元素，否则的话会是死循环。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> </span>{        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        ListNode fast = head, slow = head, pre = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>){            pre = slow;            slow = slow.next;            fast = fast.next.next;        }        <span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span>)            pre.next = <span class="hljs-keyword">null</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(slow.val);        <span class="hljs-keyword">if</span>(head == slow) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 判断是否是有一个元素</span>        root.left = sortedListToBST(head);        root.right = sortedListToBST(slow.next);        <span class="hljs-keyword">return</span> root;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 5.26%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1120. Maximum Average Subtree</title>
      <link href="2020/02/12/Leetcode-1120-Maximum-Average-Subtree/"/>
      <url>2020/02/12/Leetcode-1120-Maximum-Average-Subtree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsmaximum-average-subtree"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsmaximum-average-subtree"></a> 题目链接 <a href="https://leetcode.com/problems/maximum-average-subtree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-average-subtree/</a></h2><h2 id="题目难度-medium-619"><a class="markdownIt-Anchor" href="#题目难度-medium-619"></a> 题目难度 Medium 61.9%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given the root of a binary tree, find the maximum average value of any subtree of that tree.</p><p>(A subtree of a tree is any node of that tree plus all its descendants. The average value of a tree is the sum of its values, divided by the number of nodes.)</p><p>Example 1:</p><pre class="highlight"><code class="">Input: [5,6,1]Output: 6.00000Explanation:For the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4.For the node with value = 6 we have an average of 6 / 1 = 6.For the node with value = 1 we have an average of 1 / 1 = 1.So the answer is 6 which is the maximum.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>求子树最大的平均数。那么这道题又是分别对待root参与和不参与。先左右递归一下，再处理包含root的。这里有一个trick需要学习一下，本来一开始那道题看到需要求平均值，就想到每个node是需要两个值保存，一个sum，一个count，但是又不会写Pair的class，怎么办呢？学习到了用两个HashMap&lt;TreeNode, Integer&gt;来保存每个node的属性。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    Map&lt;TreeNode, Double&gt; sum_map = <span class="hljs-keyword">new</span> HashMap();    Map&lt;TreeNode, Integer&gt; count_map = <span class="hljs-keyword">new</span> HashMap();    <span class="hljs-keyword">double</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">maximumAverageSubtree</span><span class="hljs-params">(TreeNode root)</span> </span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">double</span> left = maximumAverageSubtree(root.left);        <span class="hljs-keyword">double</span> right = maximumAverageSubtree(root.right);        <span class="hljs-keyword">double</span> average = helper(root);        <span class="hljs-keyword">return</span> Math.max(Math.max(left, right), average);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root)</span></span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        helper(root.left);        helper(root.right);        <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>){            sum += sum_map.get(root.left);            count += count_map.get(root.left);        }        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>){            sum += sum_map.get(root.right);            count += count_map.get(root.right);        }        sum += root.val;        count++;        sum_map.put(root, sum);        count_map.put(root, count);        <span class="hljs-keyword">return</span> sum / count;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 5.01%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Postorder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>687. Longest Univalue Path</title>
      <link href="2020/02/12/Leetcode-687-Longest-Univalue-Path/"/>
      <url>2020/02/12/Leetcode-687-Longest-Univalue-Path/</url>
      
        <content type="html"><![CDATA[<h4 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h4><p><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-univalue-path/</a></p><h4 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h4><p>Easy 35.1%</p><a id="more"></a><h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4><p>Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.</p><p>The length of path between two nodes is represented by the number of edges between them.</p><p>Example 1:</p><pre class="highlight"><code class="">Input:              5             / \            4   5           / \   \          1   1   5Output: 2</code></pre><h4 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h4><p>返回最长的path长度，要求path所有node都有相同的值，这条path包不包括root都可以。这种包不包括root都可以的题，肯定要包括和不包括比较一下，不包括又分为两种，左边和右边，所以又需要比较一下。重点是实现包括root的code，我的实现是从root往两边走，然后把两边加起来。</p><h4 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h4><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode root)</span> </span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// not include root</span>        <span class="hljs-keyword">int</span> left = longestUnivaluePath(root.left);        <span class="hljs-keyword">int</span> right = longestUnivaluePath(root.right);        <span class="hljs-keyword">int</span> res = Math.max(left, right);        <span class="hljs-comment">// include root</span>        res = Math.max(res, helper(root.left, root.val) + helper(root.right, root.val));        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target)</span></span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || root.val != target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> Math.max(helper(root.left, target), helper(root.right, target)) + <span class="hljs-number">1</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 11.63%<br />Memory: 10.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>96. Unique Binary Search Trees</title>
      <link href="2020/02/12/Leetcode-96-Unique-Binary-Search-Trees/"/>
      <url>2020/02/12/Leetcode-96-Unique-Binary-Search-Trees/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-binary-search-trees/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Medium 38.4%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p><p>Example 1:</p><pre class="highlight"><code class="">Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST's:   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题的问题是，有多少种可能性？一般就会想到用dfs，但是结果dfs的时间复杂度很高。仔细想想，这个问题其实是存在子问题，如果用G(n)代表最终答案，也就是从1到n的所有BST的数量，F(i)表示i当root时所有BST的数量，那么G(n) = F(1) + F(2) + … + (n)。对于F(i)，既然是i当root，那么左边的就是左子树，右边的就是右子树，F(i) = G(i-1)*G(n-i)。所以G(n) = sum(i = 1…n, G(i-1)*G(n-i)).<br />所以整个程序先有一个for loop（i长度），再有一个for loop（j当root）去计算G(i)，直到计算G(n).</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++){                dp[i] += dp[j-<span class="hljs-number">1</span>] * dp[i-j];            }        }        <span class="hljs-keyword">return</span> dp[n];    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 5.55%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1261. Find Elements in a Contaminated Binary Tree</title>
      <link href="2020/02/12/Leetcode-1261-Find-Elements-in-a-Contaminated-Binary-Tree/"/>
      <url>2020/02/12/Leetcode-1261-Find-Elements-in-a-Contaminated-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsfind-elements-in-a-contaminated-binary-tree"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsfind-elements-in-a-contaminated-binary-tree"></a> 题目链接 <a href="https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/</a></h2><h2 id="题目难度-medium-726"><a class="markdownIt-Anchor" href="#题目难度-medium-726"></a> 题目难度 Medium 72.6%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a binary tree with the following rules:</p><ol><li>root.val == 0</li><li>If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1</li><li>If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2<br />Now the binary tree is contaminated, which means all treeNode.val have been changed to -1.</li></ol><p>You need to first recover the binary tree and then implement the FindElements class:</p><ul><li>FindElements(TreeNode* root) Initializes the object with a contamined binary tree, you need to recover it first.</li><li>bool find(int target) Return if the target value exists in the recovered binary tree.</li></ul><p>Example 1:</p><pre class="highlight"><code class="">Input[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;][[[-1,null,-1]],[1],[2]]Output[null,false,true]ExplanationFindElements findElements = new FindElements([-1,null,-1]);findElements.find(1); // return FalsefindElements.find(2); // return True</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目很简单，想到用set记录值再以O(1)查找target就行。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FindElements</span> </span>{    Set&lt;Integer&gt; set;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FindElements</span><span class="hljs-params">(TreeNode root)</span> </span>{        set = <span class="hljs-keyword">new</span> HashSet();        helper(root, <span class="hljs-number">0</span>);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span></span>{        root.val = val;        set.add(val);        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>) helper(root.left, val * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>) helper(root.right, val * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>{        <span class="hljs-keyword">return</span> set.contains(target);    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 35.37%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1325. Delete Leaves With a Given Value</title>
      <link href="2020/02/11/Leetcode-1325-Delete-Leaves-With-a-Given-Value/"/>
      <url>2020/02/11/Leetcode-1325-Delete-Leaves-With-a-Given-Value/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsdelete-leaves-with-a-given-value"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsdelete-leaves-with-a-given-value"></a> 题目链接 <a href="https://leetcode.com/problems/delete-leaves-with-a-given-value/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-leaves-with-a-given-value/</a></h2><h2 id="题目难度-medium-733"><a class="markdownIt-Anchor" href="#题目难度-medium-733"></a> 题目难度 Medium 73.3%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a binary tree root and an integer target, delete all the leaf nodes with value target.</p><p>Note that once you delete a leaf node with value target, if it’s parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you can’t).</p><p>Example 1:</p><pre class="highlight"><code class="">Input: root = [1,2,3,2,null,2,4], target = 2Output: [1,null,3,null,4]Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left).After removing, new nodes become leaf nodes with value (target = 2) (Picture in center).</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题和814一样都是postorder。两者的共同点是，先动左右子树，root的去留是根据左右子树的状态来决定。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">removeLeafNodes</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target)</span> </span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        root.left = removeLeafNodes(root.left, target);        root.right = removeLeafNodes(root.right, target);        <span class="hljs-keyword">if</span>(root.val == target &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> root;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Postorder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>814. Binary Tree Pruning</title>
      <link href="2020/02/11/Leetcode-814-Binary-Tree-Pruning/"/>
      <url>2020/02/11/Leetcode-814-Binary-Tree-Pruning/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsbinary-tree-pruning"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsbinary-tree-pruning"></a> 题目链接 <a href="https://leetcode.com/problems/binary-tree-pruning/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-pruning/</a></h2><h2 id="题目难度-medium-730"><a class="markdownIt-Anchor" href="#题目难度-medium-730"></a> 题目难度 Medium 73.0%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>We are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1.</p><p>Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.</p><p>(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)</p><p>Example 1:</p><pre class="highlight"><code class="">Example 1:Input: [1,null,0,0,1]Output: [1,null,0,null,1]Explanation:Only the red nodes satisfy the property &quot;every subtree not containing a 1&quot;.The diagram on the right represents the answer.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题是先处理左右子树再判断root。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode root)</span> </span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        root.left = pruneTree(root.left);        root.right = pruneTree(root.right);        <span class="hljs-keyword">if</span>(root.val == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> root;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 5.88%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Postorder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>366. Find Leaves of Binary Tree</title>
      <link href="2020/02/11/Leetcode-366-Find-Leaves-of-Binary-Tree/"/>
      <url>2020/02/11/Leetcode-366-Find-Leaves-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsfind-leaves-of-binary-tree"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsfind-leaves-of-binary-tree"></a> 题目链接https://leetcode.com/problems/find-leaves-of-binary-tree/</h2><h2 id="题目难度medium-69"><a class="markdownIt-Anchor" href="#题目难度medium-69"></a> 题目难度Medium 69%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: [1,2,3,4,5]          1         / \        2   3       / \      4   5Output: [[4,5,3],[2],[1]]</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题是要将叶子节点一层一层去掉直到root为空。一开始拿到这个题没有太多思路，想到的是dfs，但是不知道什么时候停止把out加入res。看了其他人的答案后，发现root是每完全去掉一次就更新的，所以需要一个while loop到root为空，所以helper的return就是root，input就是root和out，因为要把叶子节点存到out再删掉，然后更新了root之后就把out给res。recursive更新左右子树。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList();        <span class="hljs-keyword">while</span>(root != <span class="hljs-keyword">null</span>){            List&lt;Integer&gt; out = <span class="hljs-keyword">new</span> ArrayList();            root = helper(root, out);            res.add(<span class="hljs-keyword">new</span> ArrayList(out));        }        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; out)</span></span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) {            out.add(root.val);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        }        root.left = helper(root.left, out);        root.right = helper(root.right, out);        <span class="hljs-keyword">return</span> root;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 6.82%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>797. All Paths From Source to Target</title>
      <link href="2020/02/10/Leetcode-797-All-Paths-From-Source-to-Target/"/>
      <url>2020/02/10/Leetcode-797-All-Paths-From-Source-to-Target/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsall-paths-from-source-to-target"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsall-paths-from-source-to-target"></a> 题目链接 <a href="https://leetcode.com/problems/all-paths-from-source-to-target/" target="_blank" rel="noopener">https://leetcode.com/problems/all-paths-from-source-to-target/</a></h2><h2 id="题目难度-medium-731"><a class="markdownIt-Anchor" href="#题目难度-medium-731"></a> 题目难度 Medium 73.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, and return them in any order.</p><p>The graph is given as follows:  the nodes are 0, 1, …, graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: [[1,2], [3], [3], []]Output: [[0,1,3],[0,2,3]]Explanation: The graph looks like this:0---&gt;1|    |v    v2---&gt;3There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>就是一道很典型的dfs找出所有path的题。需要的是一个visited数组来记录哪些是走过了的避免重复走。然后就是遍历邻接节点之后要将out和visited复原。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">boolean</span>[] visited;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="hljs-keyword">int</span>[][] graph) {        <span class="hljs-keyword">int</span> n = graph.length;        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList();        List&lt;Integer&gt; out = <span class="hljs-keyword">new</span> ArrayList();        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];        out.add(<span class="hljs-number">0</span>);        visited[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        dfs(graph, <span class="hljs-number">0</span>, res, out);        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] g, <span class="hljs-keyword">int</span> start, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; out)</span></span>{        <span class="hljs-keyword">if</span>(start == g.length - <span class="hljs-number">1</span>){            res.add(<span class="hljs-keyword">new</span> ArrayList(out));            <span class="hljs-keyword">return</span>;        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : g[start]){            <span class="hljs-keyword">if</span>(!visited[n]){                visited[n] = <span class="hljs-keyword">true</span>;                out.add(n);                dfs(g, n, res, out);                visited[n] = <span class="hljs-keyword">false</span>;                out.remove(out.size() - <span class="hljs-number">1</span>);            }        }    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 99.51%<br />Memory: 25.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1198. Find Smallest Common Element in All Rows</title>
      <link href="2020/02/10/Leetcode-1198-Find-Smallest-Common-Element-in-All-Rows/"/>
      <url>2020/02/10/Leetcode-1198-Find-Smallest-Common-Element-in-All-Rows/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsfind-smallest-common-element-in-all-rows"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsfind-smallest-common-element-in-all-rows"></a> 题目链接https://leetcode.com/problems/find-smallest-common-element-in-all-rows/</h2><h2 id="题目难度medium-742"><a class="markdownIt-Anchor" href="#题目难度medium-742"></a> 题目难度Medium 74.2%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a matrix mat where every row is sorted in increasing order, return the smallest common element in all rows.</p><p>If there is no common element, return -1.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: mat = [[1,2,3,4,5],[2,4,5,8,10],[3,5,7,9,11],[1,3,5,7,9]]Output: 5</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>给定一个矩阵，每行都是sorted，找出最小的common value。从每一行的第一个数开始，纵向的最大是可能的答案，找到最大之后再在每个数组里找有没有这个数，如果有就是答案，如果没有就往后看一格。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">smallestCommonElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat)</span> </span>{        <span class="hljs-keyword">int</span> n = mat.length;        <span class="hljs-keyword">int</span> m = mat[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">int</span> max_ind = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(max_ind &lt; m){            <span class="hljs-keyword">int</span> max = get_max(mat, a);            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){                <span class="hljs-keyword">if</span>(mat[i][a[i]] &lt; max){                    flag = <span class="hljs-keyword">true</span>;                    max_ind = Math.max(max_ind, ++a[i]);                }            }            <span class="hljs-keyword">if</span>(flag == <span class="hljs-keyword">false</span>)                <span class="hljs-keyword">return</span> max;        }        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_max</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span>[] a)</span></span>{        <span class="hljs-keyword">int</span> res = mat[<span class="hljs-number">0</span>][a[<span class="hljs-number">0</span>]];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++)            res = Math.max(res, mat[i][a[i]]);        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 55.43%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1305. All Elements in Two Binary Search Trees</title>
      <link href="2020/02/10/Leetcode-1305-All-Elements-in-Two-Binary-Search-Trees/"/>
      <url>2020/02/10/Leetcode-1305-All-Elements-in-Two-Binary-Search-Trees/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsall-elements-in-two-binary-search-trees"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsall-elements-in-two-binary-search-trees"></a> 题目链接https://leetcode.com/problems/all-elements-in-two-binary-search-trees/</h2><h2 id="题目难度medium-746"><a class="markdownIt-Anchor" href="#题目难度medium-746"></a> 题目难度Medium 74.6%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given two binary search trees root1 and root2.</p><p>Return a list containing all the integers from both trees sorted in ascending order.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: root1 = [2,1,4], root2 = [1,0,3]Output: [0,1,1,2,3,4]</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>一开始看到两个树需要merge排好序，就开始想dfs，结果怎么想都不对。后来一想，就两个tree都inorder遍历一遍得到两个sorted array，再merge就行了。这里考察的点就是inorder和merge sorted array。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    List&lt;Integer&gt; list;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getAllElements</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>{        list = <span class="hljs-keyword">new</span> ArrayList();        inorder(root1);        List&lt;Integer&gt; l1 = <span class="hljs-keyword">new</span> ArrayList(list);        list = <span class="hljs-keyword">new</span> ArrayList();        inorder(root2);        List&lt;Integer&gt; l2 = <span class="hljs-keyword">new</span> ArrayList(list);        <span class="hljs-keyword">return</span> merge(l1, l2);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root)</span></span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        inorder(root.left);        list.add(root.val);        inorder(root.right);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">merge</span><span class="hljs-params">(List&lt;Integer&gt; l1, List&lt;Integer&gt; l2)</span></span>{        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i &lt; l1.size() &amp;&amp; j &lt; l2.size()){            <span class="hljs-keyword">if</span>(l1.get(i) &gt; l2.get(j))                res.add(l2.get(j++));            <span class="hljs-keyword">else</span>                res.add(l1.get(i++));        }        <span class="hljs-keyword">while</span>(i &lt; l1.size())            res.add(l1.get(i++));        <span class="hljs-keyword">while</span>(j &lt; l2.size())            res.add(l2.get(j++));        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 93.01%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1347. Minimum Number of Steps to Make Two Strings Anagram</title>
      <link href="2020/02/10/Leetcode-1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram/"/>
      <url>2020/02/10/Leetcode-1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsminimum-number-of-steps-to-make-two-strings-anagram"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsminimum-number-of-steps-to-make-two-strings-anagram"></a> 题目链接 <a href="https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/</a></h2><h2 id="题目难度-medium-769"><a class="markdownIt-Anchor" href="#题目难度-medium-769"></a> 题目难度 Medium 76.9%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given two equal-size strings s and t. In one step you can choose any character of t and replace it with another character.</p><p>Return the minimum number of steps to make t an anagram of s.</p><p>An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: s = &quot;bab&quot;, t = &quot;aba&quot;Output: 1Explanation: Replace the first 'a' in t with b, t = &quot;bba&quot; which is anagram of s.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>看到string只有lowercase就知道是用int[26]来count再比较。比较的时候一开始把所有的差值都加上了，其实不对。以上面的例子，如果把所有差值加起来，那就是2，但结果是1.这是因为当s的某个值比t少时，就可以把另外的多余变成这个值，这样就减少2，但变化却是1.所以就只需要统计当s少于t的时候了。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(String s, String t)</span> </span>{        <span class="hljs-keyword">int</span>[] scount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">int</span>[] tcount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray())            scount[c - <span class="hljs-string">'a'</span>]++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : t.toCharArray())            tcount[c - <span class="hljs-string">'a'</span>]++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++){            sum += tcount[i] &gt; scount[i] ? <span class="hljs-number">0</span> : Math.abs(scount[i] - tcount[i]);        }        <span class="hljs-keyword">return</span> sum;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 92.02%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>654. Maximum Binary Tree</title>
      <link href="2020/02/10/Leetcode-654-Maximum-Binary-Tree/"/>
      <url>2020/02/10/Leetcode-654-Maximum-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsmaximum-binary-tree"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsmaximum-binary-tree"></a> 题目链接https://leetcode.com/problems/maximum-binary-tree/</h2><h2 id="题目难度medium-782"><a class="markdownIt-Anchor" href="#题目难度medium-782"></a> 题目难度Medium 78.2%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:</p><ol><li>The root is the maximum number in the array.</li><li>The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.</li><li>The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.<br />Construct the maximum tree by the given array and output the root node of this tree.</li></ol><p>Example 1:</p><pre class="highlight"><code class="">Input: [3,2,1,6,0,5]Output: return the tree root node representing the following tree:      6    /   \   3     5    \    /     2  0       \        1</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>最大的数作为root，左边的形成左子树，右边的形成右子树。时间复杂度是O(n2)。因为找最大值是O(n),再形成是O(n)。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{        <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>{        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> max = nums[left];        <span class="hljs-keyword">int</span> max_ind = left;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++){            <span class="hljs-keyword">if</span>(nums[i] &gt; max){                max = nums[i];                max_ind = i;            }        }        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[max_ind]);        root.left = helper(nums, left, max_ind - <span class="hljs-number">1</span>);        root.right = helper(nums, max_ind + <span class="hljs-number">1</span>, right);        <span class="hljs-keyword">return</span> root;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 37.50%<br />Memory: 6.52%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1038. Binary Search Tree to Greater Sum Tree</title>
      <link href="2020/02/10/Leetcode-1038-Binary-Search-Tree-to-Greater-Sum-Tree/"/>
      <url>2020/02/10/Leetcode-1038-Binary-Search-Tree-to-Greater-Sum-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsbinary-search-tree-to-greater-sum-tree"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsbinary-search-tree-to-greater-sum-tree"></a> 题目链接 <a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/</a></h2><h2 id="题目难度-medium-790"><a class="markdownIt-Anchor" href="#题目难度-medium-790"></a> 题目难度 Medium 79.0%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val.</p><p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>Example 1:</p><pre class="highlight"><code class="">Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>还记得之前拿到这道题还得使劲分析一下，知道大概怎么做但是写code还有点犹豫。但这次竟然就很通畅，一次bug free，还是挺开心的。这种一看就是dfs加上累计信息的，就是要有一个global variable去记录和更新。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">bstToGst</span><span class="hljs-params">(TreeNode root)</span> </span>{        dfs(root);        <span class="hljs-keyword">return</span> root;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        dfs(root.right);        root.val += sum;        sum = root.val;        dfs(root.left);    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1282. Group the People Given the Group Size They Belong To</title>
      <link href="2020/02/10/Leetcode-1282-Group-the-People-Given-the-Group-Size-They-Belong-To/"/>
      <url>2020/02/10/Leetcode-1282-Group-the-People-Given-the-Group-Size-They-Belong-To/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemsgroup-the-people-given-the-group-size-they-belong-to"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemsgroup-the-people-given-the-group-size-they-belong-to"></a> 题目链接https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/</h2><h2 id="题目难度medium-835"><a class="markdownIt-Anchor" href="#题目难度medium-835"></a> 题目难度Medium 83.5%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>There are n people whose IDs go from 0 to n - 1 and each person belongs exactly to one group. Given the array groupSizes of length n telling the group size each person belongs to, return the groups there are and the people’s IDs each group includes.</p><p>You can return any solution in any order and the same applies for IDs. Also, it is guaranteed that there exists at least one solution.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: groupSizes = [3,3,3,3,3,1,3]Output: [[5],[0,1,2],[3,4,6]]Explanation:Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目的输入是一个数组，里面的值代表这个坐标所属group的size。需要返回每个组的成员。所以这里用hashmap&lt;Integer, List&gt;来储存size和成员。然后再对于每一个size都去组成组，多的就新建组。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; groupThePeople(<span class="hljs-keyword">int</span>[] g) {        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g.length; i++){            List&lt;Integer&gt; a;            <span class="hljs-keyword">if</span>(map.containsKey(g[i]))                a = map.get(g[i]);            <span class="hljs-keyword">else</span>                a = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();            a.add(i);            map.put(g[i], a);        }        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : map.keySet()){            List&lt;Integer&gt; a = map.get(n);            <span class="hljs-keyword">if</span>(a.size() == n)                res.add(a);            <span class="hljs-keyword">else</span>{                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size() / n; i++){                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)                        list.add(a.get(i * n + j));                    res.add(list);                }            }        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 51.13%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1315. Sum of Nodes with Even-Valued Grandparent</title>
      <link href="2020/02/10/Leetcode-1315-Sum-of-Nodes-with-Even-Valued-Grandparent/"/>
      <url>2020/02/10/Leetcode-1315-Sum-of-Nodes-with-Even-Valued-Grandparent/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemssum-of-nodes-with-even-valued-grandparent"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemssum-of-nodes-with-even-valued-grandparent"></a> 题目链接 <a href="https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/</a></h2><h2 id="题目难度-837"><a class="markdownIt-Anchor" href="#题目难度-837"></a> 题目难度 83.7%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a binary tree, return the sum of values of nodes with even-valued grandparent.  (A grandparent of a node is the parent of its parent, if it exists.)</p><p>If there are no nodes with an even-valued grandparent, return 0.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]Output: 18Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目的输入是一个二叉树。要求sum这些node，如果node的grandparent是偶数值。很容易想到是dfs，sum作为全局变量，dfs的input是当前node和parent是否为偶数。然后判断左右子树是否应该加入sum。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumEvenGrandparent</span><span class="hljs-params">(TreeNode root)</span> </span>{        dfs(root, <span class="hljs-keyword">false</span>);        <span class="hljs-keyword">return</span> sum;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">boolean</span> peven)</span></span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span> &amp;&amp; peven) sum += root.left.val;        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span> &amp;&amp; peven) sum += root.right.val;        dfs(root.left, root.val % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);        dfs(root.right, root.val % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 99.75%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1265. Print Immutable Linked List in Reverse</title>
      <link href="2020/02/10/Leetcode-1265-Print-Immutable-Linked-List-in-Reverse/"/>
      <url>2020/02/10/Leetcode-1265-Print-Immutable-Linked-List-in-Reverse/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsprint-immutable-linked-list-in-reverse"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsprint-immutable-linked-list-in-reverse"></a> 题目链接 <a href="https://leetcode.com/problems/print-immutable-linked-list-in-reverse/" target="_blank" rel="noopener">https://leetcode.com/problems/print-immutable-linked-list-in-reverse/</a></h2><h2 id="题目难度-medium-925"><a class="markdownIt-Anchor" href="#题目难度-medium-925"></a> 题目难度 Medium 92.5%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>You are given an immutable linked list, print out all values of each node in reverse with the help of the following interface:</p><p>ImmutableListNode: An interface of immutable linked list, you are given the head of the list.<br />You need to use the following functions to access the linked list (you can’t access the ImmutableListNode directly):</p><p>ImmutableListNode.printValue(): Print value of the current node.<br />ImmutableListNode.getNext(): Return the next node.<br />The input is only given to initialize the linked list internally. You must solve this problem without modifying the linked list. In other words, you must operate the linked list using only the mentioned APIs.</p><p>Follow up:</p><p>Could you solve this problem in:</p><p>Constant space complexity?<br />Linear time complexity and less than linear space complexity?</p><p>Example 1:</p><pre class="highlight"><code class="">Input: head = [1,2,3,4]Output: [4,3,2,1]</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题接受率92.5%…为什么是道medium呢？</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-comment">/** * // This is the ImmutableListNode's API interface. * // You should not implement it, or speculate about its implementation. * interface ImmutableListNode { *     public void printValue(); // print the value of this node. *     public ImmutableListNode getNext(); // return the next node. * }; */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLinkedListInReverse</span><span class="hljs-params">(ImmutableListNode head)</span> </span>{        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(head.getNext() == <span class="hljs-keyword">null</span>)            head.printValue();        <span class="hljs-keyword">else</span>{            printLinkedListInReverse(head.getNext());            head.printValue();        }    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 88.73%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1302. Deepest Leaves Sum</title>
      <link href="2020/02/09/Leetcode-1302-Deepest-Leaves-Sum/"/>
      <url>2020/02/09/Leetcode-1302-Deepest-Leaves-Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsdeepest-leaves-sum"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsdeepest-leaves-sum"></a> 题目链接 <a href="https://leetcode.com/problems/deepest-leaves-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/deepest-leaves-sum/</a></h2><h2 id="题目难度-medium-837"><a class="markdownIt-Anchor" href="#题目难度-medium-837"></a> 题目难度 Medium 83.7%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a binary tree, return the sum of values of its deepest leaves.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]Output: 15</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目要求返回最深的根的和。这里有两点，深度和和。采用的是dfs，遇到leave随时更新最深的深度和结果和。这种需要在dfs时随时更新的variable就需要是static的全局变量。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">int</span> max_depth = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deepestLeavesSum</span><span class="hljs-params">(TreeNode root)</span> </span>{        dfs(root, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> sum;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> depth)</span></span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) {            <span class="hljs-keyword">if</span>(depth == max_depth)                sum += root.val;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(depth &gt; max_depth){                max_depth = depth;                sum = root.val;            }        } <span class="hljs-keyword">else</span> {            dfs(root.left, depth + <span class="hljs-number">1</span>);            dfs(root.right, depth + <span class="hljs-number">1</span>);        }    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="2020/02/09/Leetcode-160-Intersection-of-Two-Linked-Lists/"/>
      <url>2020/02/09/Leetcode-160-Intersection-of-Two-Linked-Lists/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-linked-lists/</a></p><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Easy 37.6%</p><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3Output: Reference of the node with value = 8Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>返回两个list重合的地方，这个题要不是之前看到过好几次要我一下子想出来也挺难的。就是用两个指针交换scan，直到指到相同的node就是答案，或者两个的next都是空，说明没有这样的node存在，就返回null。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>{        <span class="hljs-keyword">if</span>(headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        ListNode n1 = headA;        ListNode n2 = headB;        <span class="hljs-keyword">while</span>(n1 != n2){            <span class="hljs-keyword">if</span>(n1.next == <span class="hljs-keyword">null</span> &amp;&amp; n2.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            n1 = n1.next == <span class="hljs-keyword">null</span> ? headB : n1.next;            n2 = n2.next == <span class="hljs-keyword">null</span> ? headA : n2.next;        }        <span class="hljs-keyword">return</span> n1;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 98.72%<br />Memory: 5.71%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>624. Maximum Distance in Arrays</title>
      <link href="2020/02/09/Leetcode-624-Maximum-Distance-in-Arrays/"/>
      <url>2020/02/09/Leetcode-624-Maximum-Distance-in-Arrays/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsmaximum-distance-in-arrays"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsmaximum-distance-in-arrays"></a> 题目链接 <a href="https://leetcode.com/problems/maximum-distance-in-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-distance-in-arrays/</a></h2><h2 id="题目难度-easy-384"><a class="markdownIt-Anchor" href="#题目难度-easy-384"></a> 题目难度 Easy 38.4%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given m arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a-b|. Your task is to find the maximum distance.</p><p>Example 1:</p><pre class="highlight"><code class="">Input:[[1,2,3], [4,5], [1,2,3]]Output: 4Explanation:One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目给定一系列的sorted array，distance定义为来自两个不同array的元素最大的差的绝对值。一开始拿到这道题，竟然无从下手。看了答案之后，才知道其实就是按照逻辑想就行，既然是sorted array，与最大差值有关，就只需要每个array考虑开头和结尾，每轮到一个array，就更新results和最小值和最大值，这样就避免了同一个array的两个值组成结果。这里应该就是这道题的难点，不能从同一个array中取两个数。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; arrays)</span> </span>{        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, min_val = arrays.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>), max_val = arrays.get(<span class="hljs-number">0</span>).get(arrays.get(<span class="hljs-number">0</span>).size() - <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arrays.size(); i++){            res = Math.max(res, Math.max(Math.abs(arrays.get(i).get(<span class="hljs-number">0</span>) - max_val),                  Math.abs(arrays.get(i).get(arrays.get(i).size() - <span class="hljs-number">1</span>) - min_val)));            min_val = Math.min(min_val, arrays.get(i).get(<span class="hljs-number">0</span>));            max_val = Math.max(max_val, arrays.get(i).get(arrays.get(i).size() - <span class="hljs-number">1</span>));        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 72.08%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>205. Isomorphic Strings</title>
      <link href="2020/02/09/Leetcode-205-Isomorphic-Strings/"/>
      <url>2020/02/09/Leetcode-205-Isomorphic-Strings/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/isomorphic-strings/" target="_blank" rel="noopener">https://leetcode.com/problems/isomorphic-strings/</a></p><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>38.9%</p><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given two strings s and t, determine if they are isomorphic.</p><p>Two strings are isomorphic if the characters in s can be replaced to get t.</p><p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: s = &quot;paper&quot;, t = &quot;title&quot;Output: true</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>读完题目知道是用hashmap建立一个映射，然后遍历所有位置，如果映射包含了s到t的这两个字符映射，就继续，如果没有包含s的字符却包含了t的字符，说明t的字符已经被映射了，返回false，如果包含了s的字符，映射却不是t的字符，也返回false。这里难点在于这句话“No two characters may map to the same character”</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> </span>{        Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++){            <span class="hljs-keyword">char</span> a = s.charAt(i);            <span class="hljs-keyword">char</span> b = t.charAt(i);            <span class="hljs-keyword">if</span>(map.containsKey(a)){                <span class="hljs-keyword">if</span>(map.get(a) != b)                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            } <span class="hljs-keyword">else</span> {                <span class="hljs-keyword">if</span>(map.containsValue(b))                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                map.put(a, b);            }        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 75.46%<br />Memory: 45.61%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. Min Stack</title>
      <link href="2020/02/09/Leetcode-155-Min-Stack/"/>
      <url>2020/02/09/Leetcode-155-Min-Stack/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">https://leetcode.com/problems/min-stack/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Easy 40.7%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p>Example 1:</p><pre class="highlight"><code class="">MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; Returns -3.minStack.pop();minStack.top();      --&gt; Returns 0.minStack.getMin();   --&gt; Returns -2.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>只有getMin这个功能需要实现。很容易想到的就是用另一个stack给导出来，同时找到min。或者一开始就用list来储存，找min的时候遍历一遍list，就可以省下一个stack的空间，但是时间上没有优势。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>{    List&lt;Integer&gt; s;    <span class="hljs-keyword">int</span> size;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>{        s = <span class="hljs-keyword">new</span> ArrayList();        size = <span class="hljs-number">0</span>;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{        s.add(x);        size += <span class="hljs-number">1</span>;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{        s.remove(size - <span class="hljs-number">1</span>);        size -= <span class="hljs-number">1</span>;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> s.get(size - <span class="hljs-number">1</span>);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)            min = Math.min(min, s.get(i));        <span class="hljs-keyword">return</span> min;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 5.06%<br />Memory: 18.84%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>342. Power of Four</title>
      <link href="2020/02/09/Leetcode-342-Power-of-Four/"/>
      <url>2020/02/09/Leetcode-342-Power-of-Four/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemspower-of-four"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemspower-of-four"></a> 题目链接 <a href="https://leetcode.com/problems/power-of-four/" target="_blank" rel="noopener">https://leetcode.com/problems/power-of-four/</a></h2><h2 id="题目难度-easy-411"><a class="markdownIt-Anchor" href="#题目难度-easy-411"></a> 题目难度 Easy 41.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: 16Output: true</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目要看是否是4的倍数，还不准用loop和recursion。那么就是看bit了。这里要记住两个小trick：</p><ul><li>是否是2的次方 <code>(n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0)</code></li><li>是否是4的次方 <code>(n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0) &amp;&amp; (n % 3 == 1)</code></li></ul><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{        <span class="hljs-keyword">return</span> (num &gt; <span class="hljs-number">0</span>) &amp;&amp; ((num &amp; (num - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) &amp;&amp; (num % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>);    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 6.67%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Bit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>734. Sentence Similarity</title>
      <link href="2020/02/09/Leetcode-734-Sentence-Similarity/"/>
      <url>2020/02/09/Leetcode-734-Sentence-Similarity/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemssentence-similarity"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemssentence-similarity"></a> 题目链接 <a href="https://leetcode.com/problems/sentence-similarity/" target="_blank" rel="noopener">https://leetcode.com/problems/sentence-similarity/</a></h2><h2 id="题目难度-easy-416"><a class="markdownIt-Anchor" href="#题目难度-easy-416"></a> 题目难度 Easy 41.6%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.</p><p>For example, “great acting skills” and “fine drama talent” are similar, if the similar word pairs are pairs = [[“great”, “fine”], [“acting”,“drama”], [“skills”,“talent”]].</p><p>Note that the similarity relation is not transitive. For example, if “great” and “fine” are similar, and “fine” and “good” are similar, “great” and “good” are not necessarily similar.</p><p>However, similarity is symmetric. For example, “great” and “fine” being similar is the same as “fine” and “great” being similar.</p><p>Also, a word is always similar with itself. For example, the sentences words1 = [“great”], words2 = [“great”], pairs = [] are similar, even though there are no specified similar word pairs.</p><p>Finally, sentences can only be similar if they have the same number of words. So a sentence like words1 = [“great”] can never be similar to words2 = [“doubleplus”,“good”].</p><p>Note:</p><ul><li>The length of words1 and words2 will not exceed 1000.</li><li>The length of pairs will not exceed 2000.</li><li>The length of each pairs[i] will be 2.</li><li>The length of each words[i] and pairs[i][j] will be in the range [1, 20].</li></ul><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这个题目没有将太清楚，看了答案才知道是只需要比较相对的位置的word是否similar。不过看完题大概就知道是用hashset或者hashmap储存pair，再去比较两个sentence。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areSentencesSimilar</span><span class="hljs-params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>{        <span class="hljs-keyword">if</span>(words1.length != words2.length)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet();        <span class="hljs-keyword">for</span>(List&lt;String&gt; list : pairs)            set.add(list.get(<span class="hljs-number">0</span>) + <span class="hljs-string">"_"</span> + list.get(<span class="hljs-number">1</span>));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words1.length; i++){            <span class="hljs-keyword">if</span>(!words1[i].equals(words2[i]) &amp;&amp;                !set.contains(words1[i] + <span class="hljs-string">"_"</span> + words2[i]) &amp;&amp;                !set.contains(words2[i] + <span class="hljs-string">"_"</span> + words1[i]))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 9.73%<br />Memory: 25.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>643. Maximum Average Subarray I</title>
      <link href="2020/02/08/Leetcode-643-Maximum-Average-Subarray-I/"/>
      <url>2020/02/08/Leetcode-643-Maximum-Average-Subarray-I/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsmaximum-average-subarray-i"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsmaximum-average-subarray-i"></a> 题目链接 <a href="https://leetcode.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-average-subarray-i/</a></h2><h2 id="题目难度-easy-408"><a class="markdownIt-Anchor" href="#题目难度-easy-408"></a> 题目难度 Easy 40.8%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目要求找出长度为k同时平均值最大的子串，返回这个平均值。那就是维持一个k长度的sliding window去计算平均值，并且随时更新result。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMaxAverage</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>{        <span class="hljs-keyword">double</span> start = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)            start += nums[i];        <span class="hljs-keyword">double</span> res = start;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++){            start += nums[i] - nums[i - k];            res = Math.max(res, start);        }        <span class="hljs-keyword">return</span> res / k;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 91.37%<br />Memory: 53.85%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>716. Max Stack</title>
      <link href="2020/02/08/Leetcode-716-Max-Stack/"/>
      <url>2020/02/08/Leetcode-716-Max-Stack/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接-httpsleetcodecomproblemsmax-stack"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsmax-stack"></a> 题目链接 <a href="https://leetcode.com/problems/max-stack/" target="_blank" rel="noopener">https://leetcode.com/problems/max-stack/</a></h1><h1 id="题目难度-420"><a class="markdownIt-Anchor" href="#题目难度-420"></a> 题目难度 42.0%</h1><a id="more"></a><h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>Design a max stack that supports push, pop, top, peekMax and popMax.</p><ol><li>push(x) – Push element x onto stack.</li><li>pop() – Remove the element on top of the stack and return it.</li><li>top() – Get the element on the top.</li><li>peekMax() – Retrieve the maximum element in the stack.</li><li>popMax() – Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.</li></ol><p>Example 1:</p><pre class="highlight"><code class="">MaxStack stack = new MaxStack();stack.push(5);stack.push(1);stack.push(5);stack.top(); -&gt; 5stack.popMax(); -&gt; 5stack.top(); -&gt; 1stack.peekMax(); -&gt; 5stack.pop(); -&gt; 1stack.top(); -&gt; 5</code></pre><h1 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h1><p>在导出导入的过程中，要用相同的structure，stack for stack， queue for queue。</p><h1 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h1><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxStack</span> </span>{    Stack&lt;Integer&gt; stack;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxStack</span><span class="hljs-params">()</span> </span>{        stack = <span class="hljs-keyword">new</span> Stack();    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{        stack.push(x);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> stack.pop();    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> stack.peek();    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peekMax</span><span class="hljs-params">()</span> </span>{        Stack&lt;Integer&gt; aux = <span class="hljs-keyword">new</span> Stack();        <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;        <span class="hljs-keyword">while</span>(!stack.isEmpty()){            <span class="hljs-keyword">int</span> cur = stack.pop();            max = Math.max(max, cur);            aux.push(cur);        }        <span class="hljs-keyword">while</span>(!aux.isEmpty()){            stack.push(aux.pop());        }        <span class="hljs-keyword">return</span> max;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">popMax</span><span class="hljs-params">()</span> </span>{        Stack&lt;Integer&gt; aux = <span class="hljs-keyword">new</span> Stack();        <span class="hljs-keyword">int</span> max = peekMax();        <span class="hljs-keyword">while</span>(!stack.isEmpty()){            <span class="hljs-keyword">if</span>(stack.peek() != max)                aux.push(stack.pop());            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">break</span>;        }        stack.pop();        <span class="hljs-keyword">while</span>(!aux.isEmpty()){            stack.push(aux.pop());        }        <span class="hljs-keyword">return</span> max;    }}</code></pre><h1 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h1><p>Runtime: 5.05%<br />Memory: 91.67%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>225. Implement Stack using Queues</title>
      <link href="2020/02/08/Leetcode-225-Implement-Stack-using-Queues/"/>
      <url>2020/02/08/Leetcode-225-Implement-Stack-using-Queues/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsimplement-stack-using-queues"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsimplement-stack-using-queues"></a> 题目链接 <a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-stack-using-queues/</a></h2><h2 id="题目难度-easy-426"><a class="markdownIt-Anchor" href="#题目难度-easy-426"></a> 题目难度 Easy 42.6%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>empty() – Return whether the stack is empty.</li></ul><p>Example 1:</p><pre class="highlight"><code class="">MyStack stack = new MyStack();stack.push(1);stack.push(2);stack.top();   // returns 2stack.pop();   // returns 2stack.empty(); // returns false</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>值得注意的地方是在导出来的时候不能用q.size()-1，因为在导的过程中q的size是在变化的。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>{    Queue&lt;Integer&gt; q;    <span class="hljs-comment">/** Initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>{        q = <span class="hljs-keyword">new</span> LinkedList();    }    <span class="hljs-comment">/** Push element x onto stack. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{        q.offer(x);    }    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{        Queue&lt;Integer&gt; aux = <span class="hljs-keyword">new</span> LinkedList();        <span class="hljs-keyword">int</span> size = q.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; i++)            aux.offer(q.poll());        <span class="hljs-keyword">int</span> res = q.poll();        <span class="hljs-keyword">while</span>(!aux.isEmpty())            q.offer(aux.poll());        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-comment">/** Get the top element. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{        Queue&lt;Integer&gt; aux = <span class="hljs-keyword">new</span> LinkedList();        <span class="hljs-keyword">int</span> size = q.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; i++){            aux.offer(q.poll());        }        <span class="hljs-keyword">int</span> res = q.poll();        aux.offer(res);        q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(aux);        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-comment">/** Returns whether the stack is empty. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> q.size() == <span class="hljs-number">0</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 6.67%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>231. Power of Two</title>
      <link href="2020/02/08/Leetcode-231-Power-of-Two/"/>
      <url>2020/02/08/Leetcode-231-Power-of-Two/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemspower-of-two"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemspower-of-two"></a> 题目链接 <a href="https://leetcode.com/problems/power-of-two/" target="_blank" rel="noopener">https://leetcode.com/problems/power-of-two/</a></h2><h2 id="题目难度-easy-428"><a class="markdownIt-Anchor" href="#题目难度-easy-428"></a> 题目难度 Easy 42.8%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given an integer, write a function to determine if it is a power of two.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: 1Output: trueExplanation: 20 = 1</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: 218Output: false</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>判断一个数是否是2的次方，这里唯一要注意的是要把负数考虑一下。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">1</span>){            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            n = n / <span class="hljs-number">2</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 7.32%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>671. Second Minimum Node In a Binary Tree</title>
      <link href="2020/02/08/Leetcode-671-Second-Minimum-Node-In-a-Binary-Tree/"/>
      <url>2020/02/08/Leetcode-671-Second-Minimum-Node-In-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemssecond-minimum-node-in-a-binary-tree"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemssecond-minimum-node-in-a-binary-tree"></a> 题目链接 <a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/</a></h2><h2 id="题目难度-easy-430"><a class="markdownIt-Anchor" href="#题目难度-easy-430"></a> 题目难度 Easy 43.0%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.<br />Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree.<br />If no such second minimum value exists, output -1 instead.</p><p>Example 1:</p><pre class="highlight"><code class="">Input:    2   / \  2   5     / \    5   7Output: 5Explanation: The smallest value is 2, the second smallest value is 5.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这个题目想要一次通过还是有难度的。因为细节很多，比如当左右子树的根相等时就要递归两边再取最小的那个，但是如果有-1出现，也就是有一边是没有答案的，这时候返回最小的就不对了，需要讨论左右两边是否为-1再进行比较。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode root)</span> </span>{        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> left = findSecondMinimumValue(root.left);        <span class="hljs-keyword">int</span> right = findSecondMinimumValue(root.right);        <span class="hljs-keyword">if</span>(root.left.val == root.right.val){            <span class="hljs-keyword">if</span>(left != -<span class="hljs-number">1</span> &amp;&amp; right != -<span class="hljs-number">1</span>)                <span class="hljs-keyword">return</span> Math.min(left, right);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>)                <span class="hljs-keyword">return</span> right;            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> left;        }        <span class="hljs-keyword">if</span>(root.left.val == root.val)            <span class="hljs-keyword">return</span> left == -<span class="hljs-number">1</span> ? root.right.val : Math.min(left, root.right.val);        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> right == -<span class="hljs-number">1</span> ? root.left.val : Math.min(right, root.left.val);    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 5.25%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1010. Pairs of Songs With Total Durations Divisible by 60</title>
      <link href="2020/02/08/Leetcode-1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60/"/>
      <url>2020/02/08/Leetcode-1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemspairs-of-songs-with-total-durations-divisible-by-60"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemspairs-of-songs-with-total-durations-divisible-by-60"></a> 题目链接 <a href="https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/" target="_blank" rel="noopener">https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/</a></h2><h2 id="题目难度-easy-469"><a class="markdownIt-Anchor" href="#题目难度-easy-469"></a> 题目难度 Easy 46.9%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>In a list of songs, the i-th song has a duration of time[i] seconds.<br />Return the number of pairs of songs for which their total duration in seconds is divisible by 60.  Formally, we want the number of indices i &lt; j with (time[i] + time[j]) % 60 == 0.<br />Example 1:</p><pre class="highlight"><code class="">Input: [30,20,150,100,40]Output: 3Explanation: Three pairs have a total duration divisible by 60:(time[0] = 30, time[2] = 150): total duration 180(time[1] = 20, time[3] = 100): total duration 120(time[1] = 20, time[4] = 40): total duration 60</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目给一个数组表示每一首歌的时长，要求返回有多少个pair歌时长加起来是60的倍数。这个题目和two sum很像，都是找满足条件的pair。所以这里可以用hashmap记录每个数出现的次数，当满足后面某个数的时候将次数加在结果中就行。这里需要特殊处理的是60，因为如果用60-n%60来看需要多少，那结果就是60，但储存的时候是储存n%60是0，这样就找不到了，所以需要把为60的转化成需要0.</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numPairsDivisibleBy60</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] time)</span> </span>{        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; time.length; i++){            <span class="hljs-keyword">int</span> need = (<span class="hljs-number">60</span> -(time[i] % <span class="hljs-number">60</span>)) % <span class="hljs-number">60</span>;            <span class="hljs-keyword">if</span>(map.containsKey(need))                res += map.get(need);            map.put(time[i] % <span class="hljs-number">60</span>, map.getOrDefault(time[i] % <span class="hljs-number">60</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 34.23%<br />Memory: 7.14%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>989. Add to Array-Form of Integer</title>
      <link href="2020/02/07/Leetcode-989-Add-to-Array-Form-of-Integer/"/>
      <url>2020/02/07/Leetcode-989-Add-to-Array-Form-of-Integer/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsadd-to-array-form-of-integer"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsadd-to-array-form-of-integer"></a> 题目链接 <a href="https://leetcode.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/add-to-array-form-of-integer/</a></h2><h2 id="题目难度-easy-441"><a class="markdownIt-Anchor" href="#题目难度-easy-441"></a> 题目难度 Easy 44.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1].<br />Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: A = [2,1,5], K = 806Output: [1,0,2,1]Explanation: 215 + 806 = 1021</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目给一个数组代表一个整数，在给一个整数，求这两个整数的和。这道题考的比较细，要同时考虑到carry，A，K不为0才会退出。重点是list的reverse。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">addToArrayForm</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>{        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList();        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> i = A.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || (carry &gt; <span class="hljs-number">0</span> || K &gt; <span class="hljs-number">0</span>)){            <span class="hljs-keyword">int</span> cur = (i &gt;= <span class="hljs-number">0</span> ? A[i] : <span class="hljs-number">0</span>) + K % <span class="hljs-number">10</span> + carry;            res.add(cur % <span class="hljs-number">10</span>);            carry = cur / <span class="hljs-number">10</span>;            K = K / <span class="hljs-number">10</span>;            i--;        }        Collections.reverse(res); <span class="hljs-comment">// 重点！！！</span>        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 90.07%<br />Memory: 19.05%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>819. Most Common Word</title>
      <link href="2020/02/07/Leetcode-819-Most-Common-Word/"/>
      <url>2020/02/07/Leetcode-819-Most-Common-Word/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsmost-common-word"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsmost-common-word"></a> 题目链接 <a href="https://leetcode.com/problems/most-common-word/" target="_blank" rel="noopener">https://leetcode.com/problems/most-common-word/</a></h2><h2 id="题目难度-easy-437"><a class="markdownIt-Anchor" href="#题目难度-easy-437"></a> 题目难度 Easy 43.7%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn’t banned, and that the answer is unique.</p><p>Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.</p><p>Example 1:</p><pre class="highlight"><code class="">Input:paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot;Explanation:&quot;hit&quot; occurs 3 times, but it is a banned word.&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.Note that words in the paragraph are not case sensitive,that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;),and that &quot;hit&quot; isn't the answer even though it occurs more because it is banned.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题就考了一个东西，如何strip string。其他的count string啥的都很直接。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mostCommonWord</span><span class="hljs-params">(String paragraph, String[] banned)</span> </span>{        String[] words = paragraph.replaceAll(<span class="hljs-string">"[^a-zA-Z ]"</span>, <span class="hljs-string">" "</span>).toLowerCase().split(<span class="hljs-string">"\\s+"</span>);        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet();        <span class="hljs-keyword">for</span>(String s : banned)            set.add(s);        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(String s : words){            <span class="hljs-keyword">if</span>(set.contains(s))                <span class="hljs-keyword">continue</span>;            map.put(s, map.getOrDefault(s, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        }        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        String res = words[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(String s : map.keySet()){            <span class="hljs-keyword">if</span>(map.get(s) &gt; max){                max = map.get(s);                res = s;            }        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 43.7%<br />Memory: 5.05%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>246. Strobogrammatic Number</title>
      <link href="2020/02/07/Leetcode-246-Strobogrammatic-Number/"/>
      <url>2020/02/07/Leetcode-246-Strobogrammatic-Number/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsstrobogrammatic-number"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsstrobogrammatic-number"></a> 题目链接 <a href="https://leetcode.com/problems/strobogrammatic-number/" target="_blank" rel="noopener">https://leetcode.com/problems/strobogrammatic-number/</a></h2><h2 id="题目难度-easy-439"><a class="markdownIt-Anchor" href="#题目难度-easy-439"></a> 题目难度 Easy 43.9%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).<br />Write a function to determine if a number is strobogrammatic. The number is represented as a string.</p><p>Example 1:</p><pre class="highlight"><code class="">Input:  &quot;69&quot;Output: true</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这个题目要判断给定的string反转180度之后是否不变。所以就先储存那些不变的数，在遍历的时候碰到了不符合条件的就直接返回false，如果符合条件就和镜面对称的位置比较。一开始做这道题的时候我想的是把数字给求出来，最后返回是否相等就行。结果运行时间很差并且会溢出，后来一想只需要比较一半的strng就行。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStrobogrammatic</span><span class="hljs-params">(String num)</span> </span>{        <span class="hljs-keyword">int</span> n = num.length();        Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap();        map.put(<span class="hljs-string">'0'</span>, <span class="hljs-string">'0'</span>); map.put(<span class="hljs-string">'1'</span>, <span class="hljs-string">'1'</span>); map.put(<span class="hljs-string">'6'</span>, <span class="hljs-string">'9'</span>);        map.put(<span class="hljs-string">'9'</span>, <span class="hljs-string">'6'</span>); map.put(<span class="hljs-string">'8'</span>, <span class="hljs-string">'8'</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n / <span class="hljs-number">2</span>; i++){            <span class="hljs-keyword">if</span>(!map.containsKey(num.charAt(i)) || map.get(num.charAt(i)) != num.charAt(n - i - <span class="hljs-number">1</span>))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 8.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1243. Array Transformation</title>
      <link href="2020/02/07/Leetcode-1243-Array-Transformation/"/>
      <url>2020/02/07/Leetcode-1243-Array-Transformation/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsarray-transformation"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsarray-transformation"></a> 题目链接 <a href="https://leetcode.com/problems/array-transformation/" target="_blank" rel="noopener">https://leetcode.com/problems/array-transformation/</a></h2><h2 id="题目难度-easy-525"><a class="markdownIt-Anchor" href="#题目难度-easy-525"></a> 题目难度 Easy 52.5%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given an initial array arr, every day you produce a new array using the array of the previous day.<br />On the i-th day, you do the following operations on the array of day i-1 to produce the array of day i:</p><ul><li>If an element is smaller than both its left neighbor and its right neighbor, then this element is incremented.</li><li>If an element is bigger than both its left neighbor and its right neighbor, then this element is decremented.</li><li>The first and last elements never change.<br />After some days, the array does not change. Return that final array.</li></ul><p>Example 1:</p><pre class="highlight"><code class="">Input: arr = [1,6,3,4,3,5]Output: [1,4,4,4,4,5]Explanation:On the first day, the array is changed from [1,6,3,4,3,5] to [1,5,4,3,4,5].On the second day, the array is changed from [1,5,4,3,4,5] to [1,4,4,4,4,5].No more operations can be done to this array.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这个题目就是认真按照题目的描述写code就行，一天一天变化，记录是否又变化，没有变化了就结束了。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">transformArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>{        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList();        <span class="hljs-keyword">int</span>[] b = arr.clone();        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">while</span>(flag){            flag = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++){                <span class="hljs-keyword">if</span>(arr[i] &gt; arr[i-<span class="hljs-number">1</span>] &amp;&amp; arr[i] &gt; arr[i+<span class="hljs-number">1</span>]){                    flag = <span class="hljs-keyword">true</span>;                    b[i] = arr[i] - <span class="hljs-number">1</span>;                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i] &lt; arr[i-<span class="hljs-number">1</span>] &amp;&amp; arr[i] &lt; arr[i+<span class="hljs-number">1</span>]){                    flag = <span class="hljs-keyword">true</span>;                    b[i] = arr[i] + <span class="hljs-number">1</span>;                } <span class="hljs-keyword">else</span>{                    b[i] = arr[i];                }            }            arr = b.clone();        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : arr)            res.add(n);        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 95.24%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>448. Find All Numbers Disappeared in an Array</title>
      <link href="2020/02/06/Leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/"/>
      <url>2020/02/06/Leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsfind-all-numbers-disappeared-in-an-array"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsfind-all-numbers-disappeared-in-an-array"></a> 题目链接 <a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/</a></h2><h2 id="题目难度-easy-550"><a class="markdownIt-Anchor" href="#题目难度-easy-550"></a> 题目难度 Easy 55.0%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.<br />Find all the elements of [1, n] inclusive that do not appear in this array.<br />Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.<br />Example 1:</p><pre class="highlight"><code class="">Input:[4,3,2,7,8,2,3,1]Output:[5,6]</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目给定一个数组，这个数组应该包含从1到n的整数（n是这个数组的长度）。但是有些元素重复了导致另外一些消失了，现在要把消失的元素都找出来。要求用O(n) time O(1) space。<br />像这种数组的值限制在长度里面，并且要求线性的时间和常数的空间，一般都是要把值当index用去标记哪些出现过。然后再统计那些没有被标记的位置得到消失的元素。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)            nums[Math.abs(nums[i]) - <span class="hljs-number">1</span>] = -Math.abs(nums[Math.abs(nums[i]) - <span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)                res.add(i+<span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 90.63%<br />Memory: 73.58%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>953. Verifying an Alien Dictionary</title>
      <link href="2020/02/06/Leetcode-953-Verifying-an-Alien-Dictionary/"/>
      <url>2020/02/06/Leetcode-953-Verifying-an-Alien-Dictionary/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsverifying-an-alien-dictionary"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsverifying-an-alien-dictionary"></a> 题目链接 <a href="https://leetcode.com/problems/verifying-an-alien-dictionary/" target="_blank" rel="noopener">https://leetcode.com/problems/verifying-an-alien-dictionary/</a></h2><h2 id="题目难度-easy-551"><a class="markdownIt-Anchor" href="#题目难度-easy-551"></a> 题目难度 Easy 55.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.<br />Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.<br />Example 1:</p><pre class="highlight"><code class="">Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;Output: falseExplanation: As 'd' comes after 'l' in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目说，假如外星人也用小写英文，但是顺序和我们不一样。给我们一些词和字母顺序，要我们判断这些词是否符合这个顺序的词典顺序。所以我们需要先把顺序处理一下，形成O(1)的访问，因为在比较词的时候会大量访问这个顺序。然后就只需要从左到右逐个比较这些词是否符合顺序。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlienSorted</span><span class="hljs-params">(String[] words, String order)</span> </span>{        <span class="hljs-keyword">int</span>[] index = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">int</span> ind = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; order.length(); i++)            index[order.charAt(i) - <span class="hljs-string">'a'</span>] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length - <span class="hljs-number">1</span>; i++){            <span class="hljs-keyword">if</span>(!compare(words[i], words[i+<span class="hljs-number">1</span>], index))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compare</span><span class="hljs-params">(String s1, String s2, <span class="hljs-keyword">int</span>[] index)</span></span>{        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(; i &lt; Math.min(s1.length(), s2.length()); i++){            <span class="hljs-keyword">int</span> a = index[s1.charAt(i) - <span class="hljs-string">'a'</span>];            <span class="hljs-keyword">int</span> b = index[s2.charAt(i) - <span class="hljs-string">'a'</span>];            <span class="hljs-keyword">if</span>(a &lt; b)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a &gt; b)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        }        <span class="hljs-keyword">return</span> i == s1.length();    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 15.38%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1170. Compare Strings by Frequency of the Smallest Character</title>
      <link href="2020/02/06/Leetcode-1170-Compare-Strings-by-Frequency-of-the-Smallest-Character/"/>
      <url>2020/02/06/Leetcode-1170-Compare-Strings-by-Frequency-of-the-Smallest-Character/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemscompare-strings-by-frequency-of-the-smallest-character"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemscompare-strings-by-frequency-of-the-smallest-character"></a> 题目链接 <a href="https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/" target="_blank" rel="noopener">https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/</a></h2><h2 id="题目难度-easy-582"><a class="markdownIt-Anchor" href="#题目难度-easy-582"></a> 题目难度 Easy 58.2%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Let’s define a function f(s) over a non-empty string s, which calculates the frequency of the smallest character in s. For example, if s = “dcce” then f(s) = 2 because the smallest character is “c” and its frequency is 2.<br />Now, given string arrays queries and words, return an integer array answer, where each answer[i] is the number of words such that f(queries[i]) &lt; f(W), where W is a word in words.<br />Example 1:</p><pre class="highlight"><code class="">Input: queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]Output: [1,2]Explanation: On the first query only f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;). On the second query both f(&quot;aaa&quot;) and f(&quot;aaaa&quot;) are both &gt; f(&quot;cc&quot;).</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目评分很低。因为考的实质内容不多，多的是繁琐的count操作。首先要有一个function去实现题目中的f，实现了之后就是逐个比较的过程了。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] numSmallerByFrequency(String[] q, String[] w) {        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[q.length];        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">11</span>];        <span class="hljs-keyword">for</span>(String s : w)            count[helper(s)]++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; q.length; i++){            <span class="hljs-keyword">int</span> tmp = helper(q[i]);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = tmp + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">11</span>; j++)                res[i] += count[j];        }        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(String s)</span></span>{        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray())            map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        <span class="hljs-keyword">char</span> min_c = s.charAt(<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> min = map.get(min_c);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : map.keySet()){            <span class="hljs-keyword">if</span>(c &lt; min_c){                min_c = c;                min = map.get(c);            }        }        <span class="hljs-keyword">return</span> min;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 47.28%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>696. Count Binary Substrings</title>
      <link href="2020/02/06/Leetcode-696-Count-Binary-Substrings/"/>
      <url>2020/02/06/Leetcode-696-Count-Binary-Substrings/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemscount-binary-substrings"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemscount-binary-substrings"></a> 题目链接 <a href="https://leetcode.com/problems/count-binary-substrings/" target="_blank" rel="noopener">https://leetcode.com/problems/count-binary-substrings/</a></h2><h2 id="题目难度-easy-549"><a class="markdownIt-Anchor" href="#题目难度-easy-549"></a> 题目难度 Easy 54.9%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively.<br />Substrings that occur multiple times are counted the number of times they occur.<br />Example 1:</p><pre class="highlight"><code class="">Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0's (and 1's) are not grouped together.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目给定一个字符串s，要求找出子串的个数，子串的要求是0和1的个数相等，并且所有的0在一半，1在一半。所以0011这样的就有2个结果。其实这道题和有多少回文子串很像，都是从中间开始判断比较容易，因为中间满足条件才需要往两边去检查。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(String s)</span> </span>{        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span>[] c = s.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; left &lt; n - <span class="hljs-number">1</span>; left++){            <span class="hljs-keyword">int</span> right = left + <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(c[left] != c[right]){                res++;                <span class="hljs-keyword">int</span> i = left - <span class="hljs-number">1</span>, j = right + <span class="hljs-number">1</span>;                <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n &amp;&amp; c[i] == c[i+<span class="hljs-number">1</span>] &amp;&amp; c[j] == c[j-<span class="hljs-number">1</span>]){                    res++;                    i--;                    j++;                }            }        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 98.79%<br />Memory: 6.25%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1103. Distribute Candies to People</title>
      <link href="2020/02/05/Leetcode-1103-Distribute-Candies-to-People/"/>
      <url>2020/02/05/Leetcode-1103-Distribute-Candies-to-People/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsdistribute-candies-to-people"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsdistribute-candies-to-people"></a> 题目链接 <a href="https://leetcode.com/problems/distribute-candies-to-people/" target="_blank" rel="noopener">https://leetcode.com/problems/distribute-candies-to-people/</a></h2><h2 id="题目难度-easy-602"><a class="markdownIt-Anchor" href="#题目难度-easy-602"></a> 题目难度 Easy 60.2%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>We distribute some number of candies, to a row of n = num_people people in the following way:<br />We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.<br />Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.<br />This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).<br />Return an array (of length num_people and sum candies) that represents the final distribution of candies.<br />Example 1:</p><pre class="highlight"><code class="">Input: candies = 7, num_people = 4Output: [1,2,3,1]Explanation:On the first turn, ans[0] += 1, and the array is [1,0,0,0].On the second turn, ans[1] += 2, and the array is [1,2,0,0].On the third turn, ans[2] += 3, and the array is [1,2,3,0].On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>按照递增分糖果。每往后挪一下就增加一个，所以要记住前一个是多少。然后每一次都判断当前糖果是否足够，如果不足够就全部给。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] distributeCandies(<span class="hljs-keyword">int</span> candies, <span class="hljs-keyword">int</span> num_people) {        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num_people];        res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        candies -= <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(candies &gt; <span class="hljs-number">0</span>){            <span class="hljs-keyword">int</span> cur_ind = i % num_people;            <span class="hljs-keyword">int</span> need = pre + <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(candies &lt; need){                res[cur_ind] += candies;                candies = <span class="hljs-number">0</span>;            } <span class="hljs-keyword">else</span> {                res[cur_ind] += need;                candies -= need;            }            pre = need;            i++;        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 91.74%<br />Memory: 100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1260. Shift 2D Grid</title>
      <link href="2020/02/05/Leetcode-1260-Shift-2D-Grid/"/>
      <url>2020/02/05/Leetcode-1260-Shift-2D-Grid/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsshift-2d-grid"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsshift-2d-grid"></a> 题目链接 <a href="https://leetcode.com/problems/shift-2d-grid/" target="_blank" rel="noopener">https://leetcode.com/problems/shift-2d-grid/</a></h2><h2 id="题目难度-easy-604"><a class="markdownIt-Anchor" href="#题目难度-easy-604"></a> 题目难度 Easy 60.4%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.<br />In one shift operation:</p><ul><li>Element at grid[i][j] moves to grid[i][j + 1].</li><li>Element at grid[i][n - 1] moves to grid[i + 1][0].</li><li>Element at grid[m - 1][n - 1] moves to grid[0][0].<br />Return the 2D grid after applying shift operation k times.<br />Example 1:</li></ul><pre class="highlight"><code class="">Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题一拿到手真想不出来有啥高效的办法。其实把给定的2d matrix转成1d array，再看那些shift就简单很多了。比如[[1,2,3], [4,5,6]] Shift两次变成[[5,6,1],[2,3,4]]，其实就是个一维数组把后面的k个element放到前面来，你说是不是？</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; shiftGrid(<span class="hljs-keyword">int</span>[][] grid, <span class="hljs-keyword">int</span> k) {        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList();        <span class="hljs-keyword">int</span> m = grid.length;        <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length;        k = k % (m * n); <span class="hljs-comment">// 因为shift m*n 次就还原了</span>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m * n];        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)                arr[idx++] = grid[i][j];        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m * n - k; i &lt; m * n; i++){            list.add(arr[i]);            <span class="hljs-keyword">if</span>(list.size() == n){                res.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(list));                list = <span class="hljs-keyword">new</span> ArrayList();            }        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n - k; i++){            list.add(arr[i]);            <span class="hljs-keyword">if</span>(list.size() == n){                res.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(list));                list = <span class="hljs-keyword">new</span> ArrayList();            }        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime:  96.51%<br />Memory:  100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> grid </tag>
            
            <tag> 2d to 1d trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1331. Rank Transform of an Array</title>
      <link href="2020/02/05/Leetcode-1331-Rank-Transform-of-an-Array/"/>
      <url>2020/02/05/Leetcode-1331-Rank-Transform-of-an-Array/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsrank-transform-of-an-array"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsrank-transform-of-an-array"></a> 题目链接 <a href="https://leetcode.com/problems/rank-transform-of-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/rank-transform-of-an-array/</a></h2><h2 id="题目难度-easy-601"><a class="markdownIt-Anchor" href="#题目难度-easy-601"></a> 题目难度 Easy 60.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given an array of integers arr, replace each element with its rank.<br />The rank represents how large the element is. The rank has the following rules:</p><ul><li>Rank is an integer starting from 1.</li><li>The larger the element, the larger the rank. If two elements are equal, their rank must be the same.</li><li>Rank should be as small as possible.</li></ul><p>Example 1:</p><pre class="highlight"><code class="">Input: arr = [40,10,20,30]Output: [4,1,2,3]Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目要求把array的值换成rank，如果是相等的值那么rank也相等。读完这个题目，我有一个疑问就是，[1,1,2]和[1,1,3]这两个rank哪个是对的。如果是在面试中碰到这个题我就要问一下面试官，在leetcode里我就是自己创建一个testcase去看结果。结果证明第一个是对的。那么我的步骤是先复制一下array再排序，这里涉及rank就肯定需要sort，然后用hashmap去记录排好序的数组的rank，再往回去对应rank。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] arrayRankTransform(<span class="hljs-keyword">int</span>[] arr) {        <span class="hljs-keyword">int</span> n = arr.length;        <span class="hljs-keyword">int</span>[] b = arr.clone();        Arrays.sort(b);        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">int</span> rank = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>){                map.put(b[i], rank);                <span class="hljs-keyword">continue</span>;            }            rank = b[i] == b[i-<span class="hljs-number">1</span>] ? rank : rank + <span class="hljs-number">1</span>;            map.put(b[i], rank);        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)            arr[i] = map.get(arr[i]);        <span class="hljs-keyword">return</span> arr;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime:  95.47%<br />Memory:  100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>758. Bold Words in String</title>
      <link href="2020/02/04/Leetcode-758-Bold-Words-in-String/"/>
      <url>2020/02/04/Leetcode-758-Bold-Words-in-String/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsbold-words-in-string"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsbold-words-in-string"></a> 题目链接 <a href="https://leetcode.com/problems/bold-words-in-string/" target="_blank" rel="noopener">https://leetcode.com/problems/bold-words-in-string/</a></h2><h2 id="题目难度-easy-441"><a class="markdownIt-Anchor" href="#题目难度-easy-441"></a> 题目难度 Easy 44.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a set of keywords words and a string S, make all appearances of all keywords in S bold. Any letters between <b> and </b> tags become bold.<br />The returned string should use the least number of tags possible, and of course the tags should form a valid combination.<br />For example, given that <code>words = [&quot;ab&quot;, &quot;bc&quot;]</code> and <code>S = &quot;aabcd&quot;</code>, we should return <code>&quot;a&lt;b&gt;abc&lt;/b&gt;d&quot;</code>. Note that returning <code>&quot;a&lt;b&gt;a&lt;b&gt;b&lt;/b&gt;c&lt;/b&gt;d&quot;</code> would use more tags, so it is incorrect.</p><p>Note:</p><p>words has length in range [0, 50].<br />words[i] has length in range [1, 10].<br />S has length in range [0, 500].<br />All characters in words[i] and S are lowercase letters.</p><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目给定一些word，和一个长string s，要求在s中找到这些word，并且用最少的<code>&lt;b&gt;...&lt;/b&gt;</code>来标记，因为word中出现的词有可能会连起来。如果我们能知道所有需要标记的坐标就很容易完成标记了。那么如何知道这些坐标呢？可以用string的indexOf来找是否有这些word，这里有一个难点就是all appearances，所以在找坐标的时候就得重复找，直到返回值是-1.</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">boldWords</span><span class="hljs-params">(String[] words, String S)</span> </span>{        <span class="hljs-keyword">int</span> N = S.length();        <span class="hljs-keyword">boolean</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[N];        <span class="hljs-keyword">for</span>(String s : words){            <span class="hljs-keyword">int</span> ind = S.indexOf(s, <span class="hljs-number">0</span>);            <span class="hljs-keyword">while</span>(ind &gt; -<span class="hljs-number">1</span>){                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = ind; i &lt; ind + s.length(); i++)                    flag[i] = <span class="hljs-keyword">true</span>;                ind = S.indexOf(s, ind + <span class="hljs-number">1</span>); <span class="hljs-comment">// 重复往后找直到返回-1</span>            }        }        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>; h &lt; N; h++){            <span class="hljs-keyword">if</span>(flag[h] &amp;&amp; (h == <span class="hljs-number">0</span> || !flag[h-<span class="hljs-number">1</span>]))                sb.append(<span class="hljs-string">"&lt;b&gt;"</span>);            sb.append(S.charAt(h));            <span class="hljs-keyword">if</span>(flag[h] &amp;&amp; (h == N-<span class="hljs-number">1</span> || !flag[h+<span class="hljs-number">1</span>]))                sb.append(<span class="hljs-string">"&lt;/b&gt;"</span>);        }        <span class="hljs-keyword">return</span> sb.toString();    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime:  88.10%<br />Memory:  100.00%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>594. Longest Harmonious Subsequence</title>
      <link href="2020/02/04/Leetcode-594-Longest-Harmonious-Subsequence/"/>
      <url>2020/02/04/Leetcode-594-Longest-Harmonious-Subsequence/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemslongest-harmonious-subsequence"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemslongest-harmonious-subsequence"></a> 题目链接 <a href="https://leetcode.com/problems/longest-harmonious-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-harmonious-subsequence/</a></h2><h2 id="题目难度-easy-452"><a class="markdownIt-Anchor" href="#题目难度-easy-452"></a> 题目难度 Easy 45.2%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1.<br />Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.<br />Example 1:</p><pre class="highlight"><code class="">Input: [1,3,2,2,5,2,3,7]Output: 5Explanation: The longest harmonious subsequence is [3,2,2,2,3].</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目要求找出最长的harmounious序列的长度，harmounious序列就是最大值与最小值之差是1。所以该题与顺序无关，与出现的次数有关，那么用hashmap统计每个数字的次数。然后要求之差为1，那么就看每个数字n是否有n-1，如果没有就是0，如果有就是两者相加，再与res相比较得到最后的最大值。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : nums)            map.put(n, map.getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : map.keySet()){            <span class="hljs-keyword">int</span> cur = map.get(n);            <span class="hljs-keyword">if</span>(map.containsKey(n - <span class="hljs-number">1</span>))                cur += map.get(n - <span class="hljs-number">1</span>);            <span class="hljs-keyword">else</span>                cur = <span class="hljs-number">0</span>;            res = Math.max(res, cur);        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 89.16%<br />Memory: 31.58%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>401. Binary Watch</title>
      <link href="2020/02/04/Leetcode-401-Binary-Watch/"/>
      <url>2020/02/04/Leetcode-401-Binary-Watch/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsbinary-watch"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsbinary-watch"></a> 题目链接 <a href="https://leetcode.com/problems/binary-watch/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-watch/</a></h2><h2 id="题目难度-easy-463"><a class="markdownIt-Anchor" href="#题目难度-easy-463"></a> 题目难度 Easy 46.3%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).<br />Each LED represents a zero or one, with the least significant bit on the right.<br />Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</code></pre><p>Note:</p><ul><li>The order of output does not matter.</li><li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li><li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li></ul><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题是个高频题。并且我认为它的难度应该在medium。读完题就能感受到是个排列组合问题，1bit放在哪个位置的问题。 这里有几个难点：</p><ol><li>有hour和minute两个集合，所以首先一个loop是分多少个1在hour，剩下的在minute；</li><li>分好了1的个数之后，就开始排列组合形成二进制数，这里很容易想到是dfs遍历所有情况。一开始我还考虑到了hour是4位，minute是6位。后来发现其实可以先不用管，在最后合并的时候判断一下数值大小就行了。</li></ol><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">readBinaryWatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList();        <span class="hljs-keyword">int</span>[] hours = {<span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>};        <span class="hljs-keyword">int</span>[] mins = {<span class="hljs-number">32</span>, <span class="hljs-number">16</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>};        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= Math.min(<span class="hljs-number">4</span>, num); i++){ <span class="hljs-comment">// 有i个1在hour</span>            List&lt;Integer&gt; hour = helper(hours, i);            List&lt;Integer&gt; min = helper(mins, num - i);            <span class="hljs-keyword">for</span>(Integer h : hour){                <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">11</span>) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">for</span>(Integer m : min){                    <span class="hljs-keyword">if</span>(m &gt; <span class="hljs-number">59</span>) <span class="hljs-keyword">continue</span>;                    res.add(String.valueOf(h) + (m &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">":0"</span> : <span class="hljs-string">":"</span>) + String.valueOf(m));                }            }        }        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] input, <span class="hljs-keyword">int</span> n)</span></span>{        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList();        dfs(input, <span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>, res);        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] input, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> out, List&lt;Integer&gt; res)</span></span>{        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>){ <span class="hljs-comment">// 没有1了</span>            res.add(out);            <span class="hljs-keyword">return</span>;            }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt; input.length; i++){ <span class="hljs-comment">//这里不是很好理解，需要记一下</span>            dfs(input, i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, out + input[i], res);        }    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime:  48.76%<br />Memory:  33.33%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>551. Student Attendance Record I</title>
      <link href="2020/02/04/Leetcode-551-Student-Attendance-Record-I/"/>
      <url>2020/02/04/Leetcode-551-Student-Attendance-Record-I/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsstudent-attendance-record-i"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsstudent-attendance-record-i"></a> 题目链接 <a href="https://leetcode.com/problems/student-attendance-record-i/" target="_blank" rel="noopener">https://leetcode.com/problems/student-attendance-record-i/</a></h2><h2 id="题目难度-easy-464"><a class="markdownIt-Anchor" href="#题目难度-easy-464"></a> 题目难度 Easy 46.4%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:<br />‘A’ : Absent.<br />‘L’ : Late.<br />‘P’ : Present.<br />A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late).<br />You need to return whether the student could be rewarded according to his attendance record.<br />Example 1:</p><pre class="highlight"><code class="">Input: &quot;PPALLP&quot;Output: True</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目的意思是，如果这个学生缺勤超过1次或者连续迟到超过2次就没有奖励。这道题的评分不太好，因为是一道不太具有考察能力的题目。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkRecord</span><span class="hljs-params">(String s)</span> </span>{        <span class="hljs-keyword">int</span> countA = <span class="hljs-number">0</span>, countL = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++){            <span class="hljs-keyword">char</span> c = s.charAt(i);            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'L'</span>)                countL++;            <span class="hljs-keyword">else</span>{                countL = <span class="hljs-number">0</span>;                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'A'</span>)                    countA++;            }            <span class="hljs-keyword">if</span>(countA &gt; <span class="hljs-number">1</span> || countL &gt; <span class="hljs-number">2</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100.00%<br />Memory: 5.26%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>572. Subtree of Another Tree</title>
      <link href="2020/02/03/Leetcode-572-Subtree-of-Another-Tree/"/>
      <url>2020/02/03/Leetcode-572-Subtree-of-Another-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemssubtree-of-another-tree"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemssubtree-of-another-tree"></a> 题目链接 <a href="https://leetcode.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/subtree-of-another-tree/</a></h2><h2 id="题目难度-easy-437"><a class="markdownIt-Anchor" href="#题目难度-easy-437"></a> 题目难度 Easy 43.7%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself.<br />Example 1:</p><pre class="highlight"><code class="">Given tree s:     3    / \   4   5  / \ 1   2Given tree t:   4  / \ 1   2Return true, because t has the same structure and node values with a subtree of s.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>t题目要求判断t是否是s的子树，子树就是s的一个树枝摘下来要完全等于t。那么就分别判断，如果root相等，那这两个树就要完全相等才行。否则就在s的左右子树中找。反正就是两种情况，包含root和不包含root。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode s, TreeNode t)</span> </span>{        <span class="hljs-keyword">if</span>(t == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> check(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode s, TreeNode t)</span></span>{        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> &amp;&amp; t == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || t == <span class="hljs-keyword">null</span> || s.val != t.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> check(s.left, t.left) &amp;&amp; check(s.right, t.right);    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime:  96.80%<br />Memory:  97.78%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> BFS </tag>
            
            <tag> Grid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191. Number of 1 Bits</title>
      <link href="2020/02/03/Leetcode-191-Number-of-1-Bits/"/>
      <url>2020/02/03/Leetcode-191-Number-of-1-Bits/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-1-bits/</a></p><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Easy 46.6%</p><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the Hamming weight).</p><p>Example 1:</p><pre class="highlight"><code class="">Input: 00000000000000000000000000001011Output: 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目的意思是，给一个整数，要count有多少个bit是1，把这个整数当作无符号整数。那么就用一个mask，每一位的去看是否为一。如果为1，那么&amp;之后就不会是0，但注意也不一定是1。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-comment">// you need to treat n as an unsigned value</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++){            <span class="hljs-keyword">if</span>((n &amp; mask) != <span class="hljs-number">0</span>)                res++;            mask = mask &lt;&lt; <span class="hljs-number">1</span>;        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100%<br />Memory: 5.41%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Bit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>994. Rotting Oranges</title>
      <link href="2020/02/03/Leetcode-994-Rotting-Oranges/"/>
      <url>2020/02/03/Leetcode-994-Rotting-Oranges/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsrotting-oranges"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsrotting-oranges"></a> 题目链接 <a href="https://leetcode.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode.com/problems/rotting-oranges/</a></h2><h2 id="题目难度-easy-470"><a class="markdownIt-Anchor" href="#题目难度-easy-470"></a> 题目难度 Easy 47.0%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>In a given grid, each cell can have one of three values:</p><ul><li>the value 0 representing an empty cell;</li><li>the value 1 representing a fresh orange;</li><li>the value 2 representing a rotten orange.</li></ul><p>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.<br />Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.<br />Example 1:</p><pre class="highlight"><code class="">Input: [[2,1,1],[1,1,0],[0,1,1]]Output: 4</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这是一道很有意思的题。坏了的橘子会把周围好的橘子也弄坏，然后慢慢传播开来。题目给定一个矩阵，然后问多少回合能将所有橘子都传染坏。如果不能就返回-1。这道题读下来就感觉比一般easy的题要难一点。这里的一回合，意思是所有为2的点都开始传播，这里就应该要想到BFS了，也就是tree的level traversal。level traversal就是用queue去储存一个level的点，然后遍历这个queue，做好标记，将新来的点加到后面，一直到queue为空。<br />在遍历的过程中，我们需要做的事情有：</p><ol><li>对于每一个点都要看看四周是否有坏橘子；</li><li>将新的点加入queue并且标记2；</li><li>随时记录为1的点，因为最后还要判断是否所有橘子都坏了；</li><li>这里有一点是需要记住并且练习的，就是对每一个点检查上下左右四周的操作。</li></ol><pre class="highlight"><code class="java"><span class="hljs-keyword">int</span>[][] steps = &lt;!--￼<span class="hljs-number">0</span>--&gt;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] step : steps){<span class="hljs-keyword">int</span> x = pos[<span class="hljs-number">0</span>] + step[<span class="hljs-number">0</span>];<span class="hljs-keyword">int</span> y = pos[<span class="hljs-number">1</span>] + step[<span class="hljs-number">1</span>];<span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= n || y &gt;= m || ...) <span class="hljs-comment">// not qualify</span><span class="hljs-keyword">continue</span>;... <span class="hljs-comment">// if qualify</span>}</code></pre><ol start="5"><li>用一个queue去做level traversal是需要记录queue的size的。</li></ol><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>{        <span class="hljs-keyword">int</span> n = grid.length;        <span class="hljs-keyword">int</span> m = grid[<span class="hljs-number">0</span>].length;        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; q = <span class="hljs-keyword">new</span> LinkedList();        <span class="hljs-keyword">int</span> freshcount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++){                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">2</span>)                    q.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{i, j});                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)                    freshcount++;            }        }        <span class="hljs-keyword">if</span>(freshcount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[][] steps = &lt;!--￼<span class="hljs-number">1</span>--&gt;;        <span class="hljs-keyword">while</span>(!q.isEmpty()){            count++;            <span class="hljs-keyword">int</span> size = q.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){                <span class="hljs-keyword">int</span>[] pos = q.poll();                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] step : steps){                    <span class="hljs-keyword">int</span> x = pos[<span class="hljs-number">0</span>] + step[<span class="hljs-number">0</span>];                    <span class="hljs-keyword">int</span> y = pos[<span class="hljs-number">1</span>] + step[<span class="hljs-number">1</span>];                    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= n || y &gt;= m || grid[x][y] == <span class="hljs-number">2</span> || grid[x][y] == <span class="hljs-number">0</span>)                        <span class="hljs-keyword">continue</span>;                    grid[x][y] = <span class="hljs-number">2</span>;                    q.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{x, y});                    freshcount--;                }            }        }        <span class="hljs-keyword">return</span> freshcount == <span class="hljs-number">0</span> ? count - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 31.05%<br />Memory: 81.25%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1018. Binary Prefix Divisible By 5</title>
      <link href="2020/02/03/Leetcode-1018-Binary-Prefix-Divisible-By-5/"/>
      <url>2020/02/03/Leetcode-1018-Binary-Prefix-Divisible-By-5/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsbinary-prefix-divisible-by-5"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsbinary-prefix-divisible-by-5"></a> 题目链接 <a href="https://leetcode.com/problems/binary-prefix-divisible-by-5/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-prefix-divisible-by-5/</a></h2><h2 id="题目难度-easy-470"><a class="markdownIt-Anchor" href="#题目难度-easy-470"></a> 题目难度 Easy 47.0%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.)<br />Return a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5.<br />Example 1:</p><pre class="highlight"><code class="">Input: [0,1,1]Output: [true,false,false]Explanation:The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: [0,1,1,1,1,1]Output: [true,false,false,false,true,false]</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目的意思很简单，就是给定一个数组，里面只有0和1，看看从左到右形成的所有二进制的数能否被5整除。<br />那么就是每添加一个右边的数，就相当于当前的数向左移一位再加上右边这个数。再判断一下是否被5整除。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title">prefixesDivBy5</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{        List&lt;Boolean&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : A){            curr = <span class="hljs-number">2</span>*curr+i;            curr %= <span class="hljs-number">5</span>;            res.add(curr == <span class="hljs-number">0</span>);        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 86.29%<br />Memory: 9.09%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>541. Reverse String II</title>
      <link href="2020/02/03/Leetcode-541-Reverse-String-II/"/>
      <url>2020/02/03/Leetcode-541-Reverse-String-II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsreverse-string-ii"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsreverse-string-ii"></a> 题目链接 <a href="https://leetcode.com/problems/reverse-string-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-string-ii/</a></h2><h2 id="题目难度-easy-471"><a class="markdownIt-Anchor" href="#题目难度-easy-471"></a> 题目难度 Easy 47.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p><p>Example 1:</p><pre class="highlight"><code class="">Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot;</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这个题目的意思是给定一个字符串s和一个整数k，把s中每2k长度的子串反转前k个字符。如果最后剩下的不足k个就全部反转，否组还是反转前k个。<br />这个题目收到的赞是341，踩是997，说明这道题不是一个很好考验算法的题目。我的答案是按照最简单的逻辑写的，比官方答案繁琐，但是更直接。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>{        <span class="hljs-keyword">int</span> n = s.length();        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i + <span class="hljs-number">2</span> * k &lt; n){            StringBuilder tmp = <span class="hljs-keyword">new</span> StringBuilder(s.substring(i, i + k));            sb.append(tmp.reverse());            sb.append(s.substring(i + k, i + <span class="hljs-number">2</span> * k));            i += <span class="hljs-number">2</span> * k;        }        <span class="hljs-keyword">if</span>(i &gt; n - k){            StringBuilder tmp = <span class="hljs-keyword">new</span> StringBuilder(s.substring(i));            sb.append(tmp.reverse());        } <span class="hljs-keyword">else</span> {            StringBuilder tmp = <span class="hljs-keyword">new</span> StringBuilder(s.substring(i, i + k));            sb.append(tmp.reverse());            sb.append(s.substring(i + k));        }        <span class="hljs-keyword">return</span> sb.toString();    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 77.19%<br />Memory: 7.41%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>299. Bulls and Cows</title>
      <link href="2020/01/27/Leetcode-299-Bulls-and-Cows/"/>
      <url>2020/01/27/Leetcode-299-Bulls-and-Cows/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsbulls-and-cows"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsbulls-and-cows"></a> 题目链接 <a href="https://leetcode.com/problems/bulls-and-cows/" target="_blank" rel="noopener">https://leetcode.com/problems/bulls-and-cows/</a></h2><h2 id="题目难度-easy-413"><a class="markdownIt-Anchor" href="#题目难度-easy-413"></a> 题目难度 Easy 41.3%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.<br />Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows.<br />Please note that both secret number and friend’s guess may contain duplicate digits.<br />Example 1:</p><pre class="highlight"><code class="">Input: secret = &quot;1123&quot;, guess = &quot;0111&quot;Output: &quot;1A1B&quot;Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>其实就是count每个字符的频率。如果对应着出现的，就直接增加A，否则就记录下来。然后再比较count。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHint</span><span class="hljs-params">(String secret, String guess)</span> </span>{        <span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];        <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];        <span class="hljs-keyword">int</span> A = <span class="hljs-number">0</span>, B = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; secret.length(); i++){            <span class="hljs-keyword">int</span> s_int = secret.charAt(i) - <span class="hljs-string">'0'</span>;            <span class="hljs-keyword">int</span> g_int = guess.charAt(i) - <span class="hljs-string">'0'</span>;            <span class="hljs-keyword">if</span>(s_int == g_int)                A++;            <span class="hljs-keyword">else</span>{                s[s_int]++;                g[g_int]++;            }        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++){            B += Math.min(s[i], g[i]);        }        <span class="hljs-keyword">return</span> String.valueOf(A) + <span class="hljs-string">"A"</span> + String.valueOf(B) + <span class="hljs-string">"B"</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 51.43%<br />Memory: 55.26%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>849. Maximize Distance to Closest Person</title>
      <link href="2020/01/27/Leetcode-849-Maximize-Distance-to-Closest-Person/"/>
      <url>2020/01/27/Leetcode-849-Maximize-Distance-to-Closest-Person/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsmaximize-distance-to-closest-person"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsmaximize-distance-to-closest-person"></a> 题目链接 <a href="https://leetcode.com/problems/maximize-distance-to-closest-person/" target="_blank" rel="noopener">https://leetcode.com/problems/maximize-distance-to-closest-person/</a></h2><h2 id="题目难度-easy-421"><a class="markdownIt-Anchor" href="#题目难度-easy-421"></a> 题目难度 Easy 42.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.<br />There is at least one empty seat, and at least one person sitting.<br />Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.<br />Return that maximum distance to closest person.<br />Example 1:</p><pre class="highlight"><code class="">Input: [1,0,0,0,1,0,1]Output: 2Explanation:If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.If Alex sits in any other open seat, the closest person has distance 1.Thus, the maximum distance to the closest person is 2.</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: [1,0,0,0]Output: 3Explanation:If Alex sits in the last seat, the closest person is 3 seats away.This is the maximum distance possible, so the answer is 3.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>给一排座位，要找一个离别人最远的座位。挺有趣的题目，和现实也挺符合。很容易想到的是用两个数组from_left和from_right，from_left[i]表示位置i到左边有人的距离为几，from_right[i]表示位置i到右边有人的距离为几。然后两个数组的对应位置的最小值就是该位置到有人位置的距离。这里难点是这两个数组的初始值应该怎么设置。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDistToClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] seats)</span> </span>{        <span class="hljs-keyword">int</span> n = seats.length;        <span class="hljs-keyword">int</span> max_dist = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] from_left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">int</span>[] from_right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        Arrays.fill(from_left, n);        Arrays.fill(from_right, n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){            <span class="hljs-keyword">if</span>(seats[i] == <span class="hljs-number">1</span>) from_left[i] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) from_left[i] = from_left[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){            <span class="hljs-keyword">if</span>(seats[i] == <span class="hljs-number">1</span>) from_right[i] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; n-<span class="hljs-number">1</span>) from_right[i] = from_right[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){            <span class="hljs-keyword">int</span> dist = Math.min(from_left[i], from_right[i]);            max_dist = Math.max(dist, max_dist);        }        <span class="hljs-keyword">return</span> max_dist;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 92.77%<br />Memory: 8.3%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>437. Path Sum III</title>
      <link href="2020/01/27/Leetcode-437-Path-Sum-III/"/>
      <url>2020/01/27/Leetcode-437-Path-Sum-III/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemspath-sum-iii"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemspath-sum-iii"></a> 题目链接 <a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-iii/</a></h2><h2 id="题目难度-easy-446"><a class="markdownIt-Anchor" href="#题目难度-easy-446"></a> 题目难度 Easy 44.6%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>You are given a binary tree in which each node contains an integer value.<br />Find the number of paths that sum to a given value.<br />The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).<br />The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.<br />Example 1:</p><pre class="highlight"><code class="">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8      10     /  \    5   -3   / \    \  3   2   11 / \   \3  -2   1Return 3. The paths that sum to 8 are:1.  5 -&gt; 32.  5 -&gt; 2 -&gt; 13. -3 -&gt; 11</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目给出一个二叉树和一个整数。找出有多少条path和为给定得整数。path不一定要从root开始或者以leaf结束。这里其实就是难点所在。不以leaf结尾不用怎么管，因为是结尾，所以判断剩下的数等于当前节点值就可以判断。关键在于不一定以root开始，所以我们就要分情况了，最后结果应该是 1）以root开始；+ 2）不以root开始。不以root开始更简单，那就是左右子树的子问题相加。以root开始呢，那就要往左右子树一直延续下去，遇到root.val==sum就要加一。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> has_root = helper(root, sum);        <span class="hljs-keyword">int</span> no_root = pathSum(root.left, sum) + pathSum(root.right, sum);        <span class="hljs-keyword">return</span> has_root + no_root;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span></span>{        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(root.val == sum) res = <span class="hljs-number">1</span>;        res += helper(root.left, sum - root.val) + helper(root.right, sum - root.val);        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 11.01% （可能有大量的重复计算，以后再优化，现在的版本最好理解）<br />Memory: 90.91%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>697. Degree of an Array</title>
      <link href="2019/12/24/Leetcode-697-Degree-of-an-Array/"/>
      <url>2019/12/24/Leetcode-697-Degree-of-an-Array/</url>
      
        <content type="html"><![CDATA[<h4 id="题目链接-httpsleetcodecomproblemsdegree-of-an-array"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsdegree-of-an-array"></a> 题目链接 <a href="https://leetcode.com/problems/degree-of-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/degree-of-an-array/</a></h4><h4 id="题目难度-easy-523"><a class="markdownIt-Anchor" href="#题目难度-easy-523"></a> 题目难度 Easy: 52.3%</h4><a id="more"></a><h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4><p>Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.<br />Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.<br />Example 1:</p><pre class="highlight"><code class="">Input: [1, 2, 2, 3, 1]Output: 2Explanation:The input array has a degree of 2 because both elements 1 and 2 appear twice.Of the subarrays that have the same degree:[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]The shortest length is 2. So return 2.</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: [1,2,2,3,1,4,2]Output: 6</code></pre><h4 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h4><p>按照题目的要求，要知道所有元素出现的次数，再找出出现次数最多的元素的起点与终点差，如果有多个，返回最小差的那个。要count元素很容易想到int[]和HashMap，但是这里除了count，还要知道开始和结束的坐标，所以就用HashMap&lt;Integer, List<Integer>&gt;对每个元素记录所有出现的坐标，count就是list的size。因为记录的时候是按照顺序来的，所以最后找开始和终点坐标也很简单，就是list.get(size-1)和list.get(0)。对于size一样的，就取最小的。</p><h4 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h4><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findShortestSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++){            List&lt;Integer&gt; list;            <span class="hljs-keyword">if</span>(map.containsKey(nums[i]))                list = map.get(nums[i]);            <span class="hljs-keyword">else</span>                list = <span class="hljs-keyword">new</span> ArrayList();            list.add(i);            map.put(nums[i], list);        }        <span class="hljs-keyword">int</span> distance = Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> freq = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : map.keySet()){            List&lt;Integer&gt; list = map.get(n);            <span class="hljs-keyword">int</span> size = list.size();            <span class="hljs-keyword">if</span>(size &gt; freq){                freq = size;                distance = list.get(size-<span class="hljs-number">1</span>) - list.get(<span class="hljs-number">0</span>);            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size == freq){                distance = Math.min(distance, list.get(size-<span class="hljs-number">1</span>) - list.get(<span class="hljs-number">0</span>));            }        }        <span class="hljs-keyword">return</span> distance + <span class="hljs-number">1</span>;    }}</code></pre><h4 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h4><p>Runtime: 78.37%<br />Memory: 16.67%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1029. Two City Scheduling</title>
      <link href="2019/12/23/Leetcode-1029-Two-City-Scheduling/"/>
      <url>2019/12/23/Leetcode-1029-Two-City-Scheduling/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemstwo-city-scheduling"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemstwo-city-scheduling"></a> 题目链接https://leetcode.com/problems/two-city-scheduling/</h2><h2 id="题目难度easy-553"><a class="markdownIt-Anchor" href="#题目难度easy-553"></a> 题目难度Easy: 55.3%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1].<br />Return the minimum cost to fly every person to a city such that exactly N people arrive in each city.</p><p>Example:</p><pre class="highlight"><code class="">Input: [[10,20],[30,200],[400,50],[30,20]]Output: 110Explanation:The first person goes to city A for a cost of 10.The second person goes to city A for a cost of 30.The third person goes to city B for a cost of 50.The fourth person goes to city B for a cost of 20.The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这个题目一拿到手就觉得是动态规划的题，因为题目要求最小cost，一般这种都是动态规划。但是想了很久都没想出来，无奈之下看了答案，结果是greedy。题目关键点就是每个人都必须被派到A或者B，所以对每个人就有一个cost差，比如：例子中的第一个人去A不去B的cost应该是10-20=-10，意思为公司省10块。那么，我们把每个人都计算一下差值再排一下序，把前一半送去A，后一半送去B。这里也正式学习写comparator的好时机。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">twoCitySchedCost</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] costs)</span> </span>{        Arrays.sort(costs, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;(){            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] o1, <span class="hljs-keyword">int</span>[] o2)</span></span>{                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">1</span>] - (o2[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">1</span>]);            }        });        <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = costs.length / <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)            total += costs[i][<span class="hljs-number">0</span>] + costs[i+n][<span class="hljs-number">1</span>];        <span class="hljs-keyword">return</span> total;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 98.63%<br />Memory: 22.22%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-必备小知识点（持续更新）</title>
      <link href="2019/12/23/Leetcode-RelatedThings/"/>
      <url>2019/12/23/Leetcode-RelatedThings/</url>
      
        <content type="html"><![CDATA[<p>刷题的时候有一些小的知识点很有用也很快捷，但感觉很多也很杂。所以在这篇文章中持续更新总结刷题过程中所遇到的。</p><a id="more"></a><h2 id="string-stringbuilder"><a class="markdownIt-Anchor" href="#string-stringbuilder"></a> String / StringBuilder</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>String start with</td><td><code>str.startsWith(String prefix, int toffset);</code></td></tr><tr><td>2</td><td>String split</td><td><code>str.split(&quot;\\s+&quot;); str.split(&quot;\\.&quot;);</code></td></tr><tr><td>3</td><td>String trim</td><td><code>str.trim();</code></td></tr><tr><td>4</td><td>Equal String</td><td><code>str1.equals(str2);</code></td></tr><tr><td>5</td><td>String replace</td><td><code>str.replace(&quot;&quot;, &quot;&quot;);</code></td></tr><tr><td>6</td><td>StringBuilder</td><td><code>sb.append(str); sb.toString(); sb.reverse();</code></td></tr><tr><td>7</td><td>Check char is letter</td><td><code>Character.isLetter(c);</code></td></tr><tr><td>8</td><td>Find substring index</td><td><code>str.indexOf(s, start_pos);</code></td></tr><tr><td>9</td><td>toLowerCase / toUpperCase</td><td><code>s.toLowerCase(); s.toUpperCase();</code></td></tr><tr><td>10</td><td>strip punctuation and split</td><td><code>s.replaceAll(&quot;[^a-zA-Z ]&quot;, &quot; &quot;).toLowerCase().split(&quot;\\s+&quot;);</code></td></tr><tr><td>11</td><td>StringBuilder delete char</td><td><code>sb.deleteCharAt(i);</code></td></tr><tr><td>12</td><td>String Compare</td><td><code>s1.compareTo(s2) &lt; 0; //check if s1 &lt; s2 lexicographically</code></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>Reverse</td><td><code>Collections.reverse(list);</code></td></tr><tr><td>2</td><td>Equals</td><td><code>list1.equals(list2);</code></td></tr><tr><td>3</td><td>Remove last element</td><td><code>list.remove(list.size() - 1);</code></td></tr><tr><td>4</td><td>Add as first element</td><td><code>list.add(0, n);</code></td></tr><tr><td>5</td><td>Set element</td><td><code>list.set(2, n);</code></td></tr><tr><td>6</td><td>Map value list to nested list</td><td><code>new ArrayList(map.values());</code></td></tr></tbody></table><h2 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>Insert</td><td><code>offer(e);</code></td></tr><tr><td>2</td><td>Remove</td><td><code>poll();</code></td></tr><tr><td>3</td><td>Get peek</td><td><code>peek();</code></td></tr><tr><td>4</td><td>Initial</td><td><code>Queue&lt;String&gt; q = new LinkedList();</code></td></tr><tr><td>5</td><td>Size</td><td><code>q.size(); // 如果用一个queue做level traversal，记得用int size = q.size();先记录size</code></td></tr><tr><td>6</td><td>Empty</td><td><code>q.empty();</code></td></tr><tr><td>7</td><td>clone</td><td><code>new LinkedList&lt;&gt;(myQueue);</code></td></tr></tbody></table><h2 id="arraydeque"><a class="markdownIt-Anchor" href="#arraydeque"></a> ArrayDeque</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>Insert from head</td><td><code>offerFirst(e);</code></td></tr><tr><td>2</td><td>Removal from head</td><td><code>pollFirst();</code></td></tr><tr><td>3</td><td>Retrieval from head</td><td><code>peekFirst();</code></td></tr><tr><td>4</td><td>Insert from tail</td><td><code>offerLast(e);</code></td></tr><tr><td>5</td><td>Removal from tail</td><td><code>pollLast();</code></td></tr><tr><td>6</td><td>Retrieval from tail</td><td><code>peekLast();</code></td></tr><tr><td>7</td><td>Initialize</td><td><code>Deque&lt;String&gt; q = new ArrayDeque();</code></td></tr></tbody></table><h2 id="priorityqueue"><a class="markdownIt-Anchor" href="#priorityqueue"></a> PriorityQueue</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>Initialize</td><td><code>PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;();</code></td></tr><tr><td>2</td><td>Default Comparator</td><td>是小根堆</td></tr><tr><td>3</td><td>MaxHeap Comparator</td><td>```new PriorityQueue<Integer>((n1, n2)-&gt;n2 - n1);</td></tr><tr><td>4</td><td>External Comparator</td><td><code>new PriorityQueue&lt;&gt;((x, y)-&gt;map.get(y) - map.get(x));</code></td></tr><tr><td>5</td><td>ListNode Comparator</td><td><code>new PriorityQueue&lt;&gt;((n1, n2)-&gt;n1.val - n2.val);</code></td></tr></tbody></table><h2 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> Stack</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>Insert</td><td><code>push(e);</code></td></tr><tr><td>2</td><td>Remove</td><td><code>pop();</code></td></tr><tr><td>3</td><td>Get peek</td><td><code>peek();</code></td></tr><tr><td>4</td><td>Initial</td><td><code>Stack&lt;String&gt; s = new Stack();</code></td></tr><tr><td>5</td><td>Size</td><td><code>s.size();</code></td></tr><tr><td>6</td><td>Empty</td><td><code>s.empty();</code></td></tr></tbody></table><h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>Update</td><td><code>map.put(a, map.getOrDefault(a, 0) + 1);</code></td></tr><tr><td>2</td><td>Max value</td><td><code>Collections.max(map.values());</code></td></tr><tr><td>3</td><td>Map&lt;Integer, List<Integer>&gt; map</td><td><code>map.get(n).add(b);</code></td></tr></tbody></table><h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>Initialize Set</td><td><code>Set&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;));</code></td></tr><tr><td>2</td><td>remove</td><td><code>set.remove(n);</code></td></tr></tbody></table><h2 id="array"><a class="markdownIt-Anchor" href="#array"></a> Array</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>一维Sort</td><td><code>Arrays.sort(a);</code></td></tr><tr><td>2</td><td>[n][2] pair sort, 先比第一个，再比第二个</td><td><code>Arrays.sort(res, (n1, n2)-&gt;n1[0] == n2[0] ? n1[1] - n2[1] : n1[0] - n2[0]);</code></td></tr><tr><td>3</td><td>数组复制</td><td><code>b = arr.clone();</code></td></tr></tbody></table><h2 id="number"><a class="markdownIt-Anchor" href="#number"></a> Number</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>取整</td><td><code>(int)Math.ceil(a); (int)Math.floor(a);</code></td></tr><tr><td>2</td><td>ASCII</td><td>总128个。A(65)-Z(90), a(97)-z(122).</td></tr><tr><td>3</td><td>异或</td><td><code>1^1=0; 1^0=1; 0^1=1; 0^0=0;</code></td></tr><tr><td>4</td><td>左移</td><td><code>n &lt;&lt; 1; //乘以2</code></td></tr><tr><td>5</td><td>右移</td><td><code>n &gt;&gt; 1; //除以2</code></td></tr><tr><td>6</td><td>无符号右移</td><td><code>n &gt;&gt;&gt; 1; //除以2，忽略符号位，空位以0补齐</code></td></tr><tr><td>7</td><td>二进制中1的个数</td><td><code>Integer.bitCount(n);</code></td></tr><tr><td>8</td><td>移位和加法</td><td><code>cur = (cur &lt;&lt; 1) + root.val; // 括号不能省</code></td></tr></tbody></table><h2 id="convertion"><a class="markdownIt-Anchor" href="#convertion"></a> Convertion</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>String to Integer</td><td><code>Integer.parseInt(str);</code></td></tr><tr><td>2</td><td>Integer to String</td><td><code>String.valueOf(n);</code></td></tr><tr><td>3</td><td>Integer to Double</td><td><code>Double.valueOf(n);</code> or <code>a*1.0;</code></td></tr><tr><td>4</td><td>Queue to List</td><td><code>List list = new ArrayList(q); // 与q顺序一样</code></td></tr><tr><td>5</td><td>Stack to List</td><td><code>List list = new ArrayList(s); // 与s顺序相反</code></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="miscellaneous"><a class="markdownIt-Anchor" href="#miscellaneous"></a> Miscellaneous</h2><table><thead><tr><th>序号</th><th>功能</th><th>代码</th></tr></thead><tbody><tr><td>1</td><td>是否为2的次方</td><td><code>(n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0);</code></td></tr><tr><td>2</td><td>是否为4的次方</td><td><code>(n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0) &amp;&amp; (n % 3 == 1);</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="2019/12/11/Leetcode-5-Longest-Palindromic-Substring/"/>
      <url>2019/12/11/Leetcode-5-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Medium 28.4%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br />Example 1:</p><pre class="highlight"><code class="">Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: &quot;cbbd&quot;Output: &quot;bb&quot;</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>{        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;        <span class="hljs-keyword">char</span>[] ca = s.toCharArray();        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)            dp[i][i] = <span class="hljs-number">1</span>;        String res = <span class="hljs-string">""</span> + ca[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> res_l = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; n; k++){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - k; i++){                <span class="hljs-keyword">int</span> j = i + k;                <span class="hljs-keyword">if</span>(ca[i] != ca[j]){                    dp[i][j] = <span class="hljs-number">0</span>;                } <span class="hljs-keyword">else</span> {                    <span class="hljs-keyword">if</span>(j - i == <span class="hljs-number">1</span> || dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>){                        dp[i][j] = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">if</span>(j - i + <span class="hljs-number">1</span> &gt; res_l){                            res_l = j - i + <span class="hljs-number">1</span>;                            res = s.substring(i, j + <span class="hljs-number">1</span>);                        }                    }                }            }        }        <span class="hljs-keyword">return</span> res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 19.78%<br />Memory: 5.24%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131. Palindrome Partitioning</title>
      <link href="2019/12/11/Leetcode-131-Palindrome-Partitioning/"/>
      <url>2019/12/11/Leetcode-131-Palindrome-Partitioning/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Medium 43.7%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string s, partition s such that every substring of the partition is a palindrome.<br />Return all possible palindrome partitioning of s.<br />Example 1:</p><pre class="highlight"><code class="">Input: &quot;aab&quot;Output:[  [&quot;aa&quot;,&quot;b&quot;],  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目要求返回partition的所有可能性，每一个partition都要把给定string分成全部都是回文的子串。这种要求列举所有可能性的，一般是dfs。画出tree就好写code了。这里先mark一下，等到写dfs系列的时候再来写解析。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) {        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList();        dfs(s, res, <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list)</span></span>{        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span>){            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(list));            <span class="hljs-keyword">return</span>;        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.length(); i++){            <span class="hljs-keyword">if</span>(valid(s, <span class="hljs-number">0</span>, i-<span class="hljs-number">1</span>)){                list.add(s.substring(<span class="hljs-number">0</span>, i));                dfs(s.substring(i), res, list);                list.remove(list.size() - <span class="hljs-number">1</span>);            }        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valid</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>{        <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">while</span>(l &lt; r){            <span class="hljs-keyword">if</span>(s.charAt(l) != s.charAt(r))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            l++;            r--;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 95.53%<br />Memory: 95.45%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>516. Longest Palindromic Subsequence</title>
      <link href="2019/12/11/Leetcode-516-Longest-Palindromic-Subsequence/"/>
      <url>2019/12/11/Leetcode-516-Longest-Palindromic-Subsequence/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemslongest-palindromic-subsequence"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemslongest-palindromic-subsequence"></a> 题目链接 <a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-subsequence/</a></h2><h2 id="题目难度-medium-495"><a class="markdownIt-Anchor" href="#题目难度-medium-495"></a> 题目难度 Medium 49.5%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.<br />Example 1:</p><pre class="highlight"><code class="">Input:&quot;bbbab&quot;Output:4One possible longest palindromic subsequence is &quot;bbbb&quot;.</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input:&quot;cbbd&quot;Output:2One possible longest palindromic subsequence is &quot;bb&quot;.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目问最长的回文子序列有多长。像这种“最”+子串问题，一般都是用动态规划。这里先mark一下，等写动态规划里系列的时候再回来写。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> </span>{        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)            dp[i][i] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; n; k++){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - k; i++){                <span class="hljs-keyword">int</span> j = i + k;                dp[i][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))                    dp[i][j] = Math.max(dp[i][j], dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>);            }        }        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 21.89%<br />Memory: 5.55%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="2019/12/11/Leetcode-125-Valid-Palindrome/"/>
      <url>2019/12/11/Leetcode-125-Valid-Palindrome/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-palindrome/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Easy 33.2%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome.<br />Example 1:</p><pre class="highlight"><code class="">Input: &quot;A man, a plan, a canal: Panama&quot;Output: true</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: &quot;race a car&quot;Output: false</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>这道题就很无聊了，从2000多个踩也能看出来。因为这道题并没有考到什么有用的知识点，只是考判断字符是否是字母或者数字而已。这种题一般不会出现在面试中，因为面试是要让面试官在短短的一道或者两道题中，对你的算法能力有个基本的判断。而这道题并不能达到这个效果却又占一道题的坑，对面试官来说也不是件好事情。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>{        <span class="hljs-keyword">char</span>[] ca = s.toCharArray();        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = s.length() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(l &lt; r){            <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; !valid(ca[l])) l++;            <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; !valid(ca[r])) r--;            <span class="hljs-keyword">if</span>(l &lt; r &amp;&amp; Character.toLowerCase(ca[l]) != Character.toLowerCase(ca[r]))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            l++;            r--;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>{        <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">'a'</span> &amp;&amp; c &lt;= <span class="hljs-string">'z'</span> || c &gt;= <span class="hljs-string">'A'</span> &amp;&amp; c &lt;= <span class="hljs-string">'Z'</span> || c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 96.51%<br />Memory: 100%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>680. Valid Palindrome II</title>
      <link href="2019/12/11/Leetcode-680-Valid-Palindrome-II/"/>
      <url>2019/12/11/Leetcode-680-Valid-Palindrome-II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsvalid-palindrome-ii"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsvalid-palindrome-ii"></a> 题目链接 <a href="https://leetcode.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-palindrome-ii/</a></h2><h2 id="题目难度-easy-354"><a class="markdownIt-Anchor" href="#题目难度-easy-354"></a> 题目难度 Easy 35.4%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.<br />Example 1:</p><pre class="highlight"><code class="">Input: &quot;aba&quot;Output: True</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: &quot;abca&quot;Output: TrueExplanation: You could delete the character 'c'.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>给一个string，允许最多删除一个字符，问能否形成回文串。当面试碰到这样的题目的时候，一定要先问一下“能否形成回文串是可以打乱顺序还是不可以？”。因为两种情况的解法不一样，如果可以打乱顺序，那就是count每个字符的个数；如果不可以打乱，就是判断左半边和右半边是否一样。这里是不允许打乱顺序（问我怎么看出来的？我以为可以打乱顺序写完后提交没通过发现的，手动微笑脸）。所以我们用左右指针l和r来比较字符，如果不相同，就判断[l+1, r]和[l, r-1]。任何一个是回文串就返回true。这里需要一个最基本的判断回文串的函数。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(String s)</span> </span>{        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">char</span>[] ca = s.toCharArray();        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(l &lt; r){            <span class="hljs-keyword">if</span>(ca[l] != ca[r])                <span class="hljs-keyword">return</span> valid(ca, l + <span class="hljs-number">1</span>, r) || valid(ca, l, r - <span class="hljs-number">1</span>);            l++;            r--;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] ca, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>{        <span class="hljs-keyword">while</span>(l &lt; r){            <span class="hljs-keyword">if</span>(ca[l] != ca[r])                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            l++;            r--;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 99.48%<br />Memory: 97.22%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="2019/12/09/Leetcode-206-Reverse-Linked-List/"/>
      <url>2019/12/09/Leetcode-206-Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Easy 58.3%</p><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Reverse a singly linked list.<br />Example :</p><pre class="highlight"><code class="">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p>Follow up:<br />A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>将链表翻转，难点在于对于每一个点都只知道下一个。所以在处理的过程中，在改变next指针的仔细一点就没有问题。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><h4 id="a-iteratively"><a class="markdownIt-Anchor" href="#a-iteratively"></a> a. Iteratively</h4><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>{        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        ListNode cur = head;        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span> &amp;&amp; cur.next != <span class="hljs-keyword">null</span>){            dummy.next = cur.next;            cur.next = dummy.next.next;            dummy.next.next = head;            head = dummy.next;        }        <span class="hljs-keyword">return</span> head;    }}</code></pre><p>通过效率<br />Runtime: 100%<br />Memory: 98.56%</p><h4 id="b-recursively"><a class="markdownIt-Anchor" href="#b-recursively"></a> b. Recursively</h4><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>{        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;        ListNode prev = reverseList(head.next);        head.next.next = head;        head.next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> prev;    }}</code></pre><p>通过效率<br />Runtime: 100%<br />Memory: 98.20%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="2019/12/09/Leetcode-234-Palindrome-Linked-List/"/>
      <url>2019/12/09/Leetcode-234-Palindrome-Linked-List/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemspalindrome-linked-list"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemspalindrome-linked-list"></a> 题目链接 <a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a></h2><h2 id="题目难度-easy-374"><a class="markdownIt-Anchor" href="#题目难度-easy-374"></a> 题目难度 Easy 37.4%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a singly linked list, determine if it is a palindrome.<br />Example 1:</p><pre class="highlight"><code class="">Input: 1-&gt;2Output: false</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: 1-&gt;2-&gt;2-&gt;1Output: true</code></pre><p>Follow up:<br />Could you do it in O(n) time and O(1) space?</p><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>和<a href="https://leetcode.com/problems/palindrome-number" target="_blank" rel="noopener">9. Palindrome Number</a>同出一辙。那题是判断一个整数是不是回文，需要反转数字的后半段。这里判断一个linked list是不是回文，那就反转list的后半段。Follow up里要求用常数空间，反转list的后半段就符合要求。所以这里考的知识点就是找list的中间点和list的反转。找中间点就是快慢指针，当停下来的时候，慢指针指的是后半段的开头，所以需要一个dummy指针的帮助来翻转list，因为不确定head是哪一个。这个dummy可以是慢指针的前一个也可以是随便一个。反转指针也是一项必定掌握的技能，有疑问的小伙伴可以先看看<a href="https://pearmonkey.com/2019/12/09/Leetcode-206-Reverse-Linked-List/">206. Reverse Linked List</a>.</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>{        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-comment">//快慢指针找中间点</span>        ListNode slow = head, fast = head, pre = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>){            pre = slow;            slow = slow.next;            fast = fast.next.next;        }        <span class="hljs-comment">//翻转后半段</span>        ListNode new_head = slow;        <span class="hljs-keyword">while</span>(slow.next != <span class="hljs-keyword">null</span>){            pre.next = slow.next;            slow.next = pre.next.next;            pre.next.next = new_head;            new_head = pre.next;        }        <span class="hljs-comment">//和前半段进行比较</span>        pre.next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; new_head != <span class="hljs-keyword">null</span>){            <span class="hljs-keyword">if</span>(head.val != new_head.val)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            head = head.next;            new_head = new_head.next;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 99.48%<br />Memory: 98.78%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. Palindrome Number</title>
      <link href="2019/12/09/Leetcode-9-Palindrome-Number/"/>
      <url>2019/12/09/Leetcode-9-Palindrome-Number/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2><p><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-number/</a></p><a id="more"></a><h2 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h2><p>Easy 45.8%</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br />Example 1:</p><pre class="highlight"><code class="">Input: 121Output: true</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</code></pre><p>Example 3</p><pre class="highlight"><code class="">Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目要判断一个给定得数字是否是个回文串，但不能直接把int转为string再判断，如果可以的话，那就没什么意思了。既然要判断是否是回文串，那就是左半边和右半边是镜面对称，但是这里是数字，如何找到左半边和右半边呢？首先，负数或者10，20这样的整数是不可能的。剩下的可以让x每次减少最低位，同时用一个变量revert记录这个数，并且x每缩小十倍，revert就放大十倍，最开始x肯定大于revert，当revert大于或者等于x的时候就可以停下来了，因为接着往下走x只能更小，revert只能更大。跳出循环之后，再比较x是否等于revert或者revert/10.</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> revert = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x &gt; revert){            revert = revert * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;            x = x / <span class="hljs-number">10</span>;        }        <span class="hljs-keyword">return</span> x == revert || x == revert / <span class="hljs-number">10</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 73.57%<br />Memory: 5.02%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>409. Longest Palindrome</title>
      <link href="2019/12/08/Leetcode-409-Longest-Palindrome/"/>
      <url>2019/12/08/Leetcode-409-Longest-Palindrome/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接httpsleetcodecomproblemslongest-palindrome"><a class="markdownIt-Anchor" href="#题目链接httpsleetcodecomproblemslongest-palindrome"></a> 题目链接https://leetcode.com/problems/longest-palindrome/</h2><h2 id="题目难度easy-491"><a class="markdownIt-Anchor" href="#题目难度easy-491"></a> 题目难度Easy 49.1%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.<br />This is case sensitive, for example “Aa” is not considered a palindrome here.<br />Note:<br />Assume the length of given string will not exceed 1,010.<br />Example:</p><pre class="highlight"><code class="">Input:&quot;abccccdd&quot;Output:7Explanation:One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目的目的是，由给定的string的字符，能组成的回文串最长是多长。关键点如下：</p><ol><li>这里是问回文串的长度，那么就需要count字符数。</li><li>回文串的可能性：偶回文和奇回文。</li><li>字符串中只包含大写或小写字符。</li><li>字符串长度不会超过1010.</li></ol><p>在开始写code之前，要把整个过程先过一遍，这是一个需要养成的好习惯，因为很有可能自己的第一直觉想法是错误的，如果还没在脑子里过一遍就开始写，等到真的碰到问题了时间就浪费了一大半了。所以，写code应该是最后完成的事情才对，在面试过程中，先将自己的想法提出来与面试官沟通，不仅会大大加分，还有可能在和面试官讨论的过程中发现自己的错误。<br />以这道题为例，题目问最长能组成的回文串是多长。回文由奇和偶，如果由奇数的字符，那肯定奇回文会更长。所以步骤为：</p><ol><li>count每个字符。</li><li>遍历每个count，若出现奇数记录下来。</li><li>对于每一个出现的字符，一定可以用个数是最大的偶数。</li><li>最后结果之前记录的奇数来返回结果。</li></ol><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>{        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray())            count[(<span class="hljs-keyword">int</span>)c]++;        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : count){            <span class="hljs-comment">//取最大的偶数</span>            res += (n / <span class="hljs-number">2</span>) * <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)                flag = <span class="hljs-keyword">true</span>;        }        <span class="hljs-keyword">return</span> flag ? res + <span class="hljs-number">1</span> : res;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100%<br />Memory: 100%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>266. Palindrome Permutation</title>
      <link href="2019/12/07/Leetcode-266-PalindromePermutation/"/>
      <url>2019/12/07/Leetcode-266-PalindromePermutation/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemspalindrome-permutation"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemspalindrome-permutation"></a> 题目链接 <a href="https://leetcode.com/problems/palindrome-permutation/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-permutation/</a></h2><h2 id="题目难度-easy-608"><a class="markdownIt-Anchor" href="#题目难度-easy-608"></a> 题目难度 Easy 60.8%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string, determine if a permutation of the string could form a palindrome.<br />Example 1:</p><pre class="highlight"><code class="">Input: &quot;code&quot;Output: false</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: &quot;aab&quot;Output: true</code></pre><p>Example 3:</p><pre class="highlight"><code class="">Input: &quot;carerac&quot;Output: true</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目很简短也很明确。是需要判断给定的string是否能经过重新排列形成一个回文。所以就count每一个字符的个数就行。有了count之后检查每一个count并记录奇数count，若出现了两次奇数则直接返回false。如果一直没有出现两次奇数则返回true。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPermutePalindrome</span><span class="hljs-params">(String s)</span> </span>{        <span class="hljs-comment">//因为不确定是否只有字母，所以假设s可能包含任何ASCII字符</span>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray())            <span class="hljs-comment">//既然考虑到了所有ASCII字符，就可以直接将char强转为int</span>            count[(<span class="hljs-keyword">int</span>)c]++;        <span class="hljs-keyword">boolean</span> odd_flag = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : count){            <span class="hljs-comment">//如果之前已经出现过奇数字符，现在又出现了，就直接返回false</span>            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; odd_flag == <span class="hljs-keyword">true</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">//上面没有返回false说明目前有可能还没有出现奇数字符</span>            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)                odd_flag = <span class="hljs-keyword">true</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 100%<br />Memory: 100%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 回文串 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>647. Palindromic Substring</title>
      <link href="2019/12/05/Leetcode-647-PalindromicSubstring/"/>
      <url>2019/12/05/Leetcode-647-PalindromicSubstring/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemspalindromic-substrings"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemspalindromic-substrings"></a> 题目链接 <a href="https://leetcode.com/problems/palindromic-substrings/" target="_blank" rel="noopener">https://leetcode.com/problems/palindromic-substrings/</a></h2><h2 id="题目难度-medium-585"><a class="markdownIt-Anchor" href="#题目难度-medium-585"></a> 题目难度 Medium 58.5%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string, your task is to count how many palindromic substrings in this string.<br />The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.<br />Example 1:</p><pre class="highlight"><code class="">Input: &quot;abc&quot;Output: 3Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: &quot;aaa&quot;Output: 6Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目要求给定字符串的所有为回文串的子串。从最简单的开始，不管字符串是什么，每一个字符一定是它的子串，并且也是回文串，例如“abc”中的“a”，“b”，“c”，然后，我们要找是否有更长的子串为回文串。最直接的想法是，从第一个元素（i = 0 : len - 1, O(n)）开始作为子串的开始端，然后以i以及之后的位置作为结束端（j = i : len - 1, O(n)）,这样形成的每一个子串都送去判断一下（O(n)），若为回文，则加入结果集中。这样做的时间复杂度是O(n^3)。我们选择仔细想一想，这个过程中有没有重复的地方，其实所谓的算法的改进，就是将那些重复做的地方识别出来然后剔除，以降低时间复杂度。在刚刚的问题中，如果我们的字符串为“abcba”，当i = 0, j = 4, 子串“abcba”被检查为回文（这一检查的时间复杂度是O(n)）, 这里也就意味着里面的“bcb”和“c”也都是回文。所以，当后面i = 1, j = 3时，我们再次判断“bcb”是否为回文的这一操作就是重复的了。所以，如果从两端开始往中间判断的办法会有重复的，那我们就从中间往两边判断。也就是让每一个字符都当一回 回文串 的中间字符（奇数回文）和中间偏左的字符（偶数回文），时间复杂度为O(2n)，然后向两边延伸判断，时间复杂度为O(n)。整体复杂度为O(2 * n^2)。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-keyword">int</span> res;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>{        res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++){            helper(s, i, i);            helper(s, i, i+<span class="hljs-number">1</span>);        }        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>{        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)){            res++;            i--;            j++;        }    }}</code></pre><h2 id="通过效率"><a class="markdownIt-Anchor" href="#通过效率"></a> 通过效率</h2><p>Runtime: 99.97%<br />Memory: 100%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>862. Shortest Subarray with Sum at Least K</title>
      <link href="2019/12/03/Leetcode-862-ShortestSubarraywithSumatLeastK/"/>
      <url>2019/12/03/Leetcode-862-ShortestSubarraywithSumatLeastK/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemsshortest-subarray-with-sum-at-least-k"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemsshortest-subarray-with-sum-at-least-k"></a> 题目链接 <a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/</a></h2><h2 id="题目难度-hard-228"><a class="markdownIt-Anchor" href="#题目难度-hard-228"></a> 题目难度 Hard 22.8%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.<br />If there is no non-empty subarray with sum at least K, return -1.<br />Example 1:</p><pre class="highlight"><code class="">Input: A = [1], K = 1Output: 1</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: A = [1,2], K = 4Output: -1</code></pre><p>Example 3:</p><pre class="highlight"><code class="">Input: A = [2,-1,2], K = 3Output: 3</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>待完成。。。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Subarray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1177. Can Make Palindrome from Substring</title>
      <link href="2019/11/30/Leetcode-1177-CanMakePalindromeFromSubstring/"/>
      <url>2019/11/30/Leetcode-1177-CanMakePalindromeFromSubstring/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemscan-make-palindrome-from-substring"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemscan-make-palindrome-from-substring"></a> 题目链接 <a href="https://leetcode.com/problems/can-make-palindrome-from-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/can-make-palindrome-from-substring/</a></h2><h2 id="题目难度-medium-325"><a class="markdownIt-Anchor" href="#题目难度-medium-325"></a> 题目难度 Medium 32.5%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string s, we make queries on substrings of s.<br />For each query <code>queries[i] = [left, right, k]</code>, we may rearrange the substring <code>s[left], ..., s[right]</code>, and then choose up to k of them to replace with any lowercase English letter.<br />If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.<br />Return an array <code>answer[]</code>, where <code>answer[i]</code> is the result of the i-th query <code>queries[i]</code>.<br />Note that: Each letter is counted individually for replacement so if for example <code>s[left..right] = &quot;aaa&quot;</code>, and k = 2, we can only replace two of the letters.  (Also, note that the initial string s is never modified by any query.)</p><p>Example :</p><pre class="highlight"><code class="">Input: s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]Output: [true,false,false,true,true]Explanation:queries[0] : substring = &quot;d&quot;, is palidrome.queries[1] : substring = &quot;bc&quot;, is not palidrome.queries[2] : substring = &quot;abcd&quot;, is not palidrome after replacing only 1 character.queries[3] : substring = &quot;abcd&quot;, could be changed to &quot;abba&quot; which is palidrome. Also this can be changed to &quot;baab&quot; first rearrange it &quot;bacd&quot; then replace &quot;cd&quot; with &quot;ab&quot;.queries[4] : substring = &quot;abcda&quot;, could be changed to &quot;abcba&quot; which is palidrome.</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目给一个string，给一些query。问这些query出来的substring是否能在规定的改动条件内组成回文串。比如例子中的[3, 3, 0]，抽出来的子串是d，能替换0个字符，问是否能组成回文串。答案是能。<br />这个题目吧，一把泪。一开始没有认真读题，以为是固定位置的substring，实现完了提交才发现是可以换位置的substring。所以啊，认真审题是成功解题的必要条件之一。既然可以换位置，那么判断这个字符串能否组成回文串就是count每个字符的数量了。按照惯例，count字符个数要么用HashMap要么用int[]。我比较推荐int[]，因为操作简单。因为query的起始点和终点不定，所以我们事先要count每一个位置都有什么信息。这里是一个难点，粗略一想，我需要记录起始点，终点，以及每个字符的个数，这应该是个什么样的数组呢？其实我们就用一个二维数组<code>int[n][26]</code>记录到位置n位置，每个字符出现的总次数，那么中间某一段的字符次数就能相减而得出了，这一点确实比较难想到，那我们就暂时先背下来吧（手动捂脸）。<br />有了每个字符的数量之后，我们就能知道需要经过多少次替换才能变成回文串。这里要注意的是，根据给定的字符串的长度来判断，这个回文是偶数回文还是奇数回文（如果不太了解可以参考一下<a href="http://localhost:4000/2019/11/27/Leetcode-Palindromic/" target="_blank" rel="noopener">这篇文章</a>）。如果我们知道了频率为奇数的字符有n个，那么，偶数回文就需要至少<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个替换，奇数回文就需要至少<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil{\frac{n-1}{2}}\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌉</span></span></span></span>个替换。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title">canMakePaliQueries</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span>[][] queries)</span> </span>{        List&lt;Boolean&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>){                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++)                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]; <span class="hljs-comment">//copy前一个位置的信息</span>            }            dp[i][s.charAt(i) - <span class="hljs-string">'a'</span>]++; <span class="hljs-comment">//添加当前位置的信息</span>        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.length; i++){            <span class="hljs-keyword">int</span>[] query = queries[i];            <span class="hljs-keyword">int</span> odd_count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++){                <span class="hljs-keyword">int</span> count = dp[query[<span class="hljs-number">1</span>]][j]; <span class="hljs-comment">//count是字符j出现的次数</span>                <span class="hljs-keyword">if</span>(query[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>)                    count -= dp[query[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>][j];                odd_count += count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">//如果count是奇数那么odd_count加一</span>            }            <span class="hljs-keyword">if</span>((query[<span class="hljs-number">1</span>] - query[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-comment">//判断给定字符串长度是偶数还是奇数</span>                odd_count--;            res.add(query[<span class="hljs-number">2</span>] * <span class="hljs-number">2</span> &gt;= odd_count);        }        <span class="hljs-keyword">return</span> res;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 回文串 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>267. Palindrome Permutation II</title>
      <link href="2019/11/30/Leetcode-267-PalindromePermutationII/"/>
      <url>2019/11/30/Leetcode-267-PalindromePermutationII/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接-httpsleetcodecomproblemspalindrome-permutation-ii"><a class="markdownIt-Anchor" href="#题目链接-httpsleetcodecomproblemspalindrome-permutation-ii"></a> 题目链接 <a href="https://leetcode.com/problems/palindrome-permutation-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-permutation-ii/</a></h2><h2 id="题目难度-medium-348"><a class="markdownIt-Anchor" href="#题目难度-medium-348"></a> 题目难度 Medium 34.8%</h2><a id="more"></a><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.<br />Example 1:</p><pre class="highlight"><code class="">Input: &quot;aabb&quot;Output: [&quot;abba&quot;, &quot;baab&quot;]</code></pre><p>Example 2:</p><pre class="highlight"><code class="">Input: &quot;abc&quot;Output: []</code></pre><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>题目还是很简明，就是给定一个string，返回所有为回文的permutation。我们就仔细想一下，要我返回所有为回文的permutation，首先给我的这个字符串至少要有可能是一个回文吧。如果做这个前期判断呢？因为回文是有偶数回文和奇数回文（如果不熟悉，可以先参考一下<a href="http://localhost:4000/2019/11/27/Leetcode-Palindromic/" target="_blank" rel="noopener">这篇文章</a>），所以我们统计一下每个字符出现的次数，如果次数为奇数的字符是小于或者等于1的话，那么这个字符串就是可以组成回文串的。<br />如果得知这个字符串可以组成回文，brute-force的想法就是列举出所有的permutation（时间复杂度为O(n!)），再对每一种可能性进行回文判断（时间复杂度为O(n/2)），如果是回文就加入结果。这样的一套想法下来，总的时间复杂度是O(n!*n/2)，其中n是给定string的长度。<br />那么，有没有可能对brute-force进行改进呢？答案当然是肯定的。在前期判断是否有可能组成回文的过程中，我们应该是用一个HashMap或者长度为128（为什么是128呢，因为ASCII码总共有128个）的int[]数组来记录每个字符的个数。有了这个信息，那这道题就变成了和<a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. Generate Parentheses</a>很相似了，不过并不需要数左右的个数，只需要同时在两边加上一样的字符。</p><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><pre class="highlight"><code class="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generatePalindromes</span><span class="hljs-params">(String s)</span> </span>{        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];        String tmp = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c  : s.toCharArray()) <span class="hljs-comment">//记录每个字符的个数</span>            map[c]++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; map.length; i++){            <span class="hljs-keyword">if</span>(map[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)                tmp = tmp + (<span class="hljs-keyword">char</span>)i; <span class="hljs-comment">//如果遇到奇数频率的字符就记录下来</span>        }        <span class="hljs-keyword">if</span>(tmp.length() &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res; <span class="hljs-comment">//如果奇数频率的字符超过一个就不满足组成回文条件，直接返回</span>        generate(s.length(), res, map, tmp); <span class="hljs-comment">//满足条件，就dfs生成回文，要把奇数字符传进去，没有的话就是""</span>        <span class="hljs-keyword">return</span> res;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, List&lt;String&gt; res, <span class="hljs-keyword">int</span>[] map, String tmp)</span></span>{        <span class="hljs-keyword">if</span>(tmp.length() == n){            res.add(tmp);            <span class="hljs-keyword">return</span>;        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; map.length; i++){            <span class="hljs-keyword">if</span>(map[i] &gt; <span class="hljs-number">1</span>){                map[i] -= <span class="hljs-number">2</span>;                generate(n, res, map, (<span class="hljs-keyword">char</span>)i + tmp + (<span class="hljs-keyword">char</span>)i);                map[i] += <span class="hljs-number">2</span>;            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 回文串 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT | 如何取消主题加载的滑动效果</title>
      <link href="2019/11/29/hexo1/"/>
      <url>2019/11/29/hexo1/</url>
      
        <content type="html"><![CDATA[<p>NexT主题是一个易用又完善的博客主题，内置的风格也就是scheme也有四种以供选择。</p><a id="more"></a><p>但是每个风格都带有同样的滑动效果，就是每点击一个item，加载的页面都以animation的效果呈现。为了在夹缝中透露一点小个性的倔强，想取消这种效果也很简单。</p><p>只需要修改主题文件，也就是<code>/themes/next/_config.yml</code>。<br />用编辑器打开这个文件，然后搜索<code>motion</code>，作出如下修改就行了。</p><pre class="highlight"><code class="">motion:  enable: false</code></pre>]]></content>
      
      
      <categories>
          
          <category> 制作博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>期刊系列JF | 市场信息如何反应在股价中?</title>
      <link href="2019/11/29/jf2/"/>
      <url>2019/11/29/jf2/</url>
      
        <content type="html"><![CDATA[<h2 id="原文题目"><a class="markdownIt-Anchor" href="#原文题目"></a> 原文题目</h2><p>《Continuous Auctions and Insider Trading？》-- 连续时间“拍卖”与知情交易</p><a id="more"></a><h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>作者提供了一个连续时间下的动态均衡模型用于研究（1）价格所包含的信息，（2）投机市场的流通性特征，（3）信息对于知情者的价值。模型包括三类交易者：（1）唯一的知情者(风险中性)，（2）随机的噪声交易者（为方便理解我们称其为“不知情者”），（3）充分竞争市场下的做市商(风险中性)(为方便理解我们称其为“定价者”)。知情者以最优方式进行知情交易，同时噪声交易者的交易行为为知情交易提供了掩护。当“拍卖”的时间间隔缩短至0，我们即可得到一个连续时间下的模型。在这样一个均衡下，价格变化符合布朗宁运动，市场深度为常数，所有知情者的信息将被包含在市场价格里。</p><h2 id="关于作者"><a class="markdownIt-Anchor" href="#关于作者"></a> 关于作者</h2><p>AlbertP. Kyle 现为美国马里兰大学金融系教授。本文介绍的（Kyle1985）是作者于1985年发表于顶级期刊Econometrica的作品。</p><h2 id="关于文章"><a class="markdownIt-Anchor" href="#关于文章"></a> 关于文章</h2><p>假设，有一只股票现价50，但你知道在明天它的价值将为100，你又是唯一知道这个消息的人，你会买这只股票吗？你会买多少？<br />首先，请读者注意，虽然上一刻的股价为50，但你成交的价格将由做市商根据他掌握的信息来确定。做市商掌握的信息为整个市场在这一刻的总订单量（包括你的订单）。<br />请思考一下你的回答。</p><p>（Kyle 1985）给出的答案是，你不该买的太多（暴露了你的信息），也不该买的太少（还可以赚的更多）。<br />你买的数量应该由以下两个因素决定：</p><ol><li>你的信息有多大的优势；（在本例中，你是唯一的知情者，100-50为你的信息的优势）</li><li>市场上有多少不知情者交易。</li></ol><p>为什么是上述两个因素？<br />首先，请明确一下你的目标是什么？赚更多的钱（根据现有的信息优势）！<br />那么，你的目标可以表示为求这个方程的最大值：<code>(100-P)*X</code>.</p><pre class="highlight"><code class="">P：做市商给出的价格；X：你购买该股票的数量；100：本例中提到的你所拥有的准确价值信息。</code></pre><p>所以，该方程表示的是一股赚的钱乘以你购买的股票数量。因为X是你自己决定的，所以该方程中仅有P为未知量。<br />现在，请考虑一下做市商是如何定价的呢？<br />我们还是先来明确一下做市商的目标：在竞争激烈的市场中，做市商的目标是尽可能的将价格准确的定为真实价值。（读者可以理解为，在竞争激烈的环境下，他不这么做会被别的做市商抢生意）<br />但是，真实价值是100，只有你知道，并且你会根据这个信息优势来确定你的购买量，即X。<br />做市商通过观察到你的购买量X来推测真实价值。可是他拥有的唯一信息是市场上这一刻总的订单量（你的订单+所有不知情者的订单），表示为X+U.<br />这里U代表所有不知情者的订单。U是随机的，或多或少，或买或卖，这就为做市商定价增加了难度。</p><p>这下好了，你要买的数量随做市商给的价格变化（最大化你的收益方程），做市商的定价随你的购买数量变化（推测你所拥有的真实价值）！咋办？找不动点（fixed point）！（Kyle 1985）的假设保证了唯一的不动点方程。这个不动点方程确定了你的购买量（方程）与做市商的定价（方程），而且对双方（你和做市商）都是最优的。也就是说，任何偏离该不动点方程的行为都会给自己造成损失。</p><p>（Kyle1985）的模型非常简单却强大：</p><ol><li>从你的角度来说：<br />1）你知道的信息越有价值，你就是说你所知道的真实价值与现有的股票价格相差（本例中为100-50）越大，你的购买量越大；<br />2）不知情交易者的交易量U越大（为做市商定价提供了难度），你的购买量越大。</li><li>从做市商的角度来说：<br />1）这一刻总的订单量(X+U)越大，他定的价格越高；<br />2）不知情交易者的交易量U越小，他就越容易从(X+U)中推测出你的交易量X，定的价格也就越高。</li></ol><p>当然，完美的模型不存在，（Kyle 1985）最大的问题在于他无法解释现实世界中频频发生的股票操控。在他的不动点方程中，任何操控都不会带来更好的收益。<br />后面我们会再介绍到别的论文讨论：如果市场中普遍存在追涨的交易者，操控可以利用这一点获利。但是追涨的行为是不理性的，不应该在市场中普遍存在。所以股价操控为何会获利仍是学界热烈讨论的话题。<br />除此之外，不知情交易者，也称为噪声交易者（noisetrader），为何交易也是有趣却未得到很好解释的问题。（Kyle1985）为了不偏离主题，没有就此展开讨论。读者可以理解为：散户意外收获了一笔不菲的年终奖，随机选择了一只股票进行投资；或是为了买房而卖掉了此前投资的股票。有机会我们会提供有关行为金融学从心理学角度解释噪声交易的推送。</p>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JF论文 </tag>
            
            <tag> 金融 </tag>
            
            <tag> 股票 </tag>
            
            <tag> 投资 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>期刊系列JF | 频繁买卖对收益的损害</title>
      <link href="2019/11/27/jf1/"/>
      <url>2019/11/27/jf1/</url>
      
        <content type="html"><![CDATA[<h2 id="原文信息"><a class="markdownIt-Anchor" href="#原文信息"></a> 原文信息</h2><p>《Trading Is Hazardous to Your Wealth: The Common Stock Investment Performance of Individual Investors》</p><a id="more"></a><p>于2000年发表于国际顶级金融期刊 金融杂志 Journal of Finance.</p><p>原文作者: 巴伯（Brad Barber） 和 欧丁（Terrance Odean）</p><p><strong>频繁买卖是否影响股民投资的回报？</strong><br />影响！<br />频繁买卖会降低股民的投资回报！但只影响净收益（也就是你要收进口袋的钱），而不影响你的总收益。</p><p>数据表明：<br />1）换手率更低的投资组合 有更高的 净收益<br />2）投资组合的换手率       不影响      总收益</p><p>也就是说 股民们在 误认为 自己知道行情的情况下进行买卖操作，可事实上这些交易并没有给他们带来真正的收益（虽然也没有损害他们的收益），但高换手率造成了更高的交易费用，进而影响了股民们真正可以收入钱袋子的收益。<br />这个实证结果是 爆炸新闻！因为它通过挑战 一篇名声远扬的的文章，《On the impossibility of informationally effecient markets》，中的推断挑战了有效市场的支持者们。前诺奖得主Stiglitz在上文中运用理性预期手段，研究了在 有交易成本和信息获取成本 的情况下，有效市场将存在怎样的均衡。具体来说，大佬认为理性投资者只有在知道自己 可获得的收益 大于或等于 所有成本 的情况下才会进行交易，而由此得出的推断是 不论股民换手率（买卖次数）的高低（多少），他们的 净收益 应该接近，而买卖次数更多的股民会有 明显更高的 总收益（考虑到交易成本）。<br />实证结果明显倾向于支持 过度自信理论（出自行为金融学）。该理论认为投资者的过分自信，也就是在“错误”的认为自己知道股价走势的情况下，进行了过多的没有价值的买入和卖出。过分自信理论预测 换手率更高的 股民有 更低的 净收益，而没有对总收益作出预测。<br />其他“看似”可能的解释有：1）流通性需要，2）投资组合调整，3）税务动机 和 4）好赌心理。对于以上解释作者均做出了反驳，因为他们均无法解释高达 75% 的年平均换手率。<br />作者还提到了 冲量效应 对股民的影响，结果为 普通股民倾向于 反冲量效应 而为之。 另一篇于2008年发表于JF的文章《Individual Investor Trading and Stock Returns》更详尽的研究了这种现象。</p><h2 id="关于作者"><a class="markdownIt-Anchor" href="#关于作者"></a> 关于作者</h2><p>两位 行为金融学 的学界大佬，巴伯在 芝加哥大学 取得博士学位目前就职于 加州大学戴维斯分校，欧丁毕业于 加州大学伯克利分校 目前于本校任教。<br />两位 行为金融学大佬 于2000年前后在世界各大顶级期刊发表数篇行为金融学实证文章，笔者将会在接下来的几次推送中介绍他们的文章。</p><h2 id="文章摘要"><a class="markdownIt-Anchor" href="#文章摘要"></a> 文章摘要</h2><p>持有普通股的个人投资者将会为积极（频繁）交易的行为付出巨大的代价。本文研究样本为1991-1996在某一大型折扣股票经纪公司进行交易的6万6千个家庭。其中交易最频繁的个人投资者群体平均得到11.4%年回报，而同时期平均市场年回报为17.9%。样本中平均家庭得到16.4%的年回报，投资偏好为高beta（收益与风险相对于市场成正比增大），小型（公司市值小），价值型（公司账面价值大于市值）普通股，平均年换手率为75%（一年中买卖股票的价值占平均股票总价值的比例）。投资者的过度自信可以解释高换手率和由此导致的较差回报。我们要传达的核心信息是：交易将会损害你的财富。</p><h2 id="样本数据介绍"><a class="markdownIt-Anchor" href="#样本数据介绍"></a> 样本数据介绍</h2><p>时间：1991.1-1996.12<br />来源：某大型折扣股票经纪公司<br />总量：六年中7万8千有交易记录的家庭，6万6千可用（至少持有股票一个月）<br />其他相关信息：<br />1）平均每家庭持有4.3只（公司）股票，总价值4万7千美元<br />2）在1996年12月，这些家庭持有总价值为 45亿美元 的股票<br />3）六年中，投资者共卖出 12.1亿美元 的股票，买入 12.2亿美元 的股票<br />4）平均股票成交价为 $31</p><h2 id="高昂的交易成本"><a class="markdownIt-Anchor" href="#高昂的交易成本"></a> 高昂的交易成本</h2><p>平均来说，一轮交易下来交易者会损失4%在交易成本上。<br />买卖价差：交易者平均每笔买入付出 0.3%，卖出付出 0.7%（在对共同基金的研究中也有相似结论，0.2%买入，0.6%卖出，参照 Carhart1997）<br />手续费：对于所有高于1000美元的交易：买入 1.58%， 卖出 1.45%<br />               对于所有交易：买入 2.1%，卖出 3.1%</p><h2 id="计算方法"><a class="markdownIt-Anchor" href="#计算方法"></a> 计算方法</h2><p>交易成本主要有手续费（主要于股票经理人赚取）和买卖价差（买入价格会比卖出价格高）。作者以百分比的形式报告了交易成本。<br />1）卖出价差： 当日收盘价/卖出价 - 1<br />2）买入价差： -（当日收盘价/买入价 - 1）<br />3）手续费： 手续费/成交总金额<br />作者认为他们对买卖价差的计算方式考虑到了一单交易对市场的所有可能造成的影响。</p><h2 id="高频率的买卖"><a class="markdownIt-Anchor" href="#高频率的买卖"></a> 高频率的买卖</h2><p>个人投资者平均每年会更新自己 75% 的股票，有趣的是这个数字与此前文献（Carhart1997）计算出的共同基金77%的年换手率很接近。</p><h2 id="计算方法-2"><a class="markdownIt-Anchor" href="#计算方法-2"></a> 计算方法</h2><p>月买入换手率: 上月买入的股票在上月月初的总价值 / 本月月初投资组合在本月月初的总价值。<br />月买出换手率: 本月卖出的股票在本月月初的总价值 / 本月月初投资组合在本月月初的总价值。</p><h2 id="投资回报"><a class="markdownIt-Anchor" href="#投资回报"></a> 投资回报</h2><p>1）相比于 投资者频繁的交易 所得的真实回报，他们若采用简单的 买入-持有策略 会得到更高的收益<br />2）投资者更倾向于持有 小型股，市场参数约为1.1（略大于市场波动），没有价值股投资倾向。（机构投资者明显的偏好持有 大型股）<br />3）小型股+高市场风险 策略 在1991-1996年期间为个人投资者提供了良好的回报</p><h2 id="计算方法-3"><a class="markdownIt-Anchor" href="#计算方法-3"></a> 计算方法</h2><p>作者使用了 1）加权总收益 和 2）加权净收益 两种方式来表现投资者回报，并使用了以下四种回报测度：<br />1）超自基准回报： 将投资者（有买卖调整的）真实收益 - 投资者若持有年初的投资组合（保持不变）的收益<br />2）超市场回报： 将投资者真实收益 - 市场指数回报<br />3）超CAPM回报： 市场无法解释的回报（将市场指数作为唯一变量进行 回归分析后所得的 截距）<br />4）超三因子回报： 市场，公司规模和价值投资策略均无法解释的回报（将三因子作为自变量进行 回归分析后所得的 截距）</p><p><strong>值得一提的是作者提到了第五种可能的测度：夏普率，但是因为作者使用的样本并不是每个开户人的所有投资组合，以此样本估计的夏普率会高估部分个人投资者所承担的风险。</strong><br /><strong>为了减少因样本数据时间短引起的错误结论，作者将样本中的 72个月 分为20个月的下降期 和 52个月的上升期 分别进行分析，结果相近。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JF论文 </tag>
            
            <tag> 金融 </tag>
            
            <tag> 股票 </tag>
            
            <tag> 投资 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文字符串系列</title>
      <link href="2019/11/27/Leetcode-Palindromic/"/>
      <url>2019/11/27/Leetcode-Palindromic/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>回文字符串英文叫 palindromic string/substring。所谓“回文”，就是正着读和反着读都是相同的字符序列，例如“level”，“noon”。所有回文字符串可以分为两大类：1）奇数回文，如“level”，中间有一个单独字符，两边延展的字符都相同；2）偶数回文，如“noon”，没有中间单独字符，对折的字符都相同。所以，在遇到回文字符串的题，这两种都要考虑进来。</p><a id="more"></a><p>首先，先不看题，我们自己能想到的问题有哪些。</p><ol><li>最基本的是判断一个字符串是否是回文串。完成这个功能有两种方式：<br />a. 从最左和最右开始往里检查</li></ol><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindromic</span><span class="hljs-params">(String s)</span></span>{  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = s.length() - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span>(l &lt; r){      <span class="hljs-keyword">if</span>(s.charAt(l) != s.charAt(r))          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      l++;      r--;  }  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;}</code></pre><p>b. 从中间开始，往两边检查</p><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindromic</span><span class="hljs-params">(String s)</span></span>{      <span class="hljs-keyword">int</span> len = s.length();      <span class="hljs-keyword">int</span> l = (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;      <span class="hljs-comment">//如果长度是奇数，r与l相等；是偶数，则l+1</span>    <span class="hljs-keyword">int</span> r = len % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? l + <span class="hljs-number">1</span> : l;      <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; len){          <span class="hljs-keyword">if</span>(s.charAt(l) != s.charAt(r))              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;          l--;          r++;      }      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  }</code></pre><ol start="2"><li>一些字符能否组成一个回文串。这个判断只需要count每个字符的出现次数，考虑的可能性还是偶回文和奇回文：</li></ol><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">CanBePalindromic</span><span class="hljs-params">(String s)</span></span>{    <span class="hljs-comment">//因为不确定是否只有字母，所以假设s可能包含任何ASCII字符</span>    <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray())        <span class="hljs-comment">//既然考虑到了所有ASCII字符，就可以直接将char强转为int</span>        count[(<span class="hljs-keyword">int</span>)c]++;    <span class="hljs-keyword">boolean</span> odd_flag = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : count){        <span class="hljs-comment">//如果之前已经出现过奇数字符，现在又出现了，就直接返回false</span>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; odd_flag == <span class="hljs-keyword">true</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//上面没有返回false说明目前有可能还没有出现奇数字符</span>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)            odd_flag = <span class="hljs-keyword">true</span>;    }    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  }</code></pre><h2 id="题目列表"><a class="markdownIt-Anchor" href="#题目列表"></a> 题目列表</h2><p>到目前为止（12/5/2019），在Leetcode里搜索Palindrome关键字会出现24道题，6道easy，7道medium，11道hard。说明回文串这个知识点是可以出到很难的题的。下面的列表中列出了easy和medium的题目，在最后一列中列出了每道题考察的关键知识点。如果在以后碰到回文串的题，就尽可能往这些知识点上想，大部分都应该能想出来。</p><table><thead><tr><th>题号</th><th>题目</th><th>难度</th><th>接受率</th><th>知识点</th><th>解答</th></tr></thead><tbody><tr><td>266</td><td><a href="https://leetcode.com/problems/palindrome-permutation" target="_blank" rel="noopener">Palindrome Permutation</a></td><td>Easy</td><td>60.8%</td><td>回文字符数</td><td><a href="https://pearmonkey.com/2019/12/07/Leetcode-266-PalindromePermutation/">link</a></td></tr><tr><td>409</td><td><a href="https://leetcode.com/problems/longest-palindrome" target="_blank" rel="noopener">Longest Palindrome</a></td><td>Easy</td><td>49.1%</td><td>回文字符数</td><td><a href="https://pearmonkey.com/2019/12/08/Leetcode-409-Longest-Palindrome/">link</a></td></tr><tr><td>9</td><td><a href="https://leetcode.com/problems/palindrome-number" target="_blank" rel="noopener">Palindrome Number</a></td><td>Easy</td><td>45.8%</td><td>回文，integer取digit</td><td><a href="https://pearmonkey.com/2019/12/09/Leetcode-9-Palindrome-Number/">link</a></td></tr><tr><td>234</td><td><a href="https://leetcode.com/problems/palindrome-linked-list" target="_blank" rel="noopener">Palindrome Linked List</a></td><td>Easy</td><td>37.4%</td><td>回文，反转list</td><td><a href="https://pearmonkey.com/2019/12/09/Leetcode-234-Palindrome-Linked-List/">link</a></td></tr><tr><td>680</td><td><a href="https://leetcode.com/problems/valid-palindrome-ii" target="_blank" rel="noopener">Valid Palindrome II</a></td><td>Easy</td><td>35.4%</td><td>回文</td><td><a href="https://pearmonkey.com/2019/12/11/Leetcode-680-Valid-Palindrome-II/">link</a></td></tr><tr><td>125</td><td><a href="https://leetcode.com/problems/valid-palindrome" target="_blank" rel="noopener">Valid Palindrome</a></td><td>Easy</td><td>33.2%</td><td>回文，字符判断</td><td><a href="https://pearmonkey.com/2019/12/11/Leetcode-125-Valid-Palindrome/">link</a></td></tr><tr><td>647</td><td><a href="https://leetcode.com/problems/palindromic-substrings" target="_blank" rel="noopener">Palindromic Substrings</a></td><td>Medium</td><td>58.5%</td><td>回文第二种判断</td><td><a href="https://pearmonkey.com/2019/12/05/Leetcode-647-PalindromicSubstring/">link</a></td></tr><tr><td>516</td><td><a href="https://leetcode.com/problems/longest-palindromic-subsequence" target="_blank" rel="noopener">Longest Palindromic Subsequence</a></td><td>Medium</td><td>49.5%</td><td>回文，动态规划</td><td><a href="https://pearmonkey.com/2019/12/11/Leetcode-516-Longest-Palindromic-Subsequence/">link</a></td></tr><tr><td>131</td><td><a href="https://leetcode.com/problems/palindrome-partitioning" target="_blank" rel="noopener">Palindrome Partitioning</a></td><td>Medium</td><td>43.7%</td><td>回文，dfs</td><td><a href="https://pearmonkey.com/2019/12/11/Leetcode-131-Palindrome-Partitioning/">link</a></td></tr><tr><td>267</td><td><a href="https://leetcode.com/problems/palindrome-permutation-ii" target="_blank" rel="noopener">Palindrome Permutation II</a></td><td>Medium</td><td>34.9%</td><td>回文生成</td><td><a href="https://pearmonkey.com/2019/11/30/Leetcode-267-PalindromePermutationII/">link</a></td></tr><tr><td>1177</td><td><a href="https://leetcode.com/problems/can-make-palindrome-from-substring" target="_blank" rel="noopener">Can Make Palindrome from Substring</a></td><td>Medium</td><td>32.5%</td><td>回文，动态规划</td><td><a href="https://pearmonkey.com/2019/11/30/Leetcode-1177-CanMakePalindromeFromSubstring/">link</a></td></tr><tr><td>5</td><td><a href="https://leetcode.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">Longest Palindromic Substring</a></td><td>Medium</td><td>28.4%</td><td>回文，动态规划</td><td><a href="https://pearmonkey.com/2019/12/11/Leetcode-5-Longest-Palindromic-Substring/">link</a></td></tr><tr><td>866</td><td><a href="https://leetcode.com/problems/prime-palindrome" target="_blank" rel="noopener">Prime Palindrome</a></td><td>Medium</td><td>22.2%</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
